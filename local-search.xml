<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeedCode-Day11</title>
    <link href="/2023/12/24/LeedCode-20231224/"/>
    <url>/2023/12/24/LeedCode-20231224/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-找出两数组的不同"><a href="#1-找出两数组的不同" class="headerlink" title="1. 找出两数组的不同"></a>1. 找出两数组的不同</h1><p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：</p><ul><li>answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。</li><li>answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。<br>注意：列表中的整数可以按 任意 顺序返回。<br><img src="/img/%E6%89%BE%E5%87%BA%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findDifference</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result1;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> point1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> point2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> number1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> number2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        nums1.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>()), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>        nums2.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>()), nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(point1&lt;n1 &amp;&amp; point2&lt;n2)&#123;<br>            number1 = nums1[point1];<br>            number2 = nums2[point2];<br>            <span class="hljs-keyword">if</span>(number1 == number2)&#123;<br>                point1++;<br>                point2++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(number1&lt;number2)&#123;<br>                result2.<span class="hljs-built_in">push_back</span>(number1);<br>                point1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(number2&lt;number1)&#123;<br>                result1.<span class="hljs-built_in">push_back</span>(number2);<br>                point2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(point1&lt;n1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = point1; i&lt;n1; i++)&#123;<br>                result2.<span class="hljs-built_in">push_back</span>(nums1[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(point2&lt;n2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = point2; i&lt;n2; i++)&#123;<br>                result1.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>            &#125;<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(result2);<br>        result.<span class="hljs-built_in">push_back</span>(result1);<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="2-执行逐位运算使字符串相等"><a href="#2-执行逐位运算使字符串相等" class="headerlink" title="2.  执行逐位运算使字符串相等"></a>2.  执行逐位运算使字符串相等</h1><p>给你两个下标从 0 开始的 二元 字符串 s 和 target ，两个字符串的长度均为 n 。你可以对 s 执行下述操作 任意 次：</p><ul><li>选择两个 不同 的下标 i 和 j ，其中 0 &lt;&#x3D; i, j &lt; n 。</li><li>同时，将 s[i] 替换为 (s[i] OR s[j]) ，s[j] 替换为 (s[i] XOR s[j]) 。<br>例如，如果 s &#x3D; “0110” ，你可以选择 i &#x3D; 0 和 j &#x3D; 2，然后同时将 s[0] 替换为 (s[0] OR s[2] &#x3D; 0 OR 1 &#x3D; 1)，并将 s[2] 替换为 (s[0] XOR s[2] &#x3D; 0 XOR 1 &#x3D; 1)，最终得到 s &#x3D; “1110” 。</li></ul><p>如果可以使 s 等于 target ，返回 true ，否则，返回 false 。<br><img src="/img/%E6%89%A7%E8%A1%8C%E9%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makeStringsEqual</span><span class="hljs-params">(string s, string target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; s_map;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; target_map;<br>        <span class="hljs-type">bool</span> flag;<br><br>        s_map[<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-number">0</span>;<br>        s_map[<span class="hljs-string">&#x27;1&#x27;</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            s_map[s[i]]++;<br>            target_map[target[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s==target || (target_map[<span class="hljs-string">&#x27;1&#x27;</span>]&amp;&amp;s_map[<span class="hljs-string">&#x27;1&#x27;</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-矩阵中的幸运数"><a href="#3-矩阵中的幸运数" class="headerlink" title="3. 矩阵中的幸运数"></a>3. 矩阵中的幸运数</h1><p>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数 是指矩阵中满足同时下列两个条件的元素：</p><ul><li>在同一行的所有元素中最小</li><li>在同一列的所有元素中最大<br><img src="/img/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> column = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">max_list</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, INT_MAX));<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">min_list</span><span class="hljs-params">(column,<span class="hljs-number">0</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;column; j++)&#123;<br>                <span class="hljs-type">int</span> num = matrix[i][j];<br>                <span class="hljs-keyword">if</span>(max_list[i][<span class="hljs-number">0</span>] &gt; num)&#123;<br>                    max_list[i][<span class="hljs-number">0</span>] = num;<br>                    max_list[i][<span class="hljs-number">1</span>] = j;<br>                &#125;<br>                min_list[j] = <span class="hljs-built_in">max</span>(min_list[j], num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-type">int</span> c = max_list[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(max_list[i][<span class="hljs-number">0</span>] == min_list[c] &amp;&amp; max_list[i][<span class="hljs-number">0</span>] == matrix[i][c])&#123;result.<span class="hljs-built_in">push_back</span>(max_list[i][<span class="hljs-number">0</span>]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="4-警告一小时内使用相同员工卡大于等于三次的人"><a href="#4-警告一小时内使用相同员工卡大于等于三次的人" class="headerlink" title="4. 警告一小时内使用相同员工卡大于等于三次的人"></a>4. 警告一小时内使用相同员工卡大于等于三次的人</h1><p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。</p><p>给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。</p><p>使用时间的格式是 24小时制 ，形如 “HH:MM” ，比方说 “23:51” 和 “09:49” 。</p><p>请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。</p><p>请注意 “10:00” - “11:00” 视为一个小时时间范围内，而 “22:51” - “23:52” 不被视为一小时时间范围内。<br><img src="/img/%E8%AD%A6%E5%91%8A%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%91%98%E5%B7%A5%E5%8D%A1%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%89%E6%AC%A1%E7%9A%84%E4%BA%BA.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">alertNames</span><span class="hljs-params">(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        unordered_map&lt;string, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mapping;<br>        <span class="hljs-type">int</span> n = keyName.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> hour;<br>            <span class="hljs-type">int</span> minute;<br>            <br>            hour = <span class="hljs-number">10</span>*(keyTime[i][<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + keyTime[i][<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            minute = <span class="hljs-number">10</span>*(keyTime[i][<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + keyTime[i][<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            minute = (minute + <span class="hljs-number">60</span>*hour);<br>            mapping[keyName[i]].<span class="hljs-built_in">push_back</span>(minute);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mapping.<span class="hljs-built_in">begin</span>(); it!=mapping.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; time_list = it-&gt;second;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">sort</span>(time_list.<span class="hljs-built_in">begin</span>(),time_list.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;time_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-type">int</span> reference = time_list[i];<br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> index = i;<br>                <span class="hljs-keyword">while</span>((i&lt;time_list.<span class="hljs-built_in">size</span>()) &amp;&amp; ((<span class="hljs-built_in">abs</span>(reference-time_list[i]))&lt;=<span class="hljs-number">60</span>))&#123;<br>                    cnt++;<br>                    i++;<br>                &#125;<br>                i = index;<br>                <span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">3</span>)&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;result.<span class="hljs-built_in">push_back</span>(it-&gt;first);&#125;<br>        &#125;<br>        <span class="hljs-comment">//sort(result.begin(),result.end(), [&amp;](string &amp;a, string &amp;b) &#123;return (a[0]-&#x27;a&#x27;)&lt;(b[0]-&#x27;a&#x27;);&#125;);</span><br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-坏了的计算器"><a href="#5-坏了的计算器" class="headerlink" title="5. 坏了的计算器"></a>5. 坏了的计算器</h1><p>在显示着数字 startValue 的坏计算器上，我们可以执行以下两种操作：</p><ul><li>双倍（Double）：将显示屏上的数字乘 2；</li><li>递减（Decrement）：将显示屏上的数字减 1 。<br>给定两个整数 startValue 和 target 。返回显示数字 target 所需的最小操作数。<br><img src="/img/%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">brokenCalc</span><span class="hljs-params">(<span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cycle = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(startValue &lt; target)&#123;<br>            startValue *=<span class="hljs-number">2</span>;<br>            res++;<br>            cycle++;<br>        &#125;<br>        diff = startValue - target;<br>        <span class="hljs-keyword">while</span>(diff != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> d = diff/(<span class="hljs-number">1</span> &lt;&lt; (cycle));<br>            diff -= d*(<span class="hljs-number">1</span> &lt;&lt; (cycle));<br>            cycle = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,cycle<span class="hljs-number">-1</span>);<br>            res += d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;                              <br></code></pre></td></tr></table></figure></li></ul><h1 id="6-最长上传前缀"><a href="#6-最长上传前缀" class="headerlink" title="6. 最长上传前缀"></a>6. 最长上传前缀</h1><p>给你一个 n 个视频的上传序列，每个视频编号为 1 到 n 之间的 不同 数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 最长上传前缀 。</p><p>如果 闭区间 1 到 i 之间的视频全部都已经被上传到服务器，那么我们称 i 是上传前缀。最长上传前缀指的是符合定义的 i 中的 最大值 。</p><p>请你实现 LUPrefix 类：</p><ul><li>LUPrefix(int n) 初始化一个 n 个视频的流对象。</li><li>void upload(int video) 上传 video 到服务器。</li><li>int longest() 返回上述定义的 最长上传前缀 的长度。<br><img src="/img/%E6%9C%80%E9%95%BF%E4%B8%8A%E4%BC%A0%E5%89%8D%E7%BC%80.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LUPrefix</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited;<br>    <span class="hljs-type">int</span> length;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LUPrefix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            visited.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upload</span><span class="hljs-params">(<span class="hljs-type">int</span> video)</span> </span>&#123;<br>        visited[video]=<span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longest</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(length+<span class="hljs-number">1</span>&lt;=n &amp;&amp; visited[length+<span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>)&#123;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LUPrefix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LUPrefix* obj = new LUPrefix(n);</span><br><span class="hljs-comment"> * obj-&gt;upload(video);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;longest();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="7-得到山形数组的最少删除次数"><a href="#7-得到山形数组的最少删除次数" class="headerlink" title="7. 得到山形数组的最少删除次数"></a>7. 得到山形数组的最少删除次数</h1><p>我们定义 arr 是 山形数组 当且仅当它满足：</p><ul><li>arr.length &gt;&#x3D; 3</li><li>存在某个下标 i （从 0 开始） 满足 0 &lt; i &lt; arr.length - 1 且：</li><li><ul><li>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]</li></ul></li><li><ul><li>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给你整数数组 nums​ ，请你返回将 nums 变成 山形状数组 的​ 最少 删除次数。<br><img src="/img/%E5%BE%97%E5%88%B0%E5%B1%B1%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumMountainRemovals</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n)</span>, increase_list</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(increase_list.<span class="hljs-built_in">begin</span>(), increase_list.<span class="hljs-built_in">end</span>(), x);<br>            after[i] = it-increase_list.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(it == increase_list.<span class="hljs-built_in">end</span>())&#123;<br>                increase_list.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                *it = x;<br>            &#125;<br>        &#125;<br>        increase_list.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(increase_list.<span class="hljs-built_in">begin</span>(), increase_list.<span class="hljs-built_in">end</span>(), x);<br>            pre = it-increase_list.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(it == increase_list.<span class="hljs-built_in">end</span>())&#123;<br>                increase_list.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                *it = x;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pre &gt;= <span class="hljs-number">2</span> &amp;&amp; after[i] &gt;=<span class="hljs-number">2</span>)&#123;<br>                result = <span class="hljs-built_in">max</span>(result, pre + after[i] <span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="8-移除石子使总数最小"><a href="#8-移除石子使总数最小" class="headerlink" title="8. 移除石子使总数最小"></a>8. 移除石子使总数最小</h1><p>给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次：</p><ul><li>选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] &#x2F; 2) 颗石子。<br>注意：你可以对 同一堆 石子多次执行此操作。</li></ul><p>返回执行 k 次操作后，剩下石子的 最小 总数。</p><p>floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。<br><img src="/img/%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E4%BD%BF%E6%80%BB%E6%95%B0%E6%9C%80%E5%B0%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minStoneSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(piles.begin(), piles.end())</span></span>;<br><br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> num = pq.<span class="hljs-built_in">top</span>() - pq.<span class="hljs-built_in">top</span>()/<span class="hljs-number">2</span>;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(num);<br>            k--;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>            result += pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day10</title>
    <link href="/2023/12/21/LeedCode-20231221/"/>
    <url>/2023/12/21/LeedCode-20231221/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-执行子串操作后的字典序最小字符串"><a href="#1-执行子串操作后的字典序最小字符串" class="headerlink" title="1. 执行子串操作后的字典序最小字符串"></a>1. 执行子串操作后的字典序最小字符串</h1><p>给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为：</p><ul><li>选择 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，’b’ 用 ‘a’ 替换，’a’ 用 ‘z’ 替换。<br>返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。</li></ul><p>子字符串 是字符串中的一个连续字符序列。</p><p>现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] !&#x3D; y[i] 的第一个位置 i 上，如果  x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。<br><img src="/img/%E6%89%A7%E8%A1%8C%E5%AD%90%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">smallestString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">while</span>(s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; i&lt;n )&#123;<br>                s[i]--;<br>                i++;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">return</span> s;&#125;<br>        s[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;z&#x27;</span>;<br>        <br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-HTML-实体解析器"><a href="#2-HTML-实体解析器" class="headerlink" title="2.  HTML 实体解析器"></a>2.  HTML 实体解析器</h1><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p><p>HTML 里这些特殊字符和它们对应的字符实体包括：</p><ul><li>双引号：字符实体为 &quot; ，对应的字符是 “ 。</li><li>单引号：字符实体为 &apos; ，对应的字符是 ‘ 。</li><li>与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。</li><li>大于号：字符实体为 &gt; ，对应的字符是 &gt; 。</li><li>小于号：字符实体为 &lt; ，对应的字符是 &lt; 。</li><li>斜线号：字符实体为 &frasl; ，对应的字符是 &#x2F; 。<br>给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。<br>![](&#x2F;img&#x2F;HTML 实体解析器.png)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">entityParser</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        string str = <span class="hljs-string">&quot;&quot;</span>;<br>        unordered_map&lt;string, string&gt; HTML_list = &#123;&#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>,<span class="hljs-string">&quot;\&quot;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;\&#x27;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;text.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string tmp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">int</span> index = i;<br>            <span class="hljs-keyword">if</span>(text[i] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">while</span>(index-i&lt;<span class="hljs-number">7</span> &amp;&amp; index&lt;text.<span class="hljs-built_in">size</span>())&#123;<br>                    tmp += text[index];<br>                    <span class="hljs-keyword">if</span>(text[index] == <span class="hljs-string">&#x27;;&#x27;</span>)&#123;<span class="hljs-keyword">break</span>;&#125; <br>                    index++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(HTML_list.<span class="hljs-built_in">find</span>(tmp) != HTML_list.<span class="hljs-built_in">end</span>())&#123;<br>                    i = index;<br>                    str += HTML_list[tmp];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;str += text[i];&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                str += text[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="3-判断字符串的两半是否相似"><a href="#3-判断字符串的两半是否相似" class="headerlink" title="3. 判断字符串的两半是否相似"></a>3. 判断字符串的两半是否相似</h1><p>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。</p><p>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。</p><p>如果 a 和 b 相似，返回 true ；否则，返回 false 。<br><img src="/img/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E5%8D%8A%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">halvesAreAlike</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; vowel = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            cnt += vowel.<span class="hljs-built_in">count</span>(s[i]);<br>            cnt -= vowel.<span class="hljs-built_in">count</span>(s[i+n]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</span><br></code></pre></td></tr></table></figure><h1 id="4-美丽塔-II"><a href="#4-美丽塔-II" class="headerlink" title="4. 美丽塔 II"></a>4. 美丽塔 II</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。</p><p>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。</p><p>如果以下条件满足，我们称这些塔是 美丽 的：</p><ol><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：</li></ol><ul><li>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]</li><li>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。<br><img src="/img/%E7%BE%8E%E4%B8%BD%E5%A1%94II.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[i] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                sum -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(st.<span class="hljs-built_in">top</span>()-j);<br>            &#125;<br>            sum += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[i]*(st.<span class="hljs-built_in">top</span>()-i);<br>            after[i] = sum;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        st = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[j] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> k = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                pre -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[k]*(k-st.<span class="hljs-built_in">top</span>());<br>            &#125;<br>            pre += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(j-st.<span class="hljs-built_in">top</span>());<br>            result = <span class="hljs-built_in">max</span>(result, pre + after[j+<span class="hljs-number">1</span>]);<br>            st.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day9</title>
    <link href="/2023/12/20/LeedCode-20231220/"/>
    <url>/2023/12/20/LeedCode-20231220/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-最大公因数等于-K-的子数组数目"><a href="#1-最大公因数等于-K-的子数组数目" class="headerlink" title="1. 最大公因数等于 K 的子数组数目"></a>1. 最大公因数等于 K 的子数组数目</h1><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。</p><p>子数组 是数组中一个连续的非空序列。</p><p>数组的最大公因数 是能整除数组中所有元素的最大整数。<br>![](&#x2F;img&#x2F;最大公因数等于 K 的子数组数目.png)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarrayGCD</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left&lt;nums.<span class="hljs-built_in">size</span>(); left++)&#123;<br>            <span class="hljs-type">int</span> num = nums[left];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = left; right&lt;nums.<span class="hljs-built_in">size</span>(); right++)&#123;<br>                num = <span class="hljs-built_in">gcd</span>(num,nums[right]);<br>                <span class="hljs-keyword">if</span>(num == k)&#123;result++;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> tmp = a%b;<br>            a = b;<br>            b =tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-二叉树中的伪回文路径"><a href="#2-二叉树中的伪回文路径" class="headerlink" title="2.  二叉树中的伪回文路径"></a>2.  二叉树中的伪回文路径</h1><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p>请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traceback</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt; p)</span></span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        p[node -&gt;val] ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(node -&gt; left == <span class="hljs-literal">nullptr</span> &amp;&amp; node -&gt; right == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">accumulate</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">1</span>)&#123;res++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res = <span class="hljs-built_in">traceback</span>(node -&gt; left, p) + <span class="hljs-built_in">traceback</span>(node -&gt; right, p);<br>        &#125;<br>        p[node -&gt;val] ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pseudoPalindromicPaths</span> <span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        result = <span class="hljs-built_in">traceback</span>(root, p);<br>     <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-统计无向图中无法互相到达点对数"><a href="#3-统计无向图中无法互相到达点对数" class="headerlink" title="3. 统计无向图中无法互相到达点对数"></a>3. 统计无向图中无法互相到达点对数</h1><p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p><p>请你返回 无法互相到达 的不同 点对数目 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:edges)&#123;<br>            g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>            g[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n)</span></span>;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> input) -&gt; <span class="hljs-type">int</span>&#123;<br>            <span class="hljs-type">int</span> size = <span class="hljs-number">1</span>;<br>            visit[input] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> element:g[input])&#123;<br>                <span class="hljs-keyword">if</span>(!visit[element])&#123;size += <span class="hljs-built_in">dfs</span>(element);&#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> size;<br>        &#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, connected_point = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visit[i])&#123;<br>                <span class="hljs-type">int</span> new_connection = <span class="hljs-built_in">dfs</span>(i);<br>                ans += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) connected_point * new_connection;<br>                connected_point += new_connection;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-表现良好的最长时间段"><a href="#4-表现良好的最长时间段" class="headerlink" title="4. 表现良好的最长时间段"></a>4. 表现良好的最长时间段</h1><p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。<br><img src="/img/%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(hours[i]/<span class="hljs-number">9</span>)&#123;hours[i] = <span class="hljs-number">1</span>;&#125;<br>            <span class="hljs-keyword">else</span>&#123;hours[i] = <span class="hljs-number">-1</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>]+hours[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n; j&gt;i; j--)&#123;<br>                <span class="hljs-keyword">if</span>(presum[j]-presum[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    result = <span class="hljs-built_in">max</span>(result,j-i);<br>                    <span class="hljs-keyword">break</span>;    <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//improve using stack</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>]+ (hours[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">8</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">if</span>(presum[i] &lt; presum[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; presum[i]&gt;presum[st.<span class="hljs-built_in">top</span>()])&#123;<br>                result = <span class="hljs-built_in">max</span>(result, i-st.<span class="hljs-built_in">top</span>());<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-寻找峰值"><a href="#5-寻找峰值" class="headerlink" title="5. 寻找峰值"></a>5. 寻找峰值</h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p><p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。<br><img src="/img/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> middle;<br><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; nums[middle+<span class="hljs-number">1</span>])&#123;<br>                right = middle;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[middle] &lt; nums[middle+<span class="hljs-number">1</span>])&#123;<br>                left = middle +<span class="hljs-number">1</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="6-统计区间中的整数数目"><a href="#6-统计区间中的整数数目" class="headerlink" title="6. 统计区间中的整数数目"></a>6. 统计区间中的整数数目</h1><p>给你区间的 空 集，请你设计并实现满足要求的数据结构：</p><p>新增：添加一个区间到这个区间集合中。<br>统计：计算出现在 至少一个 区间中的整数个数。<br>实现 CountIntervals 类：</p><p>CountIntervals() 使用区间的空集初始化对象<br>void add(int left, int right) 添加区间 [left, right] 到区间集合之中。<br>int count() 返回出现在 至少一个 区间中的整数个数。<br>注意：区间 [left, right] 表示满足 left &lt;&#x3D; x &lt;&#x3D; right 的所有整数 x 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E5%8C%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountIntervals</span> &#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CountIntervals</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = m.<span class="hljs-built_in">lower_bound</span>(left); it!=m.<span class="hljs-built_in">end</span>() &amp;&amp; it -&gt; second &lt;= right; m.<span class="hljs-built_in">erase</span>(it++))&#123;<br>            <span class="hljs-type">int</span> l = it-&gt;second;<br>            <span class="hljs-type">int</span> r = it-&gt;first;<br>            left = <span class="hljs-built_in">min</span>(l, left);<br>            right = <span class="hljs-built_in">max</span>(r,right);<br>            cnt -= r-l+<span class="hljs-number">1</span>;<br>        &#125;<br>        cnt += right-left+<span class="hljs-number">1</span>;<br>        m[right] = left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CountIntervals object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CountIntervals* obj = new CountIntervals();</span><br><span class="hljs-comment"> * obj-&gt;add(left,right);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;count();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inside the C++ Object Model-1</title>
    <link href="/2023/12/18/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/12/18/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-对象模式"><a href="#C-对象模式" class="headerlink" title="C++对象模式"></a>C++对象模式</h1><span id="more"></span><p>下面是示例代码，以下对于模型的介绍都围绕着示例代码展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> xval);<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Point</span>();<br>    <br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">PointCount</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os)</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-type">float</span> _x;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> _point_count;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1-简单对象模型"><a href="#1-简单对象模型" class="headerlink" title="1. 简单对象模型"></a>1. 简单对象模型</h2><p>正如名字中的简单二字，简单对象模式的设计初衷是为了降低C++编译器的复杂度，其示例代码(参考深入探索C++对象模型)和设计模型如下图。对于简单对象模式，一个对象被分成了许多slot，slot的个数对应于class中member的个数，从上到下按照在class中的申明顺序进行排列。为了适应class中member的不同类型，slot中存放的是执行具体member的指针。在进行member寻址的时候通过slot的索引值来进行查找。<br>优点：降低了C++编译器的设计复杂度。<br>缺点：降低了C++编译器的空间利用率和执行时的效率。</p><h3 id="加上继承"><a href="#加上继承" class="headerlink" title="加上继承"></a>加上继承</h3><p>假设有两个类，base_point和 derived_point，其中base_point为derived_class的父类。那么在简单对象模型中，base_point会被derived_point的一个slot来指出，slot中储存的是base_point的地址。<br>优点：由间接性导致的空间和存取时间上的额外损耗。<br>缺点：derived_point的大小与base_point的大小无关。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p><h2 id="2-表格驱动对象模型"><a href="#2-表格驱动对象模型" class="headerlink" title="2.表格驱动对象模型"></a>2.表格驱动对象模型</h2><p>表格驱动对象模型也被称为双表格模型。相比与上面的简单对象模式，表格驱动模式将class中的data member和 function member 做了一个区分，将它们分别放在Data Member Table和Function Member Table中。由此Point pt就简化为只拥有两个指针的slot,分别指向两个Table. 这里需要注意的一点是data member直接存放在Data Member Table中，而对于Function Member Table可以类比上述的简单对象模型。其中的不同点在于将Poitn pt替换成了Function Member Table并且每个slot所指向的对象只包含function member.<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E8%A1%A8%E6%A0%BC%E9%A9%B1%E5%8A%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p><h3 id="加上继承-1"><a href="#加上继承-1" class="headerlink" title="加上继承"></a>加上继承</h3><p>可以类比于VirtualTable，会产生另一个叫做Base Class Table 的表格。表格中的每个slot都包含一个base class的地址。Derived Class通过一个bptr的指针指向Base Class Table。<br>缺点：由间接性导致的空间和存取时间上的额外损耗。<br>优点：由于每个class在固定位置都会存在一个bptr指针，每一个class对于继承都保持了一致性。由于Base Class Table的存在，做到了与class本身的分离，所以在无需改变class本身的大小就能增加或是减少base class。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/base_class_table.png"></p><h2 id="3-C-对象模型"><a href="#3-C-对象模型" class="headerlink" title="3.C++对象模型"></a>3.C++对象模型</h2><p>从简单模型到C++对象模型经历了内存空间和存取时间上的优化。相比于上面的双表格模型，C++对象模型对calss的member做了更细的划分。<br>1.Nonstatic data members 放在class之中。<br>2.Static data member 放在class之外。<br>3.Static和nonstatic function member放在class之外。<br>根据上面的示例代码可以画出下面的模型图，读者可以根据C++对象模型各种元素的存放规则去图中一一对应。对于Virtual table 中指针分配的顺序是以type_info开始，并以程序中的申明顺序进行排列。对与type_info的解释，读者可以移步至这篇博客<a href="https://www.cnblogs.com/xuelisheng/p/9479288.html">Click to jump</a>，笔者个人觉得对于RTTI机制，type_info, typeid 和dynamic_cast都做了不错的解释。<br>优点：空间和存取时间效率。<br>缺点：对于nonstatic data member的改变需要进行重新编译。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day8</title>
    <link href="/2023/12/17/LeedCode-20231217/"/>
    <url>/2023/12/17/LeedCode-20231217/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-划分数组并满足最大差限制"><a href="#1-划分数组并满足最大差限制" class="headerlink" title="1. 划分数组并满足最大差限制"></a>1. 划分数组并满足最大差限制</h1><p>给你一个长度为 n 的整数数组 nums，以及一个正整数 k 。</p><p>将这个数组划分为一个或多个长度为 3 的子数组，并满足以下条件：</p><p>nums 中的 每个 元素都必须 恰好 存在于某个子数组中。<br>子数组中 任意 两个元素的差必须小于或等于 k 。<br>返回一个 二维数组 ，包含所有的子数组。如果不可能满足条件，就返回一个空数组。如果有多个答案，返回 任意一个 即可。<br><img src="/img/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E5%B9%B6%E6%BB%A1%E8%B6%B3%E6%9C%80%E5%A4%A7%E5%B7%AE%E9%99%90%E5%88%B6.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">divideArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; empty;<br>        <br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> empty;&#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i = i + <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-type">int</span> left = nums[i];<br>            <span class="hljs-type">int</span> middle = nums[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> right = nums[i+<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(right-left&lt;=k)&#123;result.<span class="hljs-built_in">push_back</span>(&#123;left,middle,right&#125;);&#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> empty;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-使数组成为等数数组的最小代价"><a href="#2-使数组成为等数数组的最小代价" class="headerlink" title="2.  使数组成为等数数组的最小代价"></a>2.  使数组成为等数数组的最小代价</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 nums 。</p><p>你可以对 nums 执行特殊操作 任意次 （也可以 0 次）。每一次特殊操作中，你需要 按顺序 执行以下步骤：</p><p>从范围 [0, n - 1] 里选择一个下标 i 和一个 正 整数 x 。<br>将 |nums[i] - x| 添加到总代价里。<br>将 nums[i] 变为 x 。<br>如果一个正整数正着读和反着读都相同，那么我们称这个数是 回文数 。比方说，121 ，2552 和 65756 都是回文数，但是 24 ，46 ，235 都不是回文数。</p><p>如果一个数组中的所有元素都等于一个整数 y ，且 y 是一个小于 109 的 回文数 ，那么我们称这个数组是一个 等数数组 。</p><p>请你返回一个整数，表示执行任意次特殊操作后使 nums 成为 等数数组 的 最小 总代价。<br><img src="/img/%E4%BD%BF%E6%95%B0%E7%BB%84%E6%88%90%E4%B8%BA%E7%AD%89%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> input)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = input; i&lt;= <span class="hljs-number">1000000000</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTrue</span>(i))&#123;<br>                result[<span class="hljs-number">0</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = input; i&gt;=<span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTrue</span>(i))&#123;<br>                result[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTrue</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> input)</span></span>&#123;<br>        string str = <span class="hljs-built_in">to_string</span>(input);<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(str[left] != str[right])&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minimumCost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">9223372036854775807</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> middle_down = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> middle_up = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> palindrome_number;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; tmp_list;<br>            <br>            middle_up = nums[n/<span class="hljs-number">2</span>];<br>            tmp_list = <span class="hljs-built_in">findNum</span>(middle_up);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;tmp_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(tmp_list[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(tmp_list[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list1;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list2;<br>            <br>            middle_down = (nums[n/<span class="hljs-number">2</span>] + nums[(n/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>])/<span class="hljs-number">2</span>;<br>            middle_up = middle_down + <span class="hljs-number">1</span>;<br>            palindrome_list1 = <span class="hljs-built_in">findNum</span>(middle_up);<br>            palindrome_list2 = <span class="hljs-built_in">findNum</span>(middle_down);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(palindrome_list1[i] != palindrome_list2[<span class="hljs-number">0</span>] &amp;&amp; palindrome_list1[i] != palindrome_list2[<span class="hljs-number">1</span>] &amp;&amp; palindrome_list1[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(palindrome_list1[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list2.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(palindrome_list1[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(palindrome_list2[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp_result = <span class="hljs-number">0</span>;<br>            <br>                palindrome_number = palindrome_list[i];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                    tmp_result += <span class="hljs-built_in">abs</span>(palindrome_number-nums[j]);<br>                &#125;<br>                result = <span class="hljs-built_in">min</span>(result,tmp_result);  <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="3-执行操作使频率分数最大"><a href="#3-执行操作使频率分数最大" class="headerlink" title="3. 执行操作使频率分数最大"></a>3. 执行操作使频率分数最大</h1><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p><p>你可以对数组执行 至多 k 次操作：</p><p>从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。<br>最终数组的频率分数定义为数组中众数的 频率 。</p><p>请你返回你可以得到的 最大 频率分数。</p><p>众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。<br><img src="/img/%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E9%A2%91%E7%8E%87%E5%88%86%E6%95%B0%E6%9C%80%E5%A4%A7.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxFrequencyScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">auto</span> operation_num = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">long</span> <span class="hljs-type">long</span>&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[m]*(m-l) - presum[m] + presum[l];<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = presum[r+<span class="hljs-number">1</span>] - presum[m+<span class="hljs-number">1</span>] - (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[m]*(r-m);<br>            <span class="hljs-keyword">return</span> left + right;<br>        &#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">operation_num</span>(start, (start+i)/<span class="hljs-number">2</span>, i) &gt; k)&#123;<br>                start++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans,i-start+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day7</title>
    <link href="/2023/12/16/LeedCode-20231216/"/>
    <url>/2023/12/16/LeedCode-20231216/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-元素计数"><a href="#1-元素计数" class="headerlink" title="1. 元素计数"></a>1. 元素计数</h1><p>给你一个整数数组 nums ，统计并返回在 nums 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。<br><img src="/img/%E5%85%83%E7%B4%A0%E8%AE%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> right = nums[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != left &amp;&amp; nums[i] != right)&#123;<br>                result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-统计圆内格点数目"><a href="#2-统计圆内格点数目" class="headerlink" title="2.  统计圆内格点数目"></a>2.  统计圆内格点数目</h1><p>给你一个二维整数数组 circles ，其中 circles[i] &#x3D; [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E5%9C%86%E5%86%85%E6%A0%BC%E7%82%B9%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countLatticePoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; circles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = INT_MAX;<br>        <span class="hljs-type">int</span> right = INT_MIN;<br>        <span class="hljs-type">int</span> up = INT_MIN;<br>        <span class="hljs-type">int</span> down = INT_MAX;<br>        <span class="hljs-type">int</span> n = circles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> cc_x = circles[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> cc_y = circles[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> r = circles[i][<span class="hljs-number">2</span>];<br>            left = <span class="hljs-built_in">min</span>(left, cc_x-r);<br>            right = <span class="hljs-built_in">max</span>(right, cc_x+r);<br>            up = <span class="hljs-built_in">max</span>(up, cc_y+r);<br>            down = <span class="hljs-built_in">min</span>(down, cc_y-r);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i&lt;=right; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = down; j&lt;=up; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index&lt;n; index++)&#123;<br>                    <span class="hljs-type">int</span> x = circles[index][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y = circles[index][<span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> R = circles[index][<span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">if</span>((i-x)*(i-x) + (j-y)*(j-y) &lt;= R*R)&#123;<br>                        result++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-反转二叉树的奇数层"><a href="#3-反转二叉树的奇数层" class="headerlink" title="3. 反转二叉树的奇数层"></a>3. 反转二叉树的奇数层</h1><p>给你一棵 完美 二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。</p><p>例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。<br>反转后，返回树的根节点。</p><p>完美 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p><p>节点的 层数 等于该节点到根节点之间的边数。<br><img src="/img/%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A5%87%E6%95%B0%E5%B1%82.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reverseOddLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-type">bool</span> isOdd = <span class="hljs-literal">false</span>;<br>        <br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;TreeNode*&gt; arr;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>                TreeNode* newnode = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(isOdd)&#123;arr.<span class="hljs-built_in">push_back</span>(newnode);&#125;<br>                <span class="hljs-keyword">if</span>(newnode -&gt; left &amp;&amp; newnode -&gt;right)&#123;<br>                    q.<span class="hljs-built_in">push</span>(newnode -&gt; left);<br>                    q.<span class="hljs-built_in">push</span>(newnode -&gt;right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isOdd)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i = i+<span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-built_in">swap</span>(arr[i] -&gt; val, arr[arr.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>] -&gt; val);<br>                &#125;<br>            &#125;<br>            isOdd ^= <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="4-图中的最短环"><a href="#4-图中的最短环" class="headerlink" title="4. 图中的最短环"></a>4. 图中的最短环</h1><p>现有一个含 n 个顶点的 双向 图，每个顶点按从 0 到 n - 1 标记。图中的边由二维整数数组 edges 表示，其中 edges[i] &#x3D; [ui, vi] 表示顶点 ui 和 vi 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p><p>返回图中 最短 环的长度。如果不存在环，则返回 -1 。</p><p>环 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。<br><img src="/img/%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E7%8E%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findShortestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">num_map</span>(n);<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;edges.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> x = edges[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edges[i][<span class="hljs-number">1</span>];<br>            num_map[x].<span class="hljs-built_in">push_back</span>(y);<br>            num_map[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">bfs</span>(i, n, num_map));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &lt; INT_MAX? ans:<span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br><br>        q.<span class="hljs-built_in">emplace</span>(st,<span class="hljs-number">-1</span>);<br>        count[st] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> [end,start] = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> newend:g[end])&#123;<br>                <span class="hljs-keyword">if</span>(count[newend] &lt; <span class="hljs-number">0</span>)&#123;<br>                    count[newend] = count[end] + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(newend,end);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newend != start)&#123;ans = <span class="hljs-built_in">min</span>(ans,count[end] + count[newend]+<span class="hljs-number">1</span>);&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-待复习</title>
    <link href="/2023/12/15/LeedCode-%E5%BE%85%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/12/15/LeedCode-%E5%BE%85%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-用邮票贴满网格图"><a href="#1-用邮票贴满网格图" class="headerlink" title="1. 用邮票贴满网格图"></a>1. 用邮票贴满网格图</h1><p>给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。</p><p>给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</p><ol><li>覆盖所有 空 格子。</li><li>不覆盖任何 被占据 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 重叠 部分。</li><li>邮票不允许 旋转 。</li><li>邮票必须完全在矩阵 内 。<br>如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。<br><img src="/img/%E7%94%A8%E9%82%AE%E7%A5%A8%E8%B4%B4%E6%BB%A1%E7%BD%91%E6%A0%BC%E5%9B%BE.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleToStamp</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> stampHeight, <span class="hljs-type">int</span> stampWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(m+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                s[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = s[i][j+<span class="hljs-number">1</span>] + s[i+<span class="hljs-number">1</span>][j] - s[i][j]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = stampHeight; i1&lt;=m; i1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = stampWidth; j1&lt;=n; j1++)&#123;<br>                <span class="hljs-type">int</span> i2 = i1-stampHeight+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> j2 = j1-stampWidth+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s[i1][j1] - s[i2<span class="hljs-number">-1</span>][j1] - s[i1][j2<span class="hljs-number">-1</span>] + s[i2<span class="hljs-number">-1</span>][j2<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    d[i2][j2]++;<br>                    d[i1+<span class="hljs-number">1</span>][j2]--;<br>                    d[i2][j1+<span class="hljs-number">1</span>]--;<br>                    d[i1+<span class="hljs-number">1</span>][j1+<span class="hljs-number">1</span>]++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] += d[i][j+<span class="hljs-number">1</span>]+d[i+<span class="hljs-number">1</span>][j] - d[i][j];<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">0</span> &amp;&amp; d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="2-美丽塔-II"><a href="#2-美丽塔-II" class="headerlink" title="2. 美丽塔 II"></a>2. 美丽塔 II</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。</p><p>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。</p><p>如果以下条件满足，我们称这些塔是 美丽 的：</p><ol><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：</li></ol><ul><li>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]</li><li>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。<br>![](&#x2F;img&#x2F;美丽塔 II.png)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[i] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                sum -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(st.<span class="hljs-built_in">top</span>()-j);<br>            &#125;<br>            sum += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[i]*(st.<span class="hljs-built_in">top</span>()-i);<br>            after[i] = sum;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        st = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[j] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> k = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                pre -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[k]*(k-st.<span class="hljs-built_in">top</span>());<br>            &#125;<br>            pre += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(j-st.<span class="hljs-built_in">top</span>());<br>            result = <span class="hljs-built_in">max</span>(result, pre + after[j+<span class="hljs-number">1</span>]);<br>            st.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day6</title>
    <link href="/2023/12/15/LeedCode-20231215/"/>
    <url>/2023/12/15/LeedCode-20231215/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-子数组和排序后的区间和"><a href="#1-子数组和排序后的区间和" class="headerlink" title="1. 子数组和排序后的区间和"></a>1. 子数组和排序后的区间和</h1><p>给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) &#x2F; 2 个数字的数组。</p><p>请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。<br><img src="/img/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> MODULO = <span class="hljs-number">1000000007</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        result.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                sum += nums[j];<br>                result.<span class="hljs-built_in">push_back</span>(sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left<span class="hljs-number">-1</span>; i&lt;=right<span class="hljs-number">-1</span>; i++)&#123;<br>            res += result[i];<br>            res = res%MODULO;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-将字符串翻转到单调递增"><a href="#2-将字符串翻转到单调递增" class="headerlink" title="2.  将字符串翻转到单调递增"></a>2.  将字符串翻转到单调递增</h1><p>如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。</p><p>给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。</p><p>返回使 s 单调递增的最小翻转次数。<br><img src="/img/%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>];<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>; <br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-使数组元素全部相等的最少操作次数"><a href="#3-使数组元素全部相等的最少操作次数" class="headerlink" title="3. 使数组元素全部相等的最少操作次数"></a>3. 使数组元素全部相等的最少操作次数</h1><p>给你一个正整数数组 nums 。</p><p>同时给你一个长度为 m 的整数数组 queries 。第 i 个查询中，你需要将 nums 中所有元素变成 queries[i] 。你可以执行以下操作 任意 次：</p><p>将数组里一个元素 增大 或者 减小 1 。<br>请你返回一个长度为 m 的数组 answer ，其中 answer[i]是将 nums 中所有元素变成 queries[i] 的 最少 操作次数。</p><p>注意，每次查询后，数组变回最开始的值。<br><img src="/img/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; result;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> breakpoint = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            presum[i+<span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp = queries[i];<br>            breakpoint = <span class="hljs-built_in">findlocation</span>(nums, tmp);<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = breakpoint*tmp - presum[breakpoint];<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = presum[n] - presum[breakpoint+<span class="hljs-number">1</span>]  - (n-breakpoint<span class="hljs-number">-1</span>)*tmp;<br>            result.<span class="hljs-built_in">push_back</span>(left+right + <span class="hljs-built_in">abs</span>(nums[breakpoint] - tmp));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">findlocation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> middle = (left+right)/<span class="hljs-number">2</span>;;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(nums[middle] == target)&#123;<span class="hljs-keyword">return</span> middle;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle] &lt; target)&#123;<br>                left  = middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = middle;<br>            &#125;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> middle;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</span><br></code></pre></td></tr></table></figure><h1 id="4-用邮票贴满网格图"><a href="#4-用邮票贴满网格图" class="headerlink" title="4. 用邮票贴满网格图"></a>4. 用邮票贴满网格图</h1><p>给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。</p><p>给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</p><ol><li>覆盖所有 空 格子。</li><li>不覆盖任何 被占据 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 重叠 部分。</li><li>邮票不允许 旋转 。</li><li>邮票必须完全在矩阵 内 。<br>如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。<br><img src="/img/%E7%94%A8%E9%82%AE%E7%A5%A8%E8%B4%B4%E6%BB%A1%E7%BD%91%E6%A0%BC%E5%9B%BE.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleToStamp</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> stampHeight, <span class="hljs-type">int</span> stampWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(m+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                s[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = s[i][j+<span class="hljs-number">1</span>] + s[i+<span class="hljs-number">1</span>][j] - s[i][j]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = stampHeight; i1&lt;=m; i1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = stampWidth; j1&lt;=n; j1++)&#123;<br>                <span class="hljs-type">int</span> i2 = i1-stampHeight+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> j2 = j1-stampWidth+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s[i1][j1] - s[i2<span class="hljs-number">-1</span>][j1] - s[i1][j2<span class="hljs-number">-1</span>] + s[i2<span class="hljs-number">-1</span>][j2<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    d[i2][j2]++;<br>                    d[i1+<span class="hljs-number">1</span>][j2]--;<br>                    d[i2][j1+<span class="hljs-number">1</span>]--;<br>                    d[i1+<span class="hljs-number">1</span>][j1+<span class="hljs-number">1</span>]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] += d[i][j+<span class="hljs-number">1</span>]+d[i+<span class="hljs-number">1</span>][j] - d[i][j];<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">0</span> &amp;&amp; d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ol>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day5</title>
    <link href="/2023/12/13/LeedCode-20231213/"/>
    <url>/2023/12/13/LeedCode-20231213/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-找出所有行中最小公共元素"><a href="#1-找出所有行中最小公共元素" class="headerlink" title="1. 找出所有行中最小公共元素"></a>1. 找出所有行中最小公共元素</h1><p>给你一个 m x n 的矩阵 mat，其中每一行的元素均符合 严格递增 。请返回 所有行中的 最小公共元素 。</p><p>如果矩阵中没有这样的公共元素，就请返回 -1。<br><img src="/img/%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E8%A1%8C%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%85%AC%E5%85%B1%E5%85%83%E7%B4%A0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">smallestCommonElement</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        result = <span class="hljs-built_in">cycle</span>(<span class="hljs-number">0</span>, mat.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, mat);<br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cycle</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<span class="hljs-keyword">return</span> mat[left];&#125;<br>        <span class="hljs-keyword">if</span>(right - left == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">intersection</span>(mat[left], mat[right]);&#125;<br><br>        <span class="hljs-type">int</span> middle = (left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersection</span>(<span class="hljs-built_in">cycle</span>(left, middle, mat), <span class="hljs-built_in">cycle</span>(middle+<span class="hljs-number">1</span>, right, mat));<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; int_mapping;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            int_mapping[a[i]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;b.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(int_mapping.<span class="hljs-built_in">find</span>(b[i]) != int_mapping.<span class="hljs-built_in">end</span>())&#123;result.<span class="hljs-built_in">push_back</span>(b[i]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-构成交替字符串需要的最小交换次数"><a href="#2-构成交替字符串需要的最小交换次数" class="headerlink" title="2.  构成交替字符串需要的最小交换次数"></a>2.  构成交替字符串需要的最小交换次数</h1><p>给你一个二进制字符串 s ，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p><p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 “010” 和 “1010” 属于交替字符串，但 “0100” 不是。</p><p>任意两个字符都可以进行交换，不必相邻 。<br><img src="/img/%E6%9E%84%E6%88%90%E4%BA%A4%E6%9B%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; binary_mapping;<br>        vector&lt;<span class="hljs-type">int</span>&gt; continu_1;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        string target1=<span class="hljs-string">&quot;&quot;</span>;<br>        string target2=<span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-number">0</span>;<br>        binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            <span class="hljs-type">char</span> tmp = c;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]++;&#125;<br>            <span class="hljs-keyword">else</span>&#123;binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br><br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">1</span>)&#123;target1 += <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">-1</span>)&#123;target2 += <span class="hljs-string">&#x27;1&#x27;</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i&lt;(binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]+binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>])/<span class="hljs-number">2</span>; i++)&#123;<br>            target1 += <span class="hljs-string">&quot;10&quot;</span>;<br>            target2 += <span class="hljs-string">&quot;01&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">-1</span>)&#123;target1 += <span class="hljs-string">&#x27;1&#x27;</span>;&#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">1</span>)&#123;target2 += <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        result = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">binarystr_and</span>(target1, s),<span class="hljs-built_in">binarystr_and</span>(target2, s));<br><br>        result = (result == s.<span class="hljs-built_in">size</span>())?<span class="hljs-number">0</span>:result;<br>        <br>        <span class="hljs-keyword">return</span> result/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarystr_and</span><span class="hljs-params">(string a, string b)</span></span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] != b[i])&#123;result += <span class="hljs-number">1</span>;&#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-完成所有任务的最少初始能量"><a href="#3-完成所有任务的最少初始能量" class="headerlink" title="3. 完成所有任务的最少初始能量"></a>3. 完成所有任务的最少初始能量</h1><p>给你一个任务数组 tasks ，其中 tasks[i] &#x3D; [actuali, minimumi] ：</p><p>actuali 是完成第 i 个任务 需要耗费 的实际能量。<br>minimumi 是开始第 i 个任务前需要达到的最低能量。<br>比方说，如果任务为 [10, 12] 且你当前的能量为 11 ，那么你不能开始这个任务。如果你当前的能量为 13 ，你可以完成这个任务，且完成它后剩余能量为 3 。</p><p>你可以按照 任意顺序 完成任务。</p><p>请你返回完成所有任务的 最少 初始能量。<br><img src="/img/%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%9D%E5%A7%8B%E8%83%BD%E9%87%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumEffort</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = tasks.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <br><br>        <span class="hljs-built_in">sort</span>(tasks.<span class="hljs-built_in">begin</span>(), tasks.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">1</span>]-b[<span class="hljs-number">0</span>];&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            result = <span class="hljs-built_in">max</span>(result+tasks[i][<span class="hljs-number">0</span>],tasks[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOSBox development environment setup</title>
    <link href="/2023/12/12/Assembly%20language%20development%20environment%20setup/"/>
    <url>/2023/12/12/Assembly%20language%20development%20environment%20setup/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-Download-DOSBox"><a href="#1-Download-DOSBox" class="headerlink" title="1. Download DOSBox"></a>1. Download DOSBox</h1><p>DosBox download link：<a href="https://sourceforge.net/projects/dosbox/">Click to jump</a><br>DosBox offical link：<a href="https://www.dosbox.com/">Click to jump</a></p><h1 id="2-Download-the-assembly-toolkit"><a href="#2-Download-the-assembly-toolkit" class="headerlink" title="2. Download the assembly toolkit"></a>2. Download the assembly toolkit</h1><p>Download link：<a href="https://github.com/xDarkLemon/DOSBox_MASM/tree/master/masm">Click to jump</a><br>At least 4 files must be included in the toolkit</p><ul><li>masm.exe id the assembler, used to execute the assembly source code (.asm) and obtain the target program (.obj).</li><li>link.exe linkd the program, connect the target program, and get the executable program exe</li><li>debug.exe is the debugger, used to debug executable programs (.exe)</li><li>exe2bin.exe is a post-compiled command line utility available on MS-DOS and other operating systems to convert DOS MZ executable files to COM files</li></ul><h1 id="3-Install-DOSBox"><a href="#3-Install-DOSBox" class="headerlink" title="3.Install DOSBox"></a>3.Install DOSBox</h1><p><img src="/img/Dosbox%E5%AE%89%E8%A3%851.png"><br>Click Next<br><img src="/img/Dosbox%E5%AE%89%E8%A3%852.png"><br>Click Next<br><img src="/img/Dosbox%E5%AE%89%E8%A3%852.png"><br>Here I choose to install to the D drive.</p><p>Note: The selection of the directory here will affect the following instructions to mount the working directory.</p><h1 id="4-Create-a-new-working-directory"><a href="#4-Create-a-new-working-directory" class="headerlink" title="4.Create a new working directory"></a>4.Create a new working directory</h1><p><img src="/img/Dosbox%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"><br>Create a new working directory DOSBox under the D drive, and cut the installed DOSBox-0.74 to the working directory.<br><img src="/img/Dosbox%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%952.png"><br>Open the Debug directory, cut the assembly tool package masm to the directory, and create a new folder ASM to store the assembly program you wrote in the future.</p><h1 id="5-Mount-the-working-directory"><a href="#5-Mount-the-working-directory" class="headerlink" title="5.Mount the working directory"></a>5.Mount the working directory</h1><p>The purpose of mounting the working directory here is to enable dosbox to use masm.exe in the configuration tool package<br><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"></p><ul><li>Open the DOSBox installation directory and find the file DOSBox 0.74 Options.bat</li><li>Add the following command below [autoexec]:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">MOUNT F D:\DOSBox\Debug<br>set PATH=%PATH%;F:\MASM;<br>F:<br>cd F:\ASM<br><br></code></pre></td></tr></table></figure><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%952.png"><br>The purpose of this is to avoid having to manually mount it again every time you use DOSBox.<br><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%953.png"><br>Start DOSBox 0.74.exe, and the following automatic program execution will appear to verify the validity of the second part above.</li></ul><h1 id="5-Change-the-size-of-the-DOSBox-command-window"><a href="#5-Change-the-size-of-the-DOSBox-command-window" class="headerlink" title="5.Change the size of the DOSBox command window"></a>5.Change the size of the DOSBox command window</h1><p><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"><br>Open the DOSBox installation directory and find the file DOSBox 0.74 Options.bat<br><img src="/img/%E6%9B%B4%E6%94%B9DOSBox%E5%91%BD%E4%BB%A4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F.png"><br>Find the above code block, change the output to ddraw, and windowresolution to the specific size of the command window. Change it according to your own habits. Here the author chose 1200x640 as the size of the command window.</p><p>Note: x in 1200x640 is a lowercase letter x</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Environment Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day4</title>
    <link href="/2023/12/12/LeedCode-20231212/"/>
    <url>/2023/12/12/LeedCode-20231212/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-罗马数字转整数"><a href="#1-罗马数字转整数" class="headerlink" title="1. 罗马数字转整数"></a>1. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。<br><img src="/img/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; roam_mapping = &#123;&#123;<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>&#125;,&#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>&#125;,&#123;<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>&#125;,&#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>&#125;&#125;;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> roam_mapping[s[<span class="hljs-number">0</span>]];&#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ; i++)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-number">5</span>*roam_mapping[s[i]] == roam_mapping[s[i+<span class="hljs-number">1</span>]]) || (<span class="hljs-number">10</span>*roam_mapping[s[i]] == roam_mapping[s[i+<span class="hljs-number">1</span>]]))&#123;<br>                result = result + roam_mapping[s[i+<span class="hljs-number">1</span>]]-roam_mapping[s[i]];<br>                i++;<br>                <span class="hljs-keyword">if</span>(i == s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;flag = <span class="hljs-literal">true</span>;&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                result +=roam_mapping[s[i]];<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)&#123;result+=roam_mapping[s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]];&#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-列举单词的全部缩写"><a href="#2-列举单词的全部缩写" class="headerlink" title="2.  列举单词的全部缩写"></a>2.  列举单词的全部缩写</h1><p>单词的 广义缩写词 可以通过下述步骤构造：先取任意数量的 不重叠、不相邻 的子字符串，再用它们各自的长度进行替换。</p><p>例如，”abcde” 可以缩写为：<br>“a3e”（”bcd” 变为 “3” ）<br>“1bcd1”（”a” 和 “e” 都变为 “1”）<br>“5” (“abcde” 变为 “5”)<br>“abcde” (没有子字符串被代替)<br>然而，这些缩写是 无效的 ：<br>“23”（”ab” 变为 “2” ，”cde” 变为 “3” ）是无效的，因为被选择的字符串是相邻的<br>“22de” (“ab” 变为 “2” ， “bc” 变为 “2”)  是无效的，因为被选择的字符串是重叠的<br>给你一个字符串 word ，返回 一个由 word 的所有可能 广义缩写词 组成的列表 。按 任意顺序 返回答案。<br><img src="/img/%E5%88%97%E4%B8%BE%E5%8D%95%E8%AF%8D%E7%9A%84%E5%85%A8%E9%83%A8%E7%BC%A9%E5%86%99.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateAbbreviations</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-built_in">traceback</span>(word,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> i, string tmp, <span class="hljs-type">int</span> cnt)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i == word.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>)&#123;tmp += <span class="hljs-built_in">to_string</span>(cnt);&#125;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp, cnt+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp + <span class="hljs-built_in">to_string</span>(cnt) + word[i], <span class="hljs-number">0</span>);&#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp+ word[i], <span class="hljs-number">0</span>);&#125;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br><img src="/img/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        map&lt;<span class="hljs-type">int</span>, string&gt; strs_mapping;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>        <br><br>        <span class="hljs-keyword">if</span>(strs.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-built_in">sort</span>(strs.<span class="hljs-built_in">begin</span>(), strs.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> string&amp; a,<span class="hljs-type">const</span> string&amp; b)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>();&#125;);<br>        string smallest_str = strs[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">while</span>(index&lt;strs.<span class="hljs-built_in">size</span>())&#123;<br>            result = <span class="hljs-built_in">CommonStr</span>(smallest_str, strs[index]);<br>            <span class="hljs-keyword">if</span>(result == <span class="hljs-string">&quot;&quot;</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            smallest_str = result;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">CommonStr</span><span class="hljs-params">(string a, string b)</span></span>&#123;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] == b[i])&#123;<br>                result += a[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-下一个更大元素-IV"><a href="#4-下一个更大元素-IV" class="headerlink" title="4. 下一个更大元素 IV"></a>4. 下一个更大元素 IV</h1><p>给你一个下标从 0 开始的非负整数数组 nums 。对于 nums 中每一个整数，你必须找到对应元素的 第二大 整数。</p><p>如果 nums[j] 满足以下条件，那么我们称它为 nums[i] 的 第二大 整数：</p><p>j &gt; i<br>nums[j] &gt; nums[i]<br>恰好存在 一个 k 满足 i &lt; k &lt; j 且 nums[k] &gt; nums[i] 。<br>如果不存在 nums[j] ，那么第二大整数为 -1 。</p><p>比方说，数组 [1, 2, 4, 3] 中，1 的第二大整数是 4 ，2 的第二大整数是 3 ，3 和 4 的第二大整数是 -1 。<br>请你返回一个整数数组 answer ，其中 answer[i]是 nums[i] 的第二大整数。<br><img src="/img/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0_IV.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">secondGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; first_st, second_st;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; tmp;<br>            <span class="hljs-keyword">while</span>(!second_st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&gt;second_st.<span class="hljs-built_in">top</span>().second)&#123;<br>                result[second_st.<span class="hljs-built_in">top</span>().first] = nums[i];<br>                second_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!first_st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&gt;first_st.<span class="hljs-built_in">top</span>().second)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(first_st.<span class="hljs-built_in">top</span>());<br>                first_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!tmp.<span class="hljs-built_in">empty</span>())&#123;<br>                second_st.<span class="hljs-built_in">push</span>(tmp.<span class="hljs-built_in">back</span>());<br>                tmp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            first_st.<span class="hljs-built_in">push</span>(&#123;i,nums[i]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day3</title>
    <link href="/2023/12/11/LeedCode-20231211/"/>
    <url>/2023/12/11/LeedCode-20231211/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-去除重复字母"><a href="#1-去除重复字母" class="headerlink" title="1. 去除重复字母"></a>1. 去除重复字母</h1><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br><img src="/img/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alpha_list</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left_list</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; result;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            alpha_list[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        result.<span class="hljs-built_in">push</span>(s[<span class="hljs-number">0</span>]);<br>        alpha_list[s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        left_list[s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-built_in">i</span>&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> s_num = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!result.<span class="hljs-built_in">empty</span>() &amp;&amp;(left_list[s_num]))&#123;<br>                alpha_list[s_num]--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!result.<span class="hljs-built_in">empty</span>() &amp;&amp; (result.<span class="hljs-built_in">top</span>() - <span class="hljs-string">&#x27;a&#x27;</span>)&gt;(s_num) &amp;&amp; alpha_list[result.<span class="hljs-built_in">top</span>()-<span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                left_list[result.<span class="hljs-built_in">top</span>()-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                result.<span class="hljs-built_in">pop</span>();   <br>            &#125;   <br>            <span class="hljs-keyword">if</span>(left_list[s_num])&#123;<span class="hljs-keyword">continue</span>;&#125;<br>            alpha_list[s_num]--;<br>            result.<span class="hljs-built_in">push</span>(s[i]);<br>            left_list[s_num]++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!result.<span class="hljs-built_in">empty</span>())&#123;<br>            res += result.<span class="hljs-built_in">top</span>();<br>            result.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-二叉树的垂直遍历"><a href="#2-二叉树的垂直遍历" class="headerlink" title="2.  二叉树的垂直遍历"></a>2.  二叉树的垂直遍历</h1><p>给你一个二叉树的根结点，返回其结点按 垂直方向（从上到下，逐列）遍历的结果。<br>如果两个结点在同一行和列，那么顺序则为 从左到右。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E7%9B%B4%E9%81%8D%E5%8E%86.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(rides.<span class="hljs-built_in">begin</span>(), rides.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];&#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(rides.size()+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt; rides.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> st = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ed = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> tip = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(rides.<span class="hljs-built_in">begin</span>(),rides.<span class="hljs-built_in">begin</span>()+i, st+<span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> val) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt; val;&#125;);<br>            <span class="hljs-type">int</span> j = <span class="hljs-built_in">distance</span>(rides.<span class="hljs-built_in">begin</span>(), it);<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[j]+ed-st+tip);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rides.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-最大单词长度乘积"><a href="#3-最大单词长度乘积" class="headerlink" title="3. 最大单词长度乘积"></a>3. 最大单词长度乘积</h1><p>给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。<br><img src="/img/%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">masks</span><span class="hljs-params">(words.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;words.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string str = words[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s:str)&#123;<br>                masks[i] |= <span class="hljs-number">1</span> &lt;&lt; (s - <span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;words.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j&lt;words.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>((masks[i] &amp; masks[j]) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-type">int</span> tmp = words[i].<span class="hljs-built_in">size</span>()*words[j].<span class="hljs-built_in">size</span>();<br>                    result = <span class="hljs-built_in">max</span>(result,tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p>给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。<br><img src="/img/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kelement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(index1 == m)&#123;<br>                <span class="hljs-keyword">return</span> nums2[index2+k<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(index2 == n)&#123;<br>                <span class="hljs-keyword">return</span> nums1[index1+k<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[index1], nums2[index2]);<br>            &#125;<br>            <span class="hljs-type">int</span> newindex1 = <span class="hljs-built_in">min</span>(m<span class="hljs-number">-1</span>,index1+k/<span class="hljs-number">2</span><span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> newindex2 = <span class="hljs-built_in">min</span>(n<span class="hljs-number">-1</span>,index2+k/<span class="hljs-number">2</span><span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> val1 = nums1[newindex1];<br>            <span class="hljs-type">int</span> val2 = nums2[newindex2];<br>            <span class="hljs-keyword">if</span>(val1&lt;=val2)&#123;<br>                k -= newindex1-index1+<span class="hljs-number">1</span>;<br>                index1 = newindex1+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                k -= newindex2-index2+<span class="hljs-number">1</span>;<br>                index2 = newindex2+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> total = m+n;<br><br>        <span class="hljs-keyword">if</span>(total%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">kelement</span>(nums1,nums2,(total+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> ((<span class="hljs-built_in">kelement</span>(nums1,nums2,(total)/<span class="hljs-number">2</span>)+<span class="hljs-built_in">kelement</span>(nums1,nums2,(total)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))/<span class="hljs-number">2.0</span>);<br>        &#125;<br>        <br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day2</title>
    <link href="/2023/12/09/LeedCode-20231209/"/>
    <url>/2023/12/09/LeedCode-20231209/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-下一个更大的数值平衡数"><a href="#1-下一个更大的数值平衡数" class="headerlink" title="1. 下一个更大的数值平衡数"></a>1. 下一个更大的数值平衡数</h1><p>如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。<br>给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalance</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (x&gt;<span class="hljs-number">0</span>)&#123;<br>            count[x%<span class="hljs-number">10</span>]++;<br>            x = x/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count[i] != i)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n+<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">1224444</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBalance</span>(i))&#123;<span class="hljs-keyword">return</span> i;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-出租车的最大盈利"><a href="#2-出租车的最大盈利" class="headerlink" title="2.  出租车的最大盈利"></a>2.  出租车的最大盈利</h1><p>你驾驶出租车行驶在一条有 n 个地点的路上。这 n 个地点从近到远编号为 1 到 n ，你想要从 1 开到 n ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。<br>乘客信息用一个下标从 0 开始的二维数组 rides 表示，其中 rides[i] &#x3D; [starti, endi, tipi] 表示第 i 位乘客需要从地点 starti 前往 endi ，愿意支付 tipi 元的小费。<br>每一位 你选择接单的乘客 i ，你可以 盈利 endi - starti + tipi 元。你同时 最多 只能接一个订单。<br>给你 n 和 rides ，请你返回在最优接单方案下，你能盈利 最多 多少元。<br>注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(rides.<span class="hljs-built_in">begin</span>(), rides.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];&#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(rides.size()+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt; rides.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> st = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ed = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> tip = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(rides.<span class="hljs-built_in">begin</span>(),rides.<span class="hljs-built_in">begin</span>()+i, st+<span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> val) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt; val;&#125;);<br>            <span class="hljs-type">int</span> j = <span class="hljs-built_in">distance</span>(rides.<span class="hljs-built_in">begin</span>(), it);<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[j]+ed-st+tip);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rides.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="3-超级丑数"><a href="#3-超级丑数" class="headerlink" title="3. 超级丑数"></a>3. 超级丑数</h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。<br>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。<br>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthSuperUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; primes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = primes.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">long</span>&gt; result;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">primes_list</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> start_point= <span class="hljs-number">0</span>;<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">long</span> primes_min = INT_MAX;<br>            <span class="hljs-type">long</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;m; j++)&#123;<br>                tmp = result[primes_list[j]]*primes[j];<br>                <span class="hljs-keyword">if</span>(tmp &gt; result.<span class="hljs-built_in">back</span>())&#123;<br>                    <span class="hljs-keyword">if</span>(tmp &lt; primes_min)&#123;<br>                        primes_min = tmp;<br>                        flag = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(primes_min);<br>            primes_list[flag]++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>                <span class="hljs-keyword">if</span>(i != flag &amp;&amp; result[primes_list[i]]*primes[i] == primes_min)&#123;<br>                    primes_list[i]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p><!--版权归LeedCode所有-->]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL Sources Learning-1</title>
    <link href="/2023/12/09/STL%20Sources%20Learning-1/"/>
    <url>/2023/12/09/STL%20Sources%20Learning-1/</url>
    
    <content type="html"><![CDATA[<h1 id="查看GCC对各种C-特性的支持程度"><a href="#查看GCC对各种C-特性的支持程度" class="headerlink" title="查看GCC对各种C++特性的支持程度"></a>查看GCC对各种C++特性的支持程度</h1><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span> defined(__sgi)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;__sgi&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span> defined(__GNUC__)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;__GNUC__&quot;</span> &lt;&lt;endl;<br>    cout &lt;&lt; __GNUC__ &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;__GNUC_MINOR__&lt;&lt;endl;<br>    <span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 2</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NO_DRAND48</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_DRAND48 defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_DRAND48 undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 3</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_STATIC_TEMPLATE_MEMBER_BUG</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 4</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_CLASS_PARTIAL_SPECIALIZATION</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 5</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_EXPLICIT_FUNCTION_TMPL_ARGS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_EXPLICIT_FUNCTION_TMPL_ARGS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 6</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_MEMBER_TEMPLATES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_MEMBER_TEMPLATES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_MEMBER_TEMPLATES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 7</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_LIMITED_DEFAULT_TEMPLATES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_LIMITED_DEFAULT_TEMPLATES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_LIMITED_DEFAULT_TEMPLATES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 8</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NON_TYPE_TMPL_PARAM_BUG</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NON_TYPE_TMPL_PARAM_BUG defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NON_TYPE_TMPL_PARAM_BUG undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 9</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __SGI_STL_NO_ARROW_OPERATOR</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__SGI_STL_NO_ARROW_OPERATOR defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__SGI_STL_NO_ARROW_OPERATOR undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 10</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_USE_EXCEPTIONS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_EXCEPTIONS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_EXCEPTIONS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 11</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_USE_NAMESPACES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_NAMESPACES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_NAMESPACES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 12</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_SGI_THREADS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_SGI_THREADS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_SGI_THREADS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 13</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_WIN32THREADS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_WIN32THREADS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_WIN32THREADS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 14</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NO_NAMESPACES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_NAMESPACES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_NAMESPACES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 15</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_TYPENAME</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_TYPENAME defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_TYPENAME undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 16</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_BOOL</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_BOOL defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_BOOL undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 17</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_EXPLICIT</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_EXPLICIT defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_EXPLICIT undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 18</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_ASSERTIONS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_ASSERTIONS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_ASSERTIONS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day1</title>
    <link href="/2023/12/08/LeedCode-20231208/"/>
    <url>/2023/12/08/LeedCode-20231208/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-买卖股票的最佳时机含手续费"><a href="#1-买卖股票的最佳时机含手续费" class="headerlink" title="1. 买卖股票的最佳时机含手续费"></a>1. 买卖股票的最佳时机含手续费</h1><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> buy = -prices[<span class="hljs-number">0</span>]-fee;<br>        <span class="hljs-type">int</span> sell = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> newbuy = <span class="hljs-built_in">max</span>(buy, sell-prices[i]-fee);<br>            <span class="hljs-type">int</span> newsell = <span class="hljs-built_in">max</span>(sell, buy+prices[i]);<br>            buy = newbuy;<br>            sell = newsell;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-买卖芯片的最佳时机数组"><a href="#2-买卖芯片的最佳时机数组" class="headerlink" title="2. 买卖芯片的最佳时机数组"></a>2. 买卖芯片的最佳时机数组</h1><p>prices 记录了某芯片近期的交易价格，其中 prices[i] 表示的 i 天该芯片的价格。你只能选择 某一天 买入芯片，并选择在 未来的某一个不同的日子 卖出该芯片。请设计一个算法计算并返回你从这笔交易中能获取的最大利润。<br>如果你不能获取任何利润，返回 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestTiming</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> smallest = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(smallest &lt; prices[i]) result = <span class="hljs-built_in">max</span>(result, prices[i]-smallest);<br>            <span class="hljs-keyword">else</span> smallest = prices[i]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-稀疏矩阵的乘法"><a href="#3-稀疏矩阵的乘法" class="headerlink" title="3. 稀疏矩阵的乘法"></a>3. 稀疏矩阵的乘法</h1><p>给定两个 稀疏矩阵 ：大小为 m x k 的稀疏矩阵 mat1 和大小为 k x n 的稀疏矩阵 mat2 ，返回 mat1 x mat2 的结果。你可以假设乘法总是可能的<br><img src="/img/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">multiply</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat2) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; newmat2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;mat2[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;mat2.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(mat2[i][j]);<br>            &#125;<br>            newmat2.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;mat1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt;tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;newmat2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;mat1[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); k++)&#123;<br>                    value += mat1[i][k]*newmat2[j][k];<br>                &#125;<br>                tmp.<span class="hljs-built_in">push_back</span>(value);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br>@版权归LeedCode所有<br><br></code></pre></td></tr></table></figure><!--版权归LeedCode所有-->]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
