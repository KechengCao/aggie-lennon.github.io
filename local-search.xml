<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Start using SDL in Windows</title>
    <link href="/2024/01/02/SDL_Start%20using%20SDL%20in%20Windows/"/>
    <url>/2024/01/02/SDL_Start%20using%20SDL%20in%20Windows/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取"><a href="#在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取" class="headerlink" title="在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取"></a>在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取</h2><p>SDL官网地址：<a href="https://www.libsdl.org/">Click to jump</a><br>SDL2下载地址：<a href="https://github.com/libsdl-org/SDL_image/releases">Click to jump</a><br>Lazy Foo’ Productions: <a href="https://lazyfoo.net/tutorials/SDL/">Click to jump</a><br>CodeBlocks下载地址：<a href="https://www.codeblocks.org/downloads/">Click to jump</a><br>MinGw下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/">Click to jump</a></p><h2 id="配置SDL"><a href="#配置SDL" class="headerlink" title="配置SDL"></a>配置SDL</h2><ol><li>   下载SDL头文件和二进制文件<br>下载链接：<a href="https://github.com/libsdl-org/SDL/releases/tag/release-2.28.5">Click to jump</a><br><img src="/img/SDL/SDL2_downloading_github.png"></li></ol><p>将文件下载下来并解压得到下列文件。这里需要使用的有两个文件夹，一个是i686-w64-mingw32另一个是x86_64-w64-mingw32.这其中第一个代表32bit binaries而后者为64bit binaries。为了最大化的保证兼容性，我们使用32bit的。不论你主机是32位的还是64位的都可以得到支持。剪切文件夹，笔者将其复制到C盘并为了方便识别加以重命名，最后得到路径C:\mingw_dev_lib。<br><img src="/img/SDL/SDL2_downloading_filelist.png"></p><ol start="2"><li><p>在CB中新建一个project，笔者在这里将其命名位SDL2<br><img src="/img/SDL/creat_new_project_in_CB.png"></p></li><li><p>添加complier directory<br>首先在project list中右击新建的project进入project&#x2F;targets options<br><img src="/img/SDL/CB_project_lists.png"><br>点击project&#x2F;targets options进入oject’s build options<br><img src="/img/SDL/CB_project_property.png"><br>进入C:\mingw_dev_lib（详细步骤见（1））其中的include&#x2F;SDL2,复制当前的文件地址拷贝入下列窗口中。<br>注意：在拷贝复制前依次点击search directions-&gt;complier, 确保输入在正确的空白框。<br>左侧框中一定要选择SDL2确保设置能同时作用到Debug和Release。<br>这一步如果出错，在示例代码build时会报 can’t find SDL.h的错误。<br><img src="/img/SDL/CB_search_directories_complier.png"></p></li><li><p>添加linker directory<br>进入C:\mingw_dev_lib（详细步骤见（1））其中的lib,复制当前的文件地址并拷入下列窗口中。<br>注意：在拷贝复制前依次点击search directions-&gt;linker, 确保输入在正确的空白框。<br>左侧框中一定要选择SDL2确保设置能同时作用到Debug和Release。<br>这一步如果出错，在示例代码build时会报 can’t find -ISDL2 or -ISDL2main的错误。<br><img src="/img/SDL/CB_linker_directory.png"></p></li><li><p>添加other linker options<br>点击Linker settings,在other linker options中输入-lmingw32 -lSDL2main -lSDL2<br><img src="/img/SDL/CB_other_linker.png"></p></li><li><p>将build type under build targets 改为Console application<br>这里选择console application主要是为了看到console output，如果读者不想看到可以选择GUI application.<br><img src="/img/SDL/CB_build_type.png"></p></li><li><p>setup the dll file<br>进入C:\mingw_dev_lib\bin（详细步骤见（1））拷贝SDL2.dll至CB项目目录下</p></li><li><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SDL.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    SDL_Window *window;<br><br>    <span class="hljs-built_in">SDL_Init</span>(SDL_INIT_VIDEO);<br><br>    window = <span class="hljs-built_in">SDL_CreateWindow</span>(<br>        <span class="hljs-string">&quot;Test&quot;</span>,<br>        SDL_WINDOWPOS_UNDEFINED,<br>        SDL_WINDOWPOS_UNDEFINED,<br>        <span class="hljs-number">640</span>,<br>        <span class="hljs-number">480</span>,<br>        SDL_WINDOW_SHOWN<br>    );<br><br>    <span class="hljs-built_in">SDL_Delay</span>(<span class="hljs-number">3000</span>);<br><br>    <span class="hljs-built_in">SDL_DestroyWindow</span>(window);<br>    <span class="hljs-built_in">SDL_Quit</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其他注意事项<br>笔者在操作的时候遇到一个大坑，本着前人踩坑，后人避坑的想法，笔者在这里帮大家总结经验。由于在步骤1）的时候选择的是支持32bit的，这对于操作系统的位数确实没有限制，但是对CB的MinGW确实有版本的限制。通过在指定目录下运行gcc -v可以查看当前CB的MinGw的版本。请确保自己CB的MinGw版本是i686开头的，否则会报can’t find -ISDL2 or -ISDL2main的错误。<br><img src="/img/SDL/CB_gcc-v.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Game Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day15</title>
    <link href="/2023/12/31/LeedCode/LeedCode-20231231/"/>
    <url>/2023/12/31/LeedCode/LeedCode-20231231/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-商品折扣后的最终价格"><a href="#1-商品折扣后的最终价格" class="headerlink" title="1. 商品折扣后的最终价格"></a>1. 商品折扣后的最终价格</h1><p>给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;&#x3D; prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。<br><img src="/img/Leedcode/%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">finalPrices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;prices)</span> </span>&#123;<br>        stack&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; st;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; prices[i]&lt;=st.<span class="hljs-built_in">top</span>()[<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">auto</span> tmp = st.<span class="hljs-built_in">top</span>();<br>                result[tmp[<span class="hljs-number">0</span>]] = tmp[<span class="hljs-number">1</span>]-prices[i];<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(&#123;i, prices[i]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> tmp = st.<span class="hljs-built_in">top</span>();<br>            result[tmp[<span class="hljs-number">0</span>]] = tmp[<span class="hljs-number">1</span>];<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>单调栈优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">finalPrices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;prices)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>()&gt;prices[i])&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            result[i] = st.<span class="hljs-built_in">empty</span>()?prices[i]:prices[i]-st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">push</span>(prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-删除给定值的叶子节点"><a href="#2-删除给定值的叶子节点" class="headerlink" title="2.  删除给定值的叶子节点"></a>2.  删除给定值的叶子节点</h1><p>给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。</p><p>注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。</p><p>也就是说，你需要重复此过程直到不能继续删除。<br><img src="/img/Leedcode/%E5%88%A0%E9%99%A4%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">removeLeafNodes</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<br>        TreeNode* leftnode = <span class="hljs-built_in">removeLeafNodes</span>(root-&gt;left, target);<br>        TreeNode* rightnode = <span class="hljs-built_in">removeLeafNodes</span>(root-&gt;right, target);<br>        root-&gt;left = leftnode;<br>        root-&gt;right = rightnode;<br>        <span class="hljs-keyword">if</span>(leftnode == <span class="hljs-literal">nullptr</span> &amp;&amp; rightnode == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;val == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-统计放置房子的方式数"><a href="#3-统计放置房子的方式数" class="headerlink" title="3. 统计放置房子的方式数"></a>3. 统计放置房子的方式数</h1><p>一条街道上共有 n * 2 个 地块 ，街道的两侧各有 n 个地块。每一边的地块都按从 1 到 n 编号。每个地块上都可以放置一所房子。</p><p>现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 109 + 7 取余后再返回。</p><p>注意，如果一所房子放置在这条街某一侧上的第 i 个地块，不影响在另一侧的第 i 个地块放置房子。<br><img src="/img/Leedcode/%E7%BB%9F%E8%AE%A1%E6%94%BE%E7%BD%AE%E6%88%BF%E5%AD%90%E7%9A%84%E6%96%B9%E5%BC%8F%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> MOD = <span class="hljs-number">7</span>+<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>            dp[i] = (dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>])%MOD;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)dp[n]*dp[n]%MOD;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-统计最高分的节点数目"><a href="#3-统计最高分的节点数目" class="headerlink" title="3. 统计最高分的节点数目"></a>3. 统计最高分的节点数目</h1><p>给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] &#x3D;&#x3D; -1 。</p><p>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。</p><p>请你返回有 最高得分 节点的 数目 。<br><img src="/img/Leedcode/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countHighestScoreNodes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; parents)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = parents.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-type">long</span> best_result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            g[parents[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; treenum = [&amp;](<span class="hljs-type">int</span> num)&#123;<br>            <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> child:g[num])&#123;<br>                <span class="hljs-type">int</span> sub_result = <span class="hljs-built_in">treenum</span>(child);<br>                result *= sub_result;<br>                cnt += sub_result;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num)&#123;result *= n - cnt - <span class="hljs-number">1</span>;&#125;<br><br>            <span class="hljs-keyword">if</span>(result &gt; best_result)&#123;<br>                ans = <span class="hljs-number">1</span>;<br>                best_result = result;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result == best_result)&#123;ans++;&#125;<br><br>            <span class="hljs-keyword">return</span> cnt + <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-type">int</span> tmp =  <span class="hljs-built_in">treenum</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inside the C++ Object Model-2</title>
    <link href="/2023/12/31/Inside%20the%20C++%20Object%20Model-2/"/>
    <url>/2023/12/31/Inside%20the%20C++%20Object%20Model-2/</url>
    
    <content type="html"><![CDATA[<h1 id="关于C-对象"><a href="#关于C-对象" class="headerlink" title="关于C++对象"></a>关于C++对象</h1><span id="more"></span><ol><li>   一个class object需要多少内存？</li></ol><ul><li>Class object中的nonstatic data member的大小总和</li><li>由于alignment的需求而填补的空间</li><li>为了支持virtual而产生的额外空间</li></ul><p>示例代码及object和pointer内存布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooAnimal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> loc;<br>    string name;<br>&#125;;<br><br><span class="hljs-function">ZooAnimal <span class="hljs-title">za</span><span class="hljs-params">(<span class="hljs-string">&quot;Zoey&quot;</span>)</span></span>;<br>ZooAnimal *pza = &amp;za;<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1_classobject%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"><br>在这个例子中由于使用的是32位机器，所以int类型位4bytes。 而string由两部分组成：4-byte字符指针和字符串长度整数，加起来一共8bytes。最后是vptr指针用来支持virtual。说到指针，读者可能会疑惑对于指向不同类型的指针（如指向整数的指针和指向class的指针）之间会有什么区别。对于指针来说没有什么不同之处，无论是在指针表示法还是在指针内容本身上面。其不同在于根据指针内容所寻址出来的object类型上面，编译器会根据所指定的指针类型来解释通过寻址得到的object的类型。也正是由于这个原因，对于void的类型指针我们无法操作它所指向的object，原因在于我们压根没有告诉编译器指针所指向的类型，更无从谈起对object进行相应的操作。</p><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>示例代码及object和pointer内存布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooAnimal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> loc;<br>    string name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bear</span>: <span class="hljs-keyword">public</span> ZooAnimal&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Bear</span>();<br>    ~<span class="hljs-built_in">Bear</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">dance</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Dances</span>&#123;...&#125;;<br>    Dances dances_known;<br>    <span class="hljs-type">int</span> cell_block;<br>&#125;;<br><br><span class="hljs-function">Bear <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;Yogi&quot;</span>)</span></span>;<br>Bear *pb = &amp;b;<br>Bear &amp;rb = *pb;<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1_derivedclassobject%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"><br>我们可以画出上述布局图，其中圆圈内的数字表示所占byte数，灰色部分为class Bear相对于class ZooAnimal多出来的部分，但这只是相较于ZooAnimal多出来的一部分，剩下的在虚函数表中。结合我们之前在C++对象模型中学习的虚函数表的知识，我们也能画出虚表中的布局图像。对于pointer pb亦或是reference rb都只需要一个word的空间，及4bytes在这个例子中，而对于Bear object b则需要24bytes。24bytes可由两部分组成：16bytes的ZooAnimal object和Bear多出来的部分。这里有一点需要注意这里的虚表指针类型仍为ZooAnimal。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>object和pointer内存布局：<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/object%E5%92%8Cpointer%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80_%E5%A4%9A%E7%BB%A7%E6%89%BF.png"><br>在这图中Derived class继承自Base1 class和Base2 class。在derived class中绿色部分有三个含义：1. 左侧部分表示继承自Base1和Base2。2. 右侧表示derived class对于Base1和Base2的override。3. 不论左侧和右侧，绿色部分的排序均按照声明的顺序排列。灰色部分表示derived class自己的部分，对于左侧nonstatic data member来说，derived class自己的data member排在base data member后面。Derived class自己的虚函数放在第一个虚函数表中base虚函数之后。</p><h2 id="关于继承问题的一些讨论"><a href="#关于继承问题的一些讨论" class="headerlink" title="关于继承问题的一些讨论"></a>关于继承问题的一些讨论</h2><h3 id="1-衍生类使用父类member"><a href="#1-衍生类使用父类member" class="headerlink" title="1.衍生类使用父类member"></a>1.衍生类使用父类member</h3><p>对于上面单继承给出的例子，我们继续给出一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bear b;<br>ZooAnimal *pz = &amp;b;<br>Bear *pb = &amp;b;<br></code></pre></td></tr></table></figure><p>鉴于Bear是ZooAnimal的衍生类， pb能涵盖的object为Bear，而pz所涵盖的只有Bear中的ZooAnimal。除了virtual和ZooAnimal class中出现的members, pz不能用来处理Bear class中出现的members。但有两种方法可以实现pz对Bear member cell_back的处理：<br>1.(static_cast&lt;Bear*&gt;(pz))-&gt;cell_back<br>2.If(Bear *pb2 &#x3D; dynamic_cast&lt;Bear*&gt;(pz)){pb2 -&gt; cell_back;}</p><h3 id="2-衍生类初始化父类"><a href="#2-衍生类初始化父类" class="headerlink" title="2.衍生类初始化父类"></a>2.衍生类初始化父类</h3><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bear b;<br>ZooAnimal za = b;<br>za.<span class="hljs-built_in">rotate</span>();<br></code></pre></td></tr></table></figure><p>以上代码会带来两个问题：</p><ul><li>为什么rotate使用的还是ZooAnimal实例？<br>首先ZooAnimal 和 Bear是两个完全不同的object， 但从继承关系上来看，Bear object所占用的内存就比ZooAnimal大，把Bear实例直接赋值给ZooAnimal无疑是十分荒唐的。</li><li>为什么za的vptr不指向Bear的vltb？<br>编译器会在初始化和指定操作之间做出仲裁。对于含有一个或一个以上vptrs的object, 那些vptrs不会被初始化或者改变</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Inside the C++ Object Model-3</title>
    <link href="/2023/12/31/Inside%20the%20C++%20Object%20Model-3/"/>
    <url>/2023/12/31/Inside%20the%20C++%20Object%20Model-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h1><span id="more"></span><p>生成nontrivial default constructor的4种情况：</p><h2 id="1-带有Default-Constructor的member-class-object"><a href="#1-带有Default-Constructor的member-class-object" class="headerlink" title="1.带有Default Constructor的member class object"></a>1.带有Default Constructor的member class object</h2><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-built_in">Foo</span>()<br>        <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>) <br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Foo foo;<br>    <span class="hljs-type">char</span> *str;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span></span>&#123;<br>    Bar bar;<br>    <span class="hljs-keyword">if</span>(str)&#123;&#125;...<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，由于class Foo default constructor的存在，编译器为class Bar合成了一个default constructor。编译器合成Bear default constructor的目的是来调用已经定义的Foo default constructor来处理class Bar中内含的Foo foo，因为这是编译器自身的需要。至于class foo中的str并没有被初始化，因为str的使用是程序员提出的需求，那自然str的初始化是程序员该负责的事情。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> </span><br><span class="hljs-function"><span class="hljs-title">Bar::Bar</span><span class="hljs-params">()</span></span>&#123;<br>    foo.Foo::<span class="hljs-built_in">Foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++不同的编译模块中，为了避免合成多个default constructor，可以通过把default constructor, copy constructor, destructor, assignment copy operator都已inline的方式完成。如果函数过于复杂，就合成一个explicit non-inline static实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bar::<span class="hljs-built_in">Bar</span>()&#123;str = <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p>还记得上文提到的str初始化问题吗，假设现在你在程序中加入了上述代码，细心的读者可能会提出疑问。编译器对于两个不同的default constructor采取什么行动呢？对于Class A, 如果包含一个或一个以上的class object member，Class A的每一个constructor必须调用member class的default constructor，其调用方式是通过扩张已经存在的constructors，在其中安插代码来完成。结合上面的例子我们能得到下面这个扩充后的constructor。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bar::<span class="hljs-built_in">Bar</span>()&#123;<br>    foo.Foo::<span class="hljs-built_in">Foo</span>();<br>    str = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那如果Class A中内含了多个class object member，其都需要constructor的初始化操作，那C++编译器会为每一个constructor以class object member 声明顺序来安插每一个class object member 所对应的default constructor代码。并且这些代码会安放在explicit user code 之前。通过下面的示例代码，读者能有一个更为直观的理解。<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Class定义：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snow_White</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Dopey dopey;<br>    Sneezy sneezy;<br>    Bashful bashful;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mumble;<br>&#125;<br><span class="hljs-comment">//编辑器中的default constructor:</span><br>Snow_White::<span class="hljs-built_in">Snow_White</span>()&#123;<br>    mumble = <span class="hljs-number">2048</span>;<br>&#125;<br><span class="hljs-comment">//编辑器扩张后的default constructor:</span><br>Snow_White::<span class="hljs-built_in">Snow_White</span>()&#123;<br>    dopey.Dopey::<span class="hljs-built_in">Dopey</span>();<br>    sneezy.Sneezy::<span class="hljs-built_in">Sneezy</span>();<br>    bashful.Bashful::<span class="hljs-built_in">Bashful</span>();<br>    <br>    mumble = <span class="hljs-number">2048</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-带有Default-Constructor的Base-Class"><a href="#2-带有Default-Constructor的Base-Class" class="headerlink" title="2.带有Default Constructor的Base Class"></a>2.带有Default Constructor的Base Class</h2><p>这里可以分为两种情况：对于本身没有任何constructors的derived class来说，如果base class含有default constructor。那就会根据声明顺序调用上一层base class的default constructor。第二种情况是对于derived class中含有constructors但是不包含base class的default constructor。Derived class面对这种情况不会合成新的default constructor。如果derived class中还存在像string这样同样带有default constructor的class object member。那些default constructor同样会被加入到derived class现有的constructor之中，只不过加入的顺序在base class constructor之后。</p><h2 id="3-带有一个Virtual-Function-的Class"><a href="#3-带有一个Virtual-Function-的Class" class="headerlink" title="3.带有一个Virtual Function 的Class"></a>3.带有一个Virtual Function 的Class</h2><p>下面两种情况会合成出default constructor：<br>1.Class 声明或继承virtual function<br>2.Class 派生自一个继承串链，其中存在virtual base classes<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget&amp; widget)</span></span>&#123;<br>    widget.<span class="hljs-built_in">flip</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>    Bell b;<br>    Whistle w;<br>    <span class="hljs-built_in">flip</span>(b);<br>    <span class="hljs-built_in">flip</span>(w);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述的代码，Widget为Bell和Whistle的父类。编译器会干两件事情：生成一个virtual function table存放class中virtual function地址。对于每个class object生成vptr来指示virtual function table的地址。<br>对于这个例子中的Bell class object b和Whistle class object w，编译器会通过default constructor为其各的vptr设定初值。如果class object本身存在constructor，编译器则会直接在其中安插代码确保vptr的正确初始化。</p><h2 id="4-带有一个Virtual-Function-的Class"><a href="#4-带有一个Virtual-Function-的Class" class="headerlink" title="4.带有一个Virtual Function 的Class"></a>4.带有一个Virtual Function 的Class</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day14</title>
    <link href="/2023/12/28/LeedCode/LeedCode-20231228/"/>
    <url>/2023/12/28/LeedCode/LeedCode-20231228/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-最长的斐波那契子序列的长度"><a href="#1-最长的斐波那契子序列的长度" class="headerlink" title="1. 最长的斐波那契子序列的长度"></a>1. 最长的斐波那契子序列的长度</h1><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><ul><li>n &gt;&#x3D; 3</li><li>对于所有 i + 2 &lt;&#x3D; n，都有 X_i + X_{i+1} &#x3D; X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</li></ul><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）<br><img src="/img/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; arr_mapping;<br>        <span class="hljs-type">int</span> max_num = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            arr_mapping[arr[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-2</span>; i++)&#123;<br>            <span class="hljs-type">int</span> num_i=arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;n<span class="hljs-number">-1</span>; j++)&#123;<br>                num_i=arr[i];<br>                <span class="hljs-type">int</span> length = <span class="hljs-number">2</span>;<br>                <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> num_j=arr[j];<br>                <span class="hljs-keyword">while</span>(arr_mapping.<span class="hljs-built_in">find</span>(num_i+num_j) != arr_mapping.<span class="hljs-built_in">end</span>())&#123;<br>                    length++;<br>                    tmp = num_i;<br>                    num_i = num_j;<br>                    num_j = tmp+num_j;<br>                &#125;<br>                max_num = <span class="hljs-built_in">max</span>(max_num, length);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max_num == <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">return</span> max_num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>动态规划优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; arr_mapping;<br>        <span class="hljs-type">int</span> max_num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            arr_mapping[arr[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(arr_mapping.<span class="hljs-built_in">find</span>(arr[i]-arr[j]) != arr_mapping.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-number">2</span>*arr[j]&gt;arr[i])&#123;<br>                    k = arr_mapping[arr[i]-arr[j]];<br>                    dp[j][i] = <span class="hljs-built_in">max</span>(dp[k][j]+<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>                &#125;<br>                max_num = <span class="hljs-built_in">max</span>(max_num,dp[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_num;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="2-最深叶节点的最近公共祖先"><a href="#2-最深叶节点的最近公共祖先" class="headerlink" title="2.  最深叶节点的最近公共祖先"></a>2.  最深叶节点的最近公共祖先</h1><p>给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。</p><p>回想一下：</p><ul><li>叶节点 是二叉树中没有子节点的节点</li><li>树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1</li><li>如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。</li></ul><p><img src="/img/%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.png"><br>自上而下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode* ans = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> maxdepth = <span class="hljs-number">-1</span>;<br><br>        function&lt;<span class="hljs-type">int</span>(TreeNode*, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](TreeNode* node, <span class="hljs-type">int</span> depth)&#123;<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>                maxdepth = <span class="hljs-built_in">max</span>(depth, maxdepth);<br>                <span class="hljs-keyword">return</span> depth;<br>            &#125;<br>            <span class="hljs-type">int</span> maxleftlength = <span class="hljs-built_in">dfs</span>(node-&gt;left, depth+<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> maxrightlength = <span class="hljs-built_in">dfs</span>(node-&gt;right, depth+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(maxleftlength == maxrightlength &amp;&amp; maxleftlength == maxdepth)&#123;<br>                ans = node;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxleftlength,maxrightlength);<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>自底向上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, TreeNode*&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-literal">nullptr</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">auto</span>[leftheight, ica_left] = <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>        <span class="hljs-keyword">auto</span>[righheight, ica_right] = <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(leftheight&gt;righheight)&#123;<span class="hljs-keyword">return</span> &#123;leftheight+<span class="hljs-number">1</span>, ica_left&#125;;&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(righheight&gt;leftheight)&#123;<span class="hljs-keyword">return</span> &#123;righheight+<span class="hljs-number">1</span>, ica_right&#125;;&#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> &#123;leftheight+<span class="hljs-number">1</span>,node&#125;;&#125;<br><br><br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root).second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-判断矩阵经轮转后是否一致"><a href="#3-判断矩阵经轮转后是否一致" class="headerlink" title="3. 判断矩阵经轮转后是否一致"></a>3. 判断矩阵经轮转后是否一致</h1><p>给你两个大小为 n x n 的二进制矩阵 mat 和 target 。现 以 90 度顺时针轮转 矩阵 mat 中的元素 若干次 ，如果能够使 mat 与 target 一致，返回 true ；否则，返回 false 。<br><img src="/img/%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E7%BB%8F%E8%BD%AE%E8%BD%AC%E5%90%8E%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findRotation</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = mat.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;<span class="hljs-number">4</span>; k++)&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span> &amp;&amp; mat[i][j]==target[j][n<span class="hljs-number">-1</span>-i] || k==<span class="hljs-number">1</span> &amp;&amp; mat[i][j]==target[n<span class="hljs-number">-1</span>-i][n<span class="hljs-number">-1</span>-j] || k==<span class="hljs-number">2</span> &amp;&amp; mat[i][j]==target[n<span class="hljs-number">-1</span>-j][i] || k==<span class="hljs-number">3</span> &amp;&amp; mat[i][j]==target[i][j])&#123;<span class="hljs-keyword">continue</span>;&#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        flag = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day13</title>
    <link href="/2023/12/26/LeedCode/LeedCode-20231226/"/>
    <url>/2023/12/26/LeedCode/LeedCode-20231226/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-按既定顺序创建目标数组"><a href="#1-按既定顺序创建目标数组" class="headerlink" title="1. 按既定顺序创建目标数组"></a>1. 按既定顺序创建目标数组</h1><p>给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：</p><ul><li>目标数组 target 最初为空。</li><li>按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。</li><li>重复上一步，直到在 nums 和 index 中都没有要读取的元素。<br>请你返回目标数组。</li></ul><p>题目保证数字插入位置总是存在。<br><img src="/img/%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//本题注意vector中insert的使用</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">createTargetArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; index)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result; <br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> tmp = result.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span>(tmp<span class="hljs-number">-1</span>&lt;index[i])&#123;result.<span class="hljs-built_in">push_back</span>(nums[i]);&#125;<br>            <span class="hljs-keyword">else</span>&#123;result.<span class="hljs-built_in">insert</span>(result.<span class="hljs-built_in">begin</span>()+index[i], nums[i]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-转变数组后最接近目标值的数组和"><a href="#2-转变数组后最接近目标值的数组和" class="headerlink" title="2.  转变数组后最接近目标值的数组和"></a>2.  转变数组后最接近目标值的数组和</h1><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 arr 中的数字。<br><img src="/img/%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> real = INT_MAX;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result3 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result4 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>] + arr[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(target - presum[i] - arr[i]*(n-i));<br>            <span class="hljs-keyword">if</span>(real &gt; diff)&#123;<br>                index = i;<br>                real = diff; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">return</span> arr[n<span class="hljs-number">-1</span>];&#125;<br>        result1 = <span class="hljs-built_in">abs</span>(target-presum[index])/(n-index);<br>        result2 = <span class="hljs-built_in">abs</span>(target-presum[index+<span class="hljs-number">1</span>])/(n-index<span class="hljs-number">-1</span>);<br>        result2 = <span class="hljs-built_in">max</span>(result1,result2);<br>        result3 = result1 + <span class="hljs-number">1</span>;<br>        result4 = result2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target - presum[index] - result1*(n-index)) &lt; <span class="hljs-built_in">abs</span>(target - presum[index+<span class="hljs-number">1</span>] - result2*(n-index<span class="hljs-number">-1</span>)))&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target - presum[index] - result3*(n-index)) &lt; <span class="hljs-built_in">abs</span>(target - presum[index] - result1*(n-index)))&#123;<br>                result = result3;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;result = result1;&#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target - presum[index+<span class="hljs-number">1</span>] - result4*(n-index<span class="hljs-number">-1</span>)) &lt; <span class="hljs-built_in">abs</span>(target - presum[index+<span class="hljs-number">1</span>] - result2*(n-index<span class="hljs-number">-1</span>)))&#123;<br>                result = result4;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;result = result2;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-差值数组不同的字符串"><a href="#3-差值数组不同的字符串" class="headerlink" title="3. 差值数组不同的字符串"></a>3. 差值数组不同的字符串</h1><p>给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。</p><p>每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 &lt;&#x3D; j &lt;&#x3D; n - 2 有 difference[i][j] &#x3D; words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 ‘a’ 的位置是 0 ，’b’ 的位置是 1 ，’z’ 的位置是 25 。</p><ul><li>比方说，字符串 “acb” 的差值整数数组是 [2 - 0, 1 - 2] &#x3D; [2, -1] 。<br>words 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</li></ul><p>请你返回 words中 差值整数数组 不同的字符串。<br><img src="/img/%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">oddString</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; diff;<br>        <span class="hljs-type">int</span> n = words.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            string str = words[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;str.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(str[i]-str[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>            diff.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; reference = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec = diff[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;vec.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(reference[j] != vec[j])&#123;<br>                    index = i;<br>                    cnt++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt == n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">return</span> words[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> words[index];&#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-获得分数的方法数"><a href="#4-获得分数的方法数" class="headerlink" title="4. 获得分数的方法数"></a>4. 获得分数的方法数</h1><p>考试中有 n 种类型的题目。给你一个整数 target 和一个下标从 0 开始的二维整数数组 types ，其中 types[i] &#x3D; [counti, marksi] 表示第 i 种类型的题目有 counti 道，每道题目对应 marksi 分。</p><p>返回你在考试中恰好得到 target 分的方法数。由于答案可能很大，结果需要对 109 +7 取余。</p><p>注意，同类型题目无法区分。</p><ul><li>比如说，如果有 3 道同类型题目，那么解答第 1 和第 2 道题目与解答第 1 和第 3 道题目或者第 2 和第 3 道题目是相同的。<br><img src="/img/%E8%8E%B7%E5%BE%97%E5%88%86%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> modul = <span class="hljs-number">7</span>+<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">waysToReachTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; types)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dp[target+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> qs:types)&#123;<br>            <span class="hljs-type">int</span> count = qs[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> mark = qs[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = target; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j&lt;= <span class="hljs-built_in">min</span>(count, i/mark);j++)&#123;<br>                    dp[i] = (dp[i] + dp[i-j*mark])%modul;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day12</title>
    <link href="/2023/12/25/LeedCode/LeedCode-20231225/"/>
    <url>/2023/12/25/LeedCode/LeedCode-20231225/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-移除栅栏得到的正方形田地的最大面积"><a href="#1-移除栅栏得到的正方形田地的最大面积" class="headerlink" title="1. 移除栅栏得到的正方形田地的最大面积"></a>1. 移除栅栏得到的正方形田地的最大面积</h1><p>有一个大型的 (m - 1) x (n - 1) 矩形田地，其两个对角分别是 (1, 1) 和 (m, n) ，田地内部有一些水平栅栏和垂直栅栏，分别由数组 hFences 和 vFences 给出。</p><p>水平栅栏为坐标 (hFences[i], 1) 到 (hFences[i], n)，垂直栅栏为坐标 (1, vFences[i]) 到 (m, vFences[i]) 。</p><p>返回通过 移除 一些栅栏（可能不移除）所能形成的最大面积的 正方形 田地的面积，或者如果无法形成正方形田地则返回 -1。</p><p>由于答案可能很大，所以请返回结果对 109 + 7 取余 后的值。</p><p>注意：田地外围两个水平栅栏（坐标 (1, 1) 到 (1, n) 和坐标 (m, 1) 到 (m, n) ）以及两个垂直栅栏（坐标 (1, 1) 到 (m, 1) 和坐标 (1, n) 到 (m, n) ）所包围。这些栅栏 不能 被移除。<br><img src="/img/%E7%A7%BB%E9%99%A4%E6%A0%85%E6%A0%8F%E5%BE%97%E5%88%B0%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%94%B0%E5%9C%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximizeSquareArea</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; hFences, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vFences)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> modul = <span class="hljs-number">7</span>+<span class="hljs-number">1e9</span>;<br>        hFences.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        hFences.<span class="hljs-built_in">push_back</span>(m);<br>        vFences.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        vFences.<span class="hljs-built_in">push_back</span>(n);<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;vFences.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=vFences.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; j&gt;i; j-- )&#123;<br>                st.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">abs</span>(vFences[j]-vFences[i]));<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;hFences.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = hFences.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; j&gt;i; j--)&#123;<br>                <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(hFences[j]-hFences[i]);<br>                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(diff))&#123;<br>                    ans = <span class="hljs-built_in">max</span>(ans, diff);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * ans * ans % modul;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-转换字符串的最小成本I"><a href="#2-转换字符串的最小成本I" class="headerlink" title="2.  转换字符串的最小成本I"></a>2.  转换字符串的最小成本I</h1><p><strong>提示</strong>：Floyd-Warshall 最短路算法<a href="https://zhuanlan.zhihu.com/p/623757829">Click to jump</a></p><p>给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。</p><p>另给你两个下标从 0 开始的字符数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符 original[i] 更改为字符 changed[i] 的成本。</p><p>你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] &#x3D;&#x3D; z  、original[j] &#x3D;&#x3D; x 以及 changed[j] &#x3D;&#x3D; y 。你就可以选择字符串中的一个字符 x 并以 z 的成本将其更改为字符 y 。</p><p>返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1 。</p><p>注意，可能存在下标 i 、j 使得 original[j] &#x3D;&#x3D; original[i] 且 changed[j] &#x3D;&#x3D; changed[i] 。<br><img src="/img/%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%ACI.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minimumCost</span><span class="hljs-params">(string source, string target, vector&lt;<span class="hljs-type">char</span>&gt;&amp; original, vector&lt;<span class="hljs-type">char</span>&gt;&amp; changed, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>,<span class="hljs-number">0x3f3f3f3f</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">26</span>; i++)&#123;<br>            dp[i][i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;original.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> x = original[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-type">int</span> y = changed[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            dp[x][y] = <span class="hljs-built_in">min</span>(dp[x][y], cost[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;<span class="hljs-number">26</span>; k++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">26</span>; i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;<span class="hljs-number">26</span>; j++)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k]+dp[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;source.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            result += dp[source[i]-<span class="hljs-string">&#x27;a&#x27;</span>][target[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(dp[source[i]-<span class="hljs-string">&#x27;a&#x27;</span>][target[i]-<span class="hljs-string">&#x27;a&#x27;</span>] ==<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day11</title>
    <link href="/2023/12/24/LeedCode/LeedCode-20231224/"/>
    <url>/2023/12/24/LeedCode/LeedCode-20231224/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-找出两数组的不同"><a href="#1-找出两数组的不同" class="headerlink" title="1. 找出两数组的不同"></a>1. 找出两数组的不同</h1><p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：</p><ul><li>answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。</li><li>answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。<br>注意：列表中的整数可以按 任意 顺序返回。<br><img src="/img/%E6%89%BE%E5%87%BA%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findDifference</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result1;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> point1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> point2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> number1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> number2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        nums1.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>()), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>        nums2.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>()), nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(point1&lt;n1 &amp;&amp; point2&lt;n2)&#123;<br>            number1 = nums1[point1];<br>            number2 = nums2[point2];<br>            <span class="hljs-keyword">if</span>(number1 == number2)&#123;<br>                point1++;<br>                point2++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(number1&lt;number2)&#123;<br>                result2.<span class="hljs-built_in">push_back</span>(number1);<br>                point1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(number2&lt;number1)&#123;<br>                result1.<span class="hljs-built_in">push_back</span>(number2);<br>                point2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(point1&lt;n1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = point1; i&lt;n1; i++)&#123;<br>                result2.<span class="hljs-built_in">push_back</span>(nums1[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(point2&lt;n2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = point2; i&lt;n2; i++)&#123;<br>                result1.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>            &#125;<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(result2);<br>        result.<span class="hljs-built_in">push_back</span>(result1);<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="2-执行逐位运算使字符串相等"><a href="#2-执行逐位运算使字符串相等" class="headerlink" title="2.  执行逐位运算使字符串相等"></a>2.  执行逐位运算使字符串相等</h1><p>给你两个下标从 0 开始的 二元 字符串 s 和 target ，两个字符串的长度均为 n 。你可以对 s 执行下述操作 任意 次：</p><ul><li>选择两个 不同 的下标 i 和 j ，其中 0 &lt;&#x3D; i, j &lt; n 。</li><li>同时，将 s[i] 替换为 (s[i] OR s[j]) ，s[j] 替换为 (s[i] XOR s[j]) 。<br>例如，如果 s &#x3D; “0110” ，你可以选择 i &#x3D; 0 和 j &#x3D; 2，然后同时将 s[0] 替换为 (s[0] OR s[2] &#x3D; 0 OR 1 &#x3D; 1)，并将 s[2] 替换为 (s[0] XOR s[2] &#x3D; 0 XOR 1 &#x3D; 1)，最终得到 s &#x3D; “1110” 。</li></ul><p>如果可以使 s 等于 target ，返回 true ，否则，返回 false 。<br><img src="/img/%E6%89%A7%E8%A1%8C%E9%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makeStringsEqual</span><span class="hljs-params">(string s, string target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; s_map;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; target_map;<br>        <span class="hljs-type">bool</span> flag;<br><br>        s_map[<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-number">0</span>;<br>        s_map[<span class="hljs-string">&#x27;1&#x27;</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            s_map[s[i]]++;<br>            target_map[target[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s==target || (target_map[<span class="hljs-string">&#x27;1&#x27;</span>]&amp;&amp;s_map[<span class="hljs-string">&#x27;1&#x27;</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-矩阵中的幸运数"><a href="#3-矩阵中的幸运数" class="headerlink" title="3. 矩阵中的幸运数"></a>3. 矩阵中的幸运数</h1><p>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数 是指矩阵中满足同时下列两个条件的元素：</p><ul><li>在同一行的所有元素中最小</li><li>在同一列的所有元素中最大<br><img src="/img/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> column = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">max_list</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, INT_MAX));<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">min_list</span><span class="hljs-params">(column,<span class="hljs-number">0</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;column; j++)&#123;<br>                <span class="hljs-type">int</span> num = matrix[i][j];<br>                <span class="hljs-keyword">if</span>(max_list[i][<span class="hljs-number">0</span>] &gt; num)&#123;<br>                    max_list[i][<span class="hljs-number">0</span>] = num;<br>                    max_list[i][<span class="hljs-number">1</span>] = j;<br>                &#125;<br>                min_list[j] = <span class="hljs-built_in">max</span>(min_list[j], num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-type">int</span> c = max_list[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(max_list[i][<span class="hljs-number">0</span>] == min_list[c] &amp;&amp; max_list[i][<span class="hljs-number">0</span>] == matrix[i][c])&#123;result.<span class="hljs-built_in">push_back</span>(max_list[i][<span class="hljs-number">0</span>]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="4-警告一小时内使用相同员工卡大于等于三次的人"><a href="#4-警告一小时内使用相同员工卡大于等于三次的人" class="headerlink" title="4. 警告一小时内使用相同员工卡大于等于三次的人"></a>4. 警告一小时内使用相同员工卡大于等于三次的人</h1><p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。</p><p>给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。</p><p>使用时间的格式是 24小时制 ，形如 “HH:MM” ，比方说 “23:51” 和 “09:49” 。</p><p>请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。</p><p>请注意 “10:00” - “11:00” 视为一个小时时间范围内，而 “22:51” - “23:52” 不被视为一小时时间范围内。<br><img src="/img/%E8%AD%A6%E5%91%8A%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%91%98%E5%B7%A5%E5%8D%A1%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%89%E6%AC%A1%E7%9A%84%E4%BA%BA.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">alertNames</span><span class="hljs-params">(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        unordered_map&lt;string, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mapping;<br>        <span class="hljs-type">int</span> n = keyName.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> hour;<br>            <span class="hljs-type">int</span> minute;<br>            <br>            hour = <span class="hljs-number">10</span>*(keyTime[i][<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + keyTime[i][<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            minute = <span class="hljs-number">10</span>*(keyTime[i][<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + keyTime[i][<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            minute = (minute + <span class="hljs-number">60</span>*hour);<br>            mapping[keyName[i]].<span class="hljs-built_in">push_back</span>(minute);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mapping.<span class="hljs-built_in">begin</span>(); it!=mapping.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; time_list = it-&gt;second;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">sort</span>(time_list.<span class="hljs-built_in">begin</span>(),time_list.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;time_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-type">int</span> reference = time_list[i];<br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> index = i;<br>                <span class="hljs-keyword">while</span>((i&lt;time_list.<span class="hljs-built_in">size</span>()) &amp;&amp; ((<span class="hljs-built_in">abs</span>(reference-time_list[i]))&lt;=<span class="hljs-number">60</span>))&#123;<br>                    cnt++;<br>                    i++;<br>                &#125;<br>                i = index;<br>                <span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">3</span>)&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;result.<span class="hljs-built_in">push_back</span>(it-&gt;first);&#125;<br>        &#125;<br>        <span class="hljs-comment">//sort(result.begin(),result.end(), [&amp;](string &amp;a, string &amp;b) &#123;return (a[0]-&#x27;a&#x27;)&lt;(b[0]-&#x27;a&#x27;);&#125;);</span><br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-坏了的计算器"><a href="#5-坏了的计算器" class="headerlink" title="5. 坏了的计算器"></a>5. 坏了的计算器</h1><p>在显示着数字 startValue 的坏计算器上，我们可以执行以下两种操作：</p><ul><li>双倍（Double）：将显示屏上的数字乘 2；</li><li>递减（Decrement）：将显示屏上的数字减 1 。<br>给定两个整数 startValue 和 target 。返回显示数字 target 所需的最小操作数。<br><img src="/img/%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">brokenCalc</span><span class="hljs-params">(<span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cycle = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(startValue &lt; target)&#123;<br>            startValue *=<span class="hljs-number">2</span>;<br>            res++;<br>            cycle++;<br>        &#125;<br>        diff = startValue - target;<br>        <span class="hljs-keyword">while</span>(diff != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> d = diff/(<span class="hljs-number">1</span> &lt;&lt; (cycle));<br>            diff -= d*(<span class="hljs-number">1</span> &lt;&lt; (cycle));<br>            cycle = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,cycle<span class="hljs-number">-1</span>);<br>            res += d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;                              <br></code></pre></td></tr></table></figure></li></ul><h1 id="6-最长上传前缀"><a href="#6-最长上传前缀" class="headerlink" title="6. 最长上传前缀"></a>6. 最长上传前缀</h1><p>给你一个 n 个视频的上传序列，每个视频编号为 1 到 n 之间的 不同 数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 最长上传前缀 。</p><p>如果 闭区间 1 到 i 之间的视频全部都已经被上传到服务器，那么我们称 i 是上传前缀。最长上传前缀指的是符合定义的 i 中的 最大值 。</p><p>请你实现 LUPrefix 类：</p><ul><li>LUPrefix(int n) 初始化一个 n 个视频的流对象。</li><li>void upload(int video) 上传 video 到服务器。</li><li>int longest() 返回上述定义的 最长上传前缀 的长度。<br><img src="/img/%E6%9C%80%E9%95%BF%E4%B8%8A%E4%BC%A0%E5%89%8D%E7%BC%80.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LUPrefix</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited;<br>    <span class="hljs-type">int</span> length;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LUPrefix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            visited.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upload</span><span class="hljs-params">(<span class="hljs-type">int</span> video)</span> </span>&#123;<br>        visited[video]=<span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longest</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(length+<span class="hljs-number">1</span>&lt;=n &amp;&amp; visited[length+<span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>)&#123;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LUPrefix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LUPrefix* obj = new LUPrefix(n);</span><br><span class="hljs-comment"> * obj-&gt;upload(video);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;longest();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="7-得到山形数组的最少删除次数"><a href="#7-得到山形数组的最少删除次数" class="headerlink" title="7. 得到山形数组的最少删除次数"></a>7. 得到山形数组的最少删除次数</h1><p>我们定义 arr 是 山形数组 当且仅当它满足：</p><ul><li>arr.length &gt;&#x3D; 3</li><li>存在某个下标 i （从 0 开始） 满足 0 &lt; i &lt; arr.length - 1 且：</li><li><ul><li>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]</li></ul></li><li><ul><li>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给你整数数组 nums​ ，请你返回将 nums 变成 山形状数组 的​ 最少 删除次数。<br><img src="/img/%E5%BE%97%E5%88%B0%E5%B1%B1%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumMountainRemovals</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n)</span>, increase_list</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(increase_list.<span class="hljs-built_in">begin</span>(), increase_list.<span class="hljs-built_in">end</span>(), x);<br>            after[i] = it-increase_list.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(it == increase_list.<span class="hljs-built_in">end</span>())&#123;<br>                increase_list.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                *it = x;<br>            &#125;<br>        &#125;<br>        increase_list.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(increase_list.<span class="hljs-built_in">begin</span>(), increase_list.<span class="hljs-built_in">end</span>(), x);<br>            pre = it-increase_list.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(it == increase_list.<span class="hljs-built_in">end</span>())&#123;<br>                increase_list.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                *it = x;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pre &gt;= <span class="hljs-number">2</span> &amp;&amp; after[i] &gt;=<span class="hljs-number">2</span>)&#123;<br>                result = <span class="hljs-built_in">max</span>(result, pre + after[i] <span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="8-移除石子使总数最小"><a href="#8-移除石子使总数最小" class="headerlink" title="8. 移除石子使总数最小"></a>8. 移除石子使总数最小</h1><p>给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次：</p><ul><li>选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] &#x2F; 2) 颗石子。<br>注意：你可以对 同一堆 石子多次执行此操作。</li></ul><p>返回执行 k 次操作后，剩下石子的 最小 总数。</p><p>floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。<br><img src="/img/%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E4%BD%BF%E6%80%BB%E6%95%B0%E6%9C%80%E5%B0%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minStoneSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(piles.begin(), piles.end())</span></span>;<br><br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> num = pq.<span class="hljs-built_in">top</span>() - pq.<span class="hljs-built_in">top</span>()/<span class="hljs-number">2</span>;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(num);<br>            k--;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>            result += pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day10</title>
    <link href="/2023/12/21/LeedCode/LeedCode-20231221/"/>
    <url>/2023/12/21/LeedCode/LeedCode-20231221/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-执行子串操作后的字典序最小字符串"><a href="#1-执行子串操作后的字典序最小字符串" class="headerlink" title="1. 执行子串操作后的字典序最小字符串"></a>1. 执行子串操作后的字典序最小字符串</h1><p>给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为：</p><ul><li>选择 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，’b’ 用 ‘a’ 替换，’a’ 用 ‘z’ 替换。<br>返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。</li></ul><p>子字符串 是字符串中的一个连续字符序列。</p><p>现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] !&#x3D; y[i] 的第一个位置 i 上，如果  x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。<br><img src="/img/%E6%89%A7%E8%A1%8C%E5%AD%90%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">smallestString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">while</span>(s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; i&lt;n )&#123;<br>                s[i]--;<br>                i++;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">return</span> s;&#125;<br>        s[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;z&#x27;</span>;<br>        <br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-HTML-实体解析器"><a href="#2-HTML-实体解析器" class="headerlink" title="2.  HTML 实体解析器"></a>2.  HTML 实体解析器</h1><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p><p>HTML 里这些特殊字符和它们对应的字符实体包括：</p><ul><li>双引号：字符实体为 &quot; ，对应的字符是 “ 。</li><li>单引号：字符实体为 &apos; ，对应的字符是 ‘ 。</li><li>与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。</li><li>大于号：字符实体为 &gt; ，对应的字符是 &gt; 。</li><li>小于号：字符实体为 &lt; ，对应的字符是 &lt; 。</li><li>斜线号：字符实体为 &frasl; ，对应的字符是 &#x2F; 。<br>给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。<br>![](&#x2F;img&#x2F;HTML 实体解析器.png)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">entityParser</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        string str = <span class="hljs-string">&quot;&quot;</span>;<br>        unordered_map&lt;string, string&gt; HTML_list = &#123;&#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>,<span class="hljs-string">&quot;\&quot;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;\&#x27;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;text.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string tmp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">int</span> index = i;<br>            <span class="hljs-keyword">if</span>(text[i] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">while</span>(index-i&lt;<span class="hljs-number">7</span> &amp;&amp; index&lt;text.<span class="hljs-built_in">size</span>())&#123;<br>                    tmp += text[index];<br>                    <span class="hljs-keyword">if</span>(text[index] == <span class="hljs-string">&#x27;;&#x27;</span>)&#123;<span class="hljs-keyword">break</span>;&#125; <br>                    index++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(HTML_list.<span class="hljs-built_in">find</span>(tmp) != HTML_list.<span class="hljs-built_in">end</span>())&#123;<br>                    i = index;<br>                    str += HTML_list[tmp];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;str += text[i];&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                str += text[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="3-判断字符串的两半是否相似"><a href="#3-判断字符串的两半是否相似" class="headerlink" title="3. 判断字符串的两半是否相似"></a>3. 判断字符串的两半是否相似</h1><p>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。</p><p>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。</p><p>如果 a 和 b 相似，返回 true ；否则，返回 false 。<br><img src="/img/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E5%8D%8A%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">halvesAreAlike</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; vowel = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            cnt += vowel.<span class="hljs-built_in">count</span>(s[i]);<br>            cnt -= vowel.<span class="hljs-built_in">count</span>(s[i+n]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</span><br></code></pre></td></tr></table></figure><h1 id="4-美丽塔-II"><a href="#4-美丽塔-II" class="headerlink" title="4. 美丽塔 II"></a>4. 美丽塔 II</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。</p><p>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。</p><p>如果以下条件满足，我们称这些塔是 美丽 的：</p><ol><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：</li></ol><ul><li>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]</li><li>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。<br><img src="/img/%E7%BE%8E%E4%B8%BD%E5%A1%94II.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[i] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                sum -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(st.<span class="hljs-built_in">top</span>()-j);<br>            &#125;<br>            sum += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[i]*(st.<span class="hljs-built_in">top</span>()-i);<br>            after[i] = sum;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        st = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[j] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> k = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                pre -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[k]*(k-st.<span class="hljs-built_in">top</span>());<br>            &#125;<br>            pre += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(j-st.<span class="hljs-built_in">top</span>());<br>            result = <span class="hljs-built_in">max</span>(result, pre + after[j+<span class="hljs-number">1</span>]);<br>            st.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day9</title>
    <link href="/2023/12/20/LeedCode/LeedCode-20231220/"/>
    <url>/2023/12/20/LeedCode/LeedCode-20231220/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-最大公因数等于-K-的子数组数目"><a href="#1-最大公因数等于-K-的子数组数目" class="headerlink" title="1. 最大公因数等于 K 的子数组数目"></a>1. 最大公因数等于 K 的子数组数目</h1><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。</p><p>子数组 是数组中一个连续的非空序列。</p><p>数组的最大公因数 是能整除数组中所有元素的最大整数。<br>![](&#x2F;img&#x2F;最大公因数等于 K 的子数组数目.png)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarrayGCD</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left&lt;nums.<span class="hljs-built_in">size</span>(); left++)&#123;<br>            <span class="hljs-type">int</span> num = nums[left];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = left; right&lt;nums.<span class="hljs-built_in">size</span>(); right++)&#123;<br>                num = <span class="hljs-built_in">gcd</span>(num,nums[right]);<br>                <span class="hljs-keyword">if</span>(num == k)&#123;result++;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> tmp = a%b;<br>            a = b;<br>            b =tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-二叉树中的伪回文路径"><a href="#2-二叉树中的伪回文路径" class="headerlink" title="2.  二叉树中的伪回文路径"></a>2.  二叉树中的伪回文路径</h1><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p>请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traceback</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt; p)</span></span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        p[node -&gt;val] ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(node -&gt; left == <span class="hljs-literal">nullptr</span> &amp;&amp; node -&gt; right == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">accumulate</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">1</span>)&#123;res++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res = <span class="hljs-built_in">traceback</span>(node -&gt; left, p) + <span class="hljs-built_in">traceback</span>(node -&gt; right, p);<br>        &#125;<br>        p[node -&gt;val] ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pseudoPalindromicPaths</span> <span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        result = <span class="hljs-built_in">traceback</span>(root, p);<br>     <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-统计无向图中无法互相到达点对数"><a href="#3-统计无向图中无法互相到达点对数" class="headerlink" title="3. 统计无向图中无法互相到达点对数"></a>3. 统计无向图中无法互相到达点对数</h1><p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p><p>请你返回 无法互相到达 的不同 点对数目 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:edges)&#123;<br>            g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>            g[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n)</span></span>;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> input) -&gt; <span class="hljs-type">int</span>&#123;<br>            <span class="hljs-type">int</span> size = <span class="hljs-number">1</span>;<br>            visit[input] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> element:g[input])&#123;<br>                <span class="hljs-keyword">if</span>(!visit[element])&#123;size += <span class="hljs-built_in">dfs</span>(element);&#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> size;<br>        &#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, connected_point = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visit[i])&#123;<br>                <span class="hljs-type">int</span> new_connection = <span class="hljs-built_in">dfs</span>(i);<br>                ans += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) connected_point * new_connection;<br>                connected_point += new_connection;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-表现良好的最长时间段"><a href="#4-表现良好的最长时间段" class="headerlink" title="4. 表现良好的最长时间段"></a>4. 表现良好的最长时间段</h1><p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。<br><img src="/img/%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(hours[i]/<span class="hljs-number">9</span>)&#123;hours[i] = <span class="hljs-number">1</span>;&#125;<br>            <span class="hljs-keyword">else</span>&#123;hours[i] = <span class="hljs-number">-1</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>]+hours[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n; j&gt;i; j--)&#123;<br>                <span class="hljs-keyword">if</span>(presum[j]-presum[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    result = <span class="hljs-built_in">max</span>(result,j-i);<br>                    <span class="hljs-keyword">break</span>;    <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//improve using stack</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>]+ (hours[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">8</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">if</span>(presum[i] &lt; presum[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; presum[i]&gt;presum[st.<span class="hljs-built_in">top</span>()])&#123;<br>                result = <span class="hljs-built_in">max</span>(result, i-st.<span class="hljs-built_in">top</span>());<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-寻找峰值"><a href="#5-寻找峰值" class="headerlink" title="5. 寻找峰值"></a>5. 寻找峰值</h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p><p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。<br><img src="/img/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> middle;<br><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; nums[middle+<span class="hljs-number">1</span>])&#123;<br>                right = middle;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[middle] &lt; nums[middle+<span class="hljs-number">1</span>])&#123;<br>                left = middle +<span class="hljs-number">1</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="6-统计区间中的整数数目"><a href="#6-统计区间中的整数数目" class="headerlink" title="6. 统计区间中的整数数目"></a>6. 统计区间中的整数数目</h1><p>给你区间的 空 集，请你设计并实现满足要求的数据结构：</p><p>新增：添加一个区间到这个区间集合中。<br>统计：计算出现在 至少一个 区间中的整数个数。<br>实现 CountIntervals 类：</p><p>CountIntervals() 使用区间的空集初始化对象<br>void add(int left, int right) 添加区间 [left, right] 到区间集合之中。<br>int count() 返回出现在 至少一个 区间中的整数个数。<br>注意：区间 [left, right] 表示满足 left &lt;&#x3D; x &lt;&#x3D; right 的所有整数 x 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E5%8C%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountIntervals</span> &#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CountIntervals</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = m.<span class="hljs-built_in">lower_bound</span>(left); it!=m.<span class="hljs-built_in">end</span>() &amp;&amp; it -&gt; second &lt;= right; m.<span class="hljs-built_in">erase</span>(it++))&#123;<br>            <span class="hljs-type">int</span> l = it-&gt;second;<br>            <span class="hljs-type">int</span> r = it-&gt;first;<br>            left = <span class="hljs-built_in">min</span>(l, left);<br>            right = <span class="hljs-built_in">max</span>(r,right);<br>            cnt -= r-l+<span class="hljs-number">1</span>;<br>        &#125;<br>        cnt += right-left+<span class="hljs-number">1</span>;<br>        m[right] = left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CountIntervals object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CountIntervals* obj = new CountIntervals();</span><br><span class="hljs-comment"> * obj-&gt;add(left,right);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;count();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inside the C++ Object Model-1</title>
    <link href="/2023/12/18/Inside%20the%20C++%20Object%20Model-1/"/>
    <url>/2023/12/18/Inside%20the%20C++%20Object%20Model-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-对象模式"><a href="#C-对象模式" class="headerlink" title="C++对象模式"></a>C++对象模式</h1><span id="more"></span><p>下面是示例代码，以下对于模型的介绍都围绕着示例代码展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> xval);<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Point</span>();<br>    <br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">PointCount</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os)</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-type">float</span> _x;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> _point_count;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1-简单对象模型"><a href="#1-简单对象模型" class="headerlink" title="1. 简单对象模型"></a>1. 简单对象模型</h2><p>正如名字中的简单二字，简单对象模式的设计初衷是为了降低C++编译器的复杂度，其示例代码(参考深入探索C++对象模型)和设计模型如下图。对于简单对象模式，一个对象被分成了许多slot，slot的个数对应于class中member的个数，从上到下按照在class中的申明顺序进行排列。为了适应class中member的不同类型，slot中存放的是执行具体member的指针。在进行member寻址的时候通过slot的索引值来进行查找。<br>优点：降低了C++编译器的设计复杂度。<br>缺点：降低了C++编译器的空间利用率和执行时的效率。</p><h3 id="加上继承"><a href="#加上继承" class="headerlink" title="加上继承"></a>加上继承</h3><p>假设有两个类，base_point和 derived_point，其中base_point为derived_class的父类。那么在简单对象模型中，base_point会被derived_point的一个slot来指出，slot中储存的是base_point的地址。<br>优点：由间接性导致的空间和存取时间上的额外损耗。<br>缺点：derived_point的大小与base_point的大小无关。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p><h2 id="2-表格驱动对象模型"><a href="#2-表格驱动对象模型" class="headerlink" title="2.表格驱动对象模型"></a>2.表格驱动对象模型</h2><p>表格驱动对象模型也被称为双表格模型。相比与上面的简单对象模式，表格驱动模式将class中的data member和 function member 做了一个区分，将它们分别放在Data Member Table和Function Member Table中。由此Point pt就简化为只拥有两个指针的slot,分别指向两个Table. 这里需要注意的一点是data member直接存放在Data Member Table中，而对于Function Member Table可以类比上述的简单对象模型。其中的不同点在于将Poitn pt替换成了Function Member Table并且每个slot所指向的对象只包含function member.<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E8%A1%A8%E6%A0%BC%E9%A9%B1%E5%8A%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p><h3 id="加上继承-1"><a href="#加上继承-1" class="headerlink" title="加上继承"></a>加上继承</h3><p>可以类比于VirtualTable，会产生另一个叫做Base Class Table 的表格。表格中的每个slot都包含一个base class的地址。Derived Class通过一个bptr的指针指向Base Class Table。<br>缺点：由间接性导致的空间和存取时间上的额外损耗。<br>优点：由于每个class在固定位置都会存在一个bptr指针，每一个class对于继承都保持了一致性。由于Base Class Table的存在，做到了与class本身的分离，所以在无需改变class本身的大小就能增加或是减少base class。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/base_class_table.png"></p><h2 id="3-C-对象模型"><a href="#3-C-对象模型" class="headerlink" title="3.C++对象模型"></a>3.C++对象模型</h2><p>从简单模型到C++对象模型经历了内存空间和存取时间上的优化。相比于上面的双表格模型，C++对象模型对calss的member做了更细的划分。<br>1.Nonstatic data members 放在class之中。<br>2.Static data member 放在class之外。<br>3.Static和nonstatic function member放在class之外。<br>根据上面的示例代码可以画出下面的模型图，读者可以根据C++对象模型各种元素的存放规则去图中一一对应。对于Virtual table 中指针分配的顺序是以type_info开始，并以程序中的申明顺序进行排列。对与type_info的解释，读者可以移步至这篇博客<a href="https://www.cnblogs.com/xuelisheng/p/9479288.html">Click to jump</a>，笔者个人觉得对于RTTI机制，type_info, typeid 和dynamic_cast都做了不错的解释。<br>优点：空间和存取时间效率。<br>缺点：对于nonstatic data member的改变需要进行重新编译。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day8</title>
    <link href="/2023/12/17/LeedCode/LeedCode-20231217/"/>
    <url>/2023/12/17/LeedCode/LeedCode-20231217/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-划分数组并满足最大差限制"><a href="#1-划分数组并满足最大差限制" class="headerlink" title="1. 划分数组并满足最大差限制"></a>1. 划分数组并满足最大差限制</h1><p>给你一个长度为 n 的整数数组 nums，以及一个正整数 k 。</p><p>将这个数组划分为一个或多个长度为 3 的子数组，并满足以下条件：</p><p>nums 中的 每个 元素都必须 恰好 存在于某个子数组中。<br>子数组中 任意 两个元素的差必须小于或等于 k 。<br>返回一个 二维数组 ，包含所有的子数组。如果不可能满足条件，就返回一个空数组。如果有多个答案，返回 任意一个 即可。<br><img src="/img/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E5%B9%B6%E6%BB%A1%E8%B6%B3%E6%9C%80%E5%A4%A7%E5%B7%AE%E9%99%90%E5%88%B6.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">divideArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; empty;<br>        <br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> empty;&#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i = i + <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-type">int</span> left = nums[i];<br>            <span class="hljs-type">int</span> middle = nums[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> right = nums[i+<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(right-left&lt;=k)&#123;result.<span class="hljs-built_in">push_back</span>(&#123;left,middle,right&#125;);&#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> empty;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-使数组成为等数数组的最小代价"><a href="#2-使数组成为等数数组的最小代价" class="headerlink" title="2.  使数组成为等数数组的最小代价"></a>2.  使数组成为等数数组的最小代价</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 nums 。</p><p>你可以对 nums 执行特殊操作 任意次 （也可以 0 次）。每一次特殊操作中，你需要 按顺序 执行以下步骤：</p><p>从范围 [0, n - 1] 里选择一个下标 i 和一个 正 整数 x 。<br>将 |nums[i] - x| 添加到总代价里。<br>将 nums[i] 变为 x 。<br>如果一个正整数正着读和反着读都相同，那么我们称这个数是 回文数 。比方说，121 ，2552 和 65756 都是回文数，但是 24 ，46 ，235 都不是回文数。</p><p>如果一个数组中的所有元素都等于一个整数 y ，且 y 是一个小于 109 的 回文数 ，那么我们称这个数组是一个 等数数组 。</p><p>请你返回一个整数，表示执行任意次特殊操作后使 nums 成为 等数数组 的 最小 总代价。<br><img src="/img/%E4%BD%BF%E6%95%B0%E7%BB%84%E6%88%90%E4%B8%BA%E7%AD%89%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> input)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = input; i&lt;= <span class="hljs-number">1000000000</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTrue</span>(i))&#123;<br>                result[<span class="hljs-number">0</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = input; i&gt;=<span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTrue</span>(i))&#123;<br>                result[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTrue</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> input)</span></span>&#123;<br>        string str = <span class="hljs-built_in">to_string</span>(input);<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(str[left] != str[right])&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minimumCost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">9223372036854775807</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> middle_down = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> middle_up = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> palindrome_number;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; tmp_list;<br>            <br>            middle_up = nums[n/<span class="hljs-number">2</span>];<br>            tmp_list = <span class="hljs-built_in">findNum</span>(middle_up);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;tmp_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(tmp_list[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(tmp_list[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list1;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list2;<br>            <br>            middle_down = (nums[n/<span class="hljs-number">2</span>] + nums[(n/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>])/<span class="hljs-number">2</span>;<br>            middle_up = middle_down + <span class="hljs-number">1</span>;<br>            palindrome_list1 = <span class="hljs-built_in">findNum</span>(middle_up);<br>            palindrome_list2 = <span class="hljs-built_in">findNum</span>(middle_down);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(palindrome_list1[i] != palindrome_list2[<span class="hljs-number">0</span>] &amp;&amp; palindrome_list1[i] != palindrome_list2[<span class="hljs-number">1</span>] &amp;&amp; palindrome_list1[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(palindrome_list1[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list2.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(palindrome_list1[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(palindrome_list2[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp_result = <span class="hljs-number">0</span>;<br>            <br>                palindrome_number = palindrome_list[i];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                    tmp_result += <span class="hljs-built_in">abs</span>(palindrome_number-nums[j]);<br>                &#125;<br>                result = <span class="hljs-built_in">min</span>(result,tmp_result);  <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="3-执行操作使频率分数最大"><a href="#3-执行操作使频率分数最大" class="headerlink" title="3. 执行操作使频率分数最大"></a>3. 执行操作使频率分数最大</h1><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p><p>你可以对数组执行 至多 k 次操作：</p><p>从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。<br>最终数组的频率分数定义为数组中众数的 频率 。</p><p>请你返回你可以得到的 最大 频率分数。</p><p>众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。<br><img src="/img/%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E9%A2%91%E7%8E%87%E5%88%86%E6%95%B0%E6%9C%80%E5%A4%A7.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxFrequencyScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">auto</span> operation_num = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">long</span> <span class="hljs-type">long</span>&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[m]*(m-l) - presum[m] + presum[l];<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = presum[r+<span class="hljs-number">1</span>] - presum[m+<span class="hljs-number">1</span>] - (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[m]*(r-m);<br>            <span class="hljs-keyword">return</span> left + right;<br>        &#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">operation_num</span>(start, (start+i)/<span class="hljs-number">2</span>, i) &gt; k)&#123;<br>                start++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans,i-start+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day7</title>
    <link href="/2023/12/16/LeedCode/LeedCode-20231216/"/>
    <url>/2023/12/16/LeedCode/LeedCode-20231216/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-元素计数"><a href="#1-元素计数" class="headerlink" title="1. 元素计数"></a>1. 元素计数</h1><p>给你一个整数数组 nums ，统计并返回在 nums 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。<br><img src="/img/%E5%85%83%E7%B4%A0%E8%AE%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> right = nums[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != left &amp;&amp; nums[i] != right)&#123;<br>                result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-统计圆内格点数目"><a href="#2-统计圆内格点数目" class="headerlink" title="2.  统计圆内格点数目"></a>2.  统计圆内格点数目</h1><p>给你一个二维整数数组 circles ，其中 circles[i] &#x3D; [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E5%9C%86%E5%86%85%E6%A0%BC%E7%82%B9%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countLatticePoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; circles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = INT_MAX;<br>        <span class="hljs-type">int</span> right = INT_MIN;<br>        <span class="hljs-type">int</span> up = INT_MIN;<br>        <span class="hljs-type">int</span> down = INT_MAX;<br>        <span class="hljs-type">int</span> n = circles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> cc_x = circles[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> cc_y = circles[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> r = circles[i][<span class="hljs-number">2</span>];<br>            left = <span class="hljs-built_in">min</span>(left, cc_x-r);<br>            right = <span class="hljs-built_in">max</span>(right, cc_x+r);<br>            up = <span class="hljs-built_in">max</span>(up, cc_y+r);<br>            down = <span class="hljs-built_in">min</span>(down, cc_y-r);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i&lt;=right; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = down; j&lt;=up; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index&lt;n; index++)&#123;<br>                    <span class="hljs-type">int</span> x = circles[index][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y = circles[index][<span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> R = circles[index][<span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">if</span>((i-x)*(i-x) + (j-y)*(j-y) &lt;= R*R)&#123;<br>                        result++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-反转二叉树的奇数层"><a href="#3-反转二叉树的奇数层" class="headerlink" title="3. 反转二叉树的奇数层"></a>3. 反转二叉树的奇数层</h1><p>给你一棵 完美 二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。</p><p>例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。<br>反转后，返回树的根节点。</p><p>完美 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p><p>节点的 层数 等于该节点到根节点之间的边数。<br><img src="/img/%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A5%87%E6%95%B0%E5%B1%82.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reverseOddLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-type">bool</span> isOdd = <span class="hljs-literal">false</span>;<br>        <br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;TreeNode*&gt; arr;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>                TreeNode* newnode = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(isOdd)&#123;arr.<span class="hljs-built_in">push_back</span>(newnode);&#125;<br>                <span class="hljs-keyword">if</span>(newnode -&gt; left &amp;&amp; newnode -&gt;right)&#123;<br>                    q.<span class="hljs-built_in">push</span>(newnode -&gt; left);<br>                    q.<span class="hljs-built_in">push</span>(newnode -&gt;right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isOdd)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i = i+<span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-built_in">swap</span>(arr[i] -&gt; val, arr[arr.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>] -&gt; val);<br>                &#125;<br>            &#125;<br>            isOdd ^= <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="4-图中的最短环"><a href="#4-图中的最短环" class="headerlink" title="4. 图中的最短环"></a>4. 图中的最短环</h1><p>现有一个含 n 个顶点的 双向 图，每个顶点按从 0 到 n - 1 标记。图中的边由二维整数数组 edges 表示，其中 edges[i] &#x3D; [ui, vi] 表示顶点 ui 和 vi 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p><p>返回图中 最短 环的长度。如果不存在环，则返回 -1 。</p><p>环 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。<br><img src="/img/%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E7%8E%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findShortestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">num_map</span>(n);<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;edges.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> x = edges[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edges[i][<span class="hljs-number">1</span>];<br>            num_map[x].<span class="hljs-built_in">push_back</span>(y);<br>            num_map[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">bfs</span>(i, n, num_map));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &lt; INT_MAX? ans:<span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br><br>        q.<span class="hljs-built_in">emplace</span>(st,<span class="hljs-number">-1</span>);<br>        count[st] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> [end,start] = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> newend:g[end])&#123;<br>                <span class="hljs-keyword">if</span>(count[newend] &lt; <span class="hljs-number">0</span>)&#123;<br>                    count[newend] = count[end] + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(newend,end);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newend != start)&#123;ans = <span class="hljs-built_in">min</span>(ans,count[end] + count[newend]+<span class="hljs-number">1</span>);&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-待复习</title>
    <link href="/2023/12/15/LeedCode/LeedCode-%E5%BE%85%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/12/15/LeedCode/LeedCode-%E5%BE%85%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-用邮票贴满网格图"><a href="#1-用邮票贴满网格图" class="headerlink" title="1. 用邮票贴满网格图"></a>1. 用邮票贴满网格图</h1><p>给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。</p><p>给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</p><ol><li>覆盖所有 空 格子。</li><li>不覆盖任何 被占据 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 重叠 部分。</li><li>邮票不允许 旋转 。</li><li>邮票必须完全在矩阵 内 。<br>如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。<br><img src="/img/%E7%94%A8%E9%82%AE%E7%A5%A8%E8%B4%B4%E6%BB%A1%E7%BD%91%E6%A0%BC%E5%9B%BE.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleToStamp</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> stampHeight, <span class="hljs-type">int</span> stampWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(m+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                s[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = s[i][j+<span class="hljs-number">1</span>] + s[i+<span class="hljs-number">1</span>][j] - s[i][j]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = stampHeight; i1&lt;=m; i1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = stampWidth; j1&lt;=n; j1++)&#123;<br>                <span class="hljs-type">int</span> i2 = i1-stampHeight+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> j2 = j1-stampWidth+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s[i1][j1] - s[i2<span class="hljs-number">-1</span>][j1] - s[i1][j2<span class="hljs-number">-1</span>] + s[i2<span class="hljs-number">-1</span>][j2<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    d[i2][j2]++;<br>                    d[i1+<span class="hljs-number">1</span>][j2]--;<br>                    d[i2][j1+<span class="hljs-number">1</span>]--;<br>                    d[i1+<span class="hljs-number">1</span>][j1+<span class="hljs-number">1</span>]++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] += d[i][j+<span class="hljs-number">1</span>]+d[i+<span class="hljs-number">1</span>][j] - d[i][j];<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">0</span> &amp;&amp; d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="2-美丽塔-II"><a href="#2-美丽塔-II" class="headerlink" title="2. 美丽塔 II"></a>2. 美丽塔 II</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。</p><p>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。</p><p>如果以下条件满足，我们称这些塔是 美丽 的：</p><ol><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：</li></ol><ul><li>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]</li><li>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。<br>![](&#x2F;img&#x2F;美丽塔 II.png)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[i] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                sum -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(st.<span class="hljs-built_in">top</span>()-j);<br>            &#125;<br>            sum += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[i]*(st.<span class="hljs-built_in">top</span>()-i);<br>            after[i] = sum;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        st = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[j] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> k = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                pre -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[k]*(k-st.<span class="hljs-built_in">top</span>());<br>            &#125;<br>            pre += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(j-st.<span class="hljs-built_in">top</span>());<br>            result = <span class="hljs-built_in">max</span>(result, pre + after[j+<span class="hljs-number">1</span>]);<br>            st.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day6</title>
    <link href="/2023/12/15/LeedCode/LeedCode-20231215/"/>
    <url>/2023/12/15/LeedCode/LeedCode-20231215/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-子数组和排序后的区间和"><a href="#1-子数组和排序后的区间和" class="headerlink" title="1. 子数组和排序后的区间和"></a>1. 子数组和排序后的区间和</h1><p>给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) &#x2F; 2 个数字的数组。</p><p>请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。<br><img src="/img/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> MODULO = <span class="hljs-number">1000000007</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        result.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                sum += nums[j];<br>                result.<span class="hljs-built_in">push_back</span>(sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left<span class="hljs-number">-1</span>; i&lt;=right<span class="hljs-number">-1</span>; i++)&#123;<br>            res += result[i];<br>            res = res%MODULO;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-将字符串翻转到单调递增"><a href="#2-将字符串翻转到单调递增" class="headerlink" title="2.  将字符串翻转到单调递增"></a>2.  将字符串翻转到单调递增</h1><p>如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。</p><p>给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。</p><p>返回使 s 单调递增的最小翻转次数。<br><img src="/img/%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>];<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>; <br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-使数组元素全部相等的最少操作次数"><a href="#3-使数组元素全部相等的最少操作次数" class="headerlink" title="3. 使数组元素全部相等的最少操作次数"></a>3. 使数组元素全部相等的最少操作次数</h1><p>给你一个正整数数组 nums 。</p><p>同时给你一个长度为 m 的整数数组 queries 。第 i 个查询中，你需要将 nums 中所有元素变成 queries[i] 。你可以执行以下操作 任意 次：</p><p>将数组里一个元素 增大 或者 减小 1 。<br>请你返回一个长度为 m 的数组 answer ，其中 answer[i]是将 nums 中所有元素变成 queries[i] 的 最少 操作次数。</p><p>注意，每次查询后，数组变回最开始的值。<br><img src="/img/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; result;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> breakpoint = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            presum[i+<span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp = queries[i];<br>            breakpoint = <span class="hljs-built_in">findlocation</span>(nums, tmp);<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = breakpoint*tmp - presum[breakpoint];<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = presum[n] - presum[breakpoint+<span class="hljs-number">1</span>]  - (n-breakpoint<span class="hljs-number">-1</span>)*tmp;<br>            result.<span class="hljs-built_in">push_back</span>(left+right + <span class="hljs-built_in">abs</span>(nums[breakpoint] - tmp));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">findlocation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> middle = (left+right)/<span class="hljs-number">2</span>;;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(nums[middle] == target)&#123;<span class="hljs-keyword">return</span> middle;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle] &lt; target)&#123;<br>                left  = middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = middle;<br>            &#125;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> middle;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</span><br></code></pre></td></tr></table></figure><h1 id="4-用邮票贴满网格图"><a href="#4-用邮票贴满网格图" class="headerlink" title="4. 用邮票贴满网格图"></a>4. 用邮票贴满网格图</h1><p>给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。</p><p>给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</p><ol><li>覆盖所有 空 格子。</li><li>不覆盖任何 被占据 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 重叠 部分。</li><li>邮票不允许 旋转 。</li><li>邮票必须完全在矩阵 内 。<br>如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。<br><img src="/img/%E7%94%A8%E9%82%AE%E7%A5%A8%E8%B4%B4%E6%BB%A1%E7%BD%91%E6%A0%BC%E5%9B%BE.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleToStamp</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> stampHeight, <span class="hljs-type">int</span> stampWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(m+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                s[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = s[i][j+<span class="hljs-number">1</span>] + s[i+<span class="hljs-number">1</span>][j] - s[i][j]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = stampHeight; i1&lt;=m; i1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = stampWidth; j1&lt;=n; j1++)&#123;<br>                <span class="hljs-type">int</span> i2 = i1-stampHeight+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> j2 = j1-stampWidth+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s[i1][j1] - s[i2<span class="hljs-number">-1</span>][j1] - s[i1][j2<span class="hljs-number">-1</span>] + s[i2<span class="hljs-number">-1</span>][j2<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    d[i2][j2]++;<br>                    d[i1+<span class="hljs-number">1</span>][j2]--;<br>                    d[i2][j1+<span class="hljs-number">1</span>]--;<br>                    d[i1+<span class="hljs-number">1</span>][j1+<span class="hljs-number">1</span>]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] += d[i][j+<span class="hljs-number">1</span>]+d[i+<span class="hljs-number">1</span>][j] - d[i][j];<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">0</span> &amp;&amp; d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ol>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day5</title>
    <link href="/2023/12/13/LeedCode/LeedCode-20231213/"/>
    <url>/2023/12/13/LeedCode/LeedCode-20231213/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-找出所有行中最小公共元素"><a href="#1-找出所有行中最小公共元素" class="headerlink" title="1. 找出所有行中最小公共元素"></a>1. 找出所有行中最小公共元素</h1><p>给你一个 m x n 的矩阵 mat，其中每一行的元素均符合 严格递增 。请返回 所有行中的 最小公共元素 。</p><p>如果矩阵中没有这样的公共元素，就请返回 -1。<br><img src="/img/%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E8%A1%8C%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%85%AC%E5%85%B1%E5%85%83%E7%B4%A0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">smallestCommonElement</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        result = <span class="hljs-built_in">cycle</span>(<span class="hljs-number">0</span>, mat.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, mat);<br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cycle</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<span class="hljs-keyword">return</span> mat[left];&#125;<br>        <span class="hljs-keyword">if</span>(right - left == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">intersection</span>(mat[left], mat[right]);&#125;<br><br>        <span class="hljs-type">int</span> middle = (left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersection</span>(<span class="hljs-built_in">cycle</span>(left, middle, mat), <span class="hljs-built_in">cycle</span>(middle+<span class="hljs-number">1</span>, right, mat));<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; int_mapping;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            int_mapping[a[i]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;b.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(int_mapping.<span class="hljs-built_in">find</span>(b[i]) != int_mapping.<span class="hljs-built_in">end</span>())&#123;result.<span class="hljs-built_in">push_back</span>(b[i]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-构成交替字符串需要的最小交换次数"><a href="#2-构成交替字符串需要的最小交换次数" class="headerlink" title="2.  构成交替字符串需要的最小交换次数"></a>2.  构成交替字符串需要的最小交换次数</h1><p>给你一个二进制字符串 s ，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p><p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 “010” 和 “1010” 属于交替字符串，但 “0100” 不是。</p><p>任意两个字符都可以进行交换，不必相邻 。<br><img src="/img/%E6%9E%84%E6%88%90%E4%BA%A4%E6%9B%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; binary_mapping;<br>        vector&lt;<span class="hljs-type">int</span>&gt; continu_1;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        string target1=<span class="hljs-string">&quot;&quot;</span>;<br>        string target2=<span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-number">0</span>;<br>        binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            <span class="hljs-type">char</span> tmp = c;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]++;&#125;<br>            <span class="hljs-keyword">else</span>&#123;binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br><br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">1</span>)&#123;target1 += <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">-1</span>)&#123;target2 += <span class="hljs-string">&#x27;1&#x27;</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i&lt;(binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]+binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>])/<span class="hljs-number">2</span>; i++)&#123;<br>            target1 += <span class="hljs-string">&quot;10&quot;</span>;<br>            target2 += <span class="hljs-string">&quot;01&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">-1</span>)&#123;target1 += <span class="hljs-string">&#x27;1&#x27;</span>;&#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">1</span>)&#123;target2 += <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        result = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">binarystr_and</span>(target1, s),<span class="hljs-built_in">binarystr_and</span>(target2, s));<br><br>        result = (result == s.<span class="hljs-built_in">size</span>())?<span class="hljs-number">0</span>:result;<br>        <br>        <span class="hljs-keyword">return</span> result/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarystr_and</span><span class="hljs-params">(string a, string b)</span></span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] != b[i])&#123;result += <span class="hljs-number">1</span>;&#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-完成所有任务的最少初始能量"><a href="#3-完成所有任务的最少初始能量" class="headerlink" title="3. 完成所有任务的最少初始能量"></a>3. 完成所有任务的最少初始能量</h1><p>给你一个任务数组 tasks ，其中 tasks[i] &#x3D; [actuali, minimumi] ：</p><p>actuali 是完成第 i 个任务 需要耗费 的实际能量。<br>minimumi 是开始第 i 个任务前需要达到的最低能量。<br>比方说，如果任务为 [10, 12] 且你当前的能量为 11 ，那么你不能开始这个任务。如果你当前的能量为 13 ，你可以完成这个任务，且完成它后剩余能量为 3 。</p><p>你可以按照 任意顺序 完成任务。</p><p>请你返回完成所有任务的 最少 初始能量。<br><img src="/img/%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%9D%E5%A7%8B%E8%83%BD%E9%87%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumEffort</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = tasks.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <br><br>        <span class="hljs-built_in">sort</span>(tasks.<span class="hljs-built_in">begin</span>(), tasks.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">1</span>]-b[<span class="hljs-number">0</span>];&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            result = <span class="hljs-built_in">max</span>(result+tasks[i][<span class="hljs-number">0</span>],tasks[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOSBox development environment setup</title>
    <link href="/2023/12/12/Assembly%20language%20development%20environment%20setup/"/>
    <url>/2023/12/12/Assembly%20language%20development%20environment%20setup/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-Download-DOSBox"><a href="#1-Download-DOSBox" class="headerlink" title="1. Download DOSBox"></a>1. Download DOSBox</h1><p>DosBox download link：<a href="https://sourceforge.net/projects/dosbox/">Click to jump</a><br>DosBox offical link：<a href="https://www.dosbox.com/">Click to jump</a></p><h1 id="2-Download-the-assembly-toolkit"><a href="#2-Download-the-assembly-toolkit" class="headerlink" title="2. Download the assembly toolkit"></a>2. Download the assembly toolkit</h1><p>Download link：<a href="https://github.com/xDarkLemon/DOSBox_MASM/tree/master/masm">Click to jump</a><br>At least 4 files must be included in the toolkit</p><ul><li>masm.exe id the assembler, used to execute the assembly source code (.asm) and obtain the target program (.obj).</li><li>link.exe linkd the program, connect the target program, and get the executable program exe</li><li>debug.exe is the debugger, used to debug executable programs (.exe)</li><li>exe2bin.exe is a post-compiled command line utility available on MS-DOS and other operating systems to convert DOS MZ executable files to COM files</li></ul><h1 id="3-Install-DOSBox"><a href="#3-Install-DOSBox" class="headerlink" title="3.Install DOSBox"></a>3.Install DOSBox</h1><p><img src="/img/Dosbox%E5%AE%89%E8%A3%851.png"><br>Click Next<br><img src="/img/Dosbox%E5%AE%89%E8%A3%852.png"><br>Click Next<br><img src="/img/Dosbox%E5%AE%89%E8%A3%852.png"><br>Here I choose to install to the D drive.</p><p>Note: The selection of the directory here will affect the following instructions to mount the working directory.</p><h1 id="4-Create-a-new-working-directory"><a href="#4-Create-a-new-working-directory" class="headerlink" title="4.Create a new working directory"></a>4.Create a new working directory</h1><p><img src="/img/Dosbox%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"><br>Create a new working directory DOSBox under the D drive, and cut the installed DOSBox-0.74 to the working directory.<br><img src="/img/Dosbox%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%952.png"><br>Open the Debug directory, cut the assembly tool package masm to the directory, and create a new folder ASM to store the assembly program you wrote in the future.</p><h1 id="5-Mount-the-working-directory"><a href="#5-Mount-the-working-directory" class="headerlink" title="5.Mount the working directory"></a>5.Mount the working directory</h1><p>The purpose of mounting the working directory here is to enable dosbox to use masm.exe in the configuration tool package<br><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"></p><ul><li>Open the DOSBox installation directory and find the file DOSBox 0.74 Options.bat</li><li>Add the following command below [autoexec]:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">MOUNT F D:\DOSBox\Debug<br>set PATH=%PATH%;F:\MASM;<br>F:<br>cd F:\ASM<br><br></code></pre></td></tr></table></figure><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%952.png"><br>The purpose of this is to avoid having to manually mount it again every time you use DOSBox.<br><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%953.png"><br>Start DOSBox 0.74.exe, and the following automatic program execution will appear to verify the validity of the second part above.</li></ul><h1 id="5-Change-the-size-of-the-DOSBox-command-window"><a href="#5-Change-the-size-of-the-DOSBox-command-window" class="headerlink" title="5.Change the size of the DOSBox command window"></a>5.Change the size of the DOSBox command window</h1><p><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"><br>Open the DOSBox installation directory and find the file DOSBox 0.74 Options.bat<br><img src="/img/%E6%9B%B4%E6%94%B9DOSBox%E5%91%BD%E4%BB%A4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F.png"><br>Find the above code block, change the output to ddraw, and windowresolution to the specific size of the command window. Change it according to your own habits. Here the author chose 1200x640 as the size of the command window.</p><p>Note: x in 1200x640 is a lowercase letter x</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Environment Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day4</title>
    <link href="/2023/12/12/LeedCode/LeedCode-20231212/"/>
    <url>/2023/12/12/LeedCode/LeedCode-20231212/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-罗马数字转整数"><a href="#1-罗马数字转整数" class="headerlink" title="1. 罗马数字转整数"></a>1. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。<br><img src="/img/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; roam_mapping = &#123;&#123;<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>&#125;,&#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>&#125;,&#123;<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>&#125;,&#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>&#125;&#125;;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> roam_mapping[s[<span class="hljs-number">0</span>]];&#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ; i++)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-number">5</span>*roam_mapping[s[i]] == roam_mapping[s[i+<span class="hljs-number">1</span>]]) || (<span class="hljs-number">10</span>*roam_mapping[s[i]] == roam_mapping[s[i+<span class="hljs-number">1</span>]]))&#123;<br>                result = result + roam_mapping[s[i+<span class="hljs-number">1</span>]]-roam_mapping[s[i]];<br>                i++;<br>                <span class="hljs-keyword">if</span>(i == s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;flag = <span class="hljs-literal">true</span>;&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                result +=roam_mapping[s[i]];<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)&#123;result+=roam_mapping[s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]];&#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-列举单词的全部缩写"><a href="#2-列举单词的全部缩写" class="headerlink" title="2.  列举单词的全部缩写"></a>2.  列举单词的全部缩写</h1><p>单词的 广义缩写词 可以通过下述步骤构造：先取任意数量的 不重叠、不相邻 的子字符串，再用它们各自的长度进行替换。</p><p>例如，”abcde” 可以缩写为：<br>“a3e”（”bcd” 变为 “3” ）<br>“1bcd1”（”a” 和 “e” 都变为 “1”）<br>“5” (“abcde” 变为 “5”)<br>“abcde” (没有子字符串被代替)<br>然而，这些缩写是 无效的 ：<br>“23”（”ab” 变为 “2” ，”cde” 变为 “3” ）是无效的，因为被选择的字符串是相邻的<br>“22de” (“ab” 变为 “2” ， “bc” 变为 “2”)  是无效的，因为被选择的字符串是重叠的<br>给你一个字符串 word ，返回 一个由 word 的所有可能 广义缩写词 组成的列表 。按 任意顺序 返回答案。<br><img src="/img/%E5%88%97%E4%B8%BE%E5%8D%95%E8%AF%8D%E7%9A%84%E5%85%A8%E9%83%A8%E7%BC%A9%E5%86%99.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateAbbreviations</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-built_in">traceback</span>(word,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> i, string tmp, <span class="hljs-type">int</span> cnt)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i == word.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>)&#123;tmp += <span class="hljs-built_in">to_string</span>(cnt);&#125;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp, cnt+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp + <span class="hljs-built_in">to_string</span>(cnt) + word[i], <span class="hljs-number">0</span>);&#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp+ word[i], <span class="hljs-number">0</span>);&#125;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br><img src="/img/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        map&lt;<span class="hljs-type">int</span>, string&gt; strs_mapping;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>        <br><br>        <span class="hljs-keyword">if</span>(strs.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-built_in">sort</span>(strs.<span class="hljs-built_in">begin</span>(), strs.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> string&amp; a,<span class="hljs-type">const</span> string&amp; b)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>();&#125;);<br>        string smallest_str = strs[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">while</span>(index&lt;strs.<span class="hljs-built_in">size</span>())&#123;<br>            result = <span class="hljs-built_in">CommonStr</span>(smallest_str, strs[index]);<br>            <span class="hljs-keyword">if</span>(result == <span class="hljs-string">&quot;&quot;</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            smallest_str = result;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">CommonStr</span><span class="hljs-params">(string a, string b)</span></span>&#123;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] == b[i])&#123;<br>                result += a[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-下一个更大元素-IV"><a href="#4-下一个更大元素-IV" class="headerlink" title="4. 下一个更大元素 IV"></a>4. 下一个更大元素 IV</h1><p>给你一个下标从 0 开始的非负整数数组 nums 。对于 nums 中每一个整数，你必须找到对应元素的 第二大 整数。</p><p>如果 nums[j] 满足以下条件，那么我们称它为 nums[i] 的 第二大 整数：</p><p>j &gt; i<br>nums[j] &gt; nums[i]<br>恰好存在 一个 k 满足 i &lt; k &lt; j 且 nums[k] &gt; nums[i] 。<br>如果不存在 nums[j] ，那么第二大整数为 -1 。</p><p>比方说，数组 [1, 2, 4, 3] 中，1 的第二大整数是 4 ，2 的第二大整数是 3 ，3 和 4 的第二大整数是 -1 。<br>请你返回一个整数数组 answer ，其中 answer[i]是 nums[i] 的第二大整数。<br><img src="/img/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0_IV.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">secondGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; first_st, second_st;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; tmp;<br>            <span class="hljs-keyword">while</span>(!second_st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&gt;second_st.<span class="hljs-built_in">top</span>().second)&#123;<br>                result[second_st.<span class="hljs-built_in">top</span>().first] = nums[i];<br>                second_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!first_st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&gt;first_st.<span class="hljs-built_in">top</span>().second)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(first_st.<span class="hljs-built_in">top</span>());<br>                first_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!tmp.<span class="hljs-built_in">empty</span>())&#123;<br>                second_st.<span class="hljs-built_in">push</span>(tmp.<span class="hljs-built_in">back</span>());<br>                tmp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            first_st.<span class="hljs-built_in">push</span>(&#123;i,nums[i]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day3</title>
    <link href="/2023/12/11/LeedCode/LeedCode-20231211/"/>
    <url>/2023/12/11/LeedCode/LeedCode-20231211/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-去除重复字母"><a href="#1-去除重复字母" class="headerlink" title="1. 去除重复字母"></a>1. 去除重复字母</h1><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br><img src="/img/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alpha_list</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left_list</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; result;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            alpha_list[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        result.<span class="hljs-built_in">push</span>(s[<span class="hljs-number">0</span>]);<br>        alpha_list[s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        left_list[s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-built_in">i</span>&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> s_num = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!result.<span class="hljs-built_in">empty</span>() &amp;&amp;(left_list[s_num]))&#123;<br>                alpha_list[s_num]--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!result.<span class="hljs-built_in">empty</span>() &amp;&amp; (result.<span class="hljs-built_in">top</span>() - <span class="hljs-string">&#x27;a&#x27;</span>)&gt;(s_num) &amp;&amp; alpha_list[result.<span class="hljs-built_in">top</span>()-<span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                left_list[result.<span class="hljs-built_in">top</span>()-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                result.<span class="hljs-built_in">pop</span>();   <br>            &#125;   <br>            <span class="hljs-keyword">if</span>(left_list[s_num])&#123;<span class="hljs-keyword">continue</span>;&#125;<br>            alpha_list[s_num]--;<br>            result.<span class="hljs-built_in">push</span>(s[i]);<br>            left_list[s_num]++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!result.<span class="hljs-built_in">empty</span>())&#123;<br>            res += result.<span class="hljs-built_in">top</span>();<br>            result.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-二叉树的垂直遍历"><a href="#2-二叉树的垂直遍历" class="headerlink" title="2.  二叉树的垂直遍历"></a>2.  二叉树的垂直遍历</h1><p>给你一个二叉树的根结点，返回其结点按 垂直方向（从上到下，逐列）遍历的结果。<br>如果两个结点在同一行和列，那么顺序则为 从左到右。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E7%9B%B4%E9%81%8D%E5%8E%86.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(rides.<span class="hljs-built_in">begin</span>(), rides.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];&#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(rides.size()+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt; rides.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> st = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ed = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> tip = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(rides.<span class="hljs-built_in">begin</span>(),rides.<span class="hljs-built_in">begin</span>()+i, st+<span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> val) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt; val;&#125;);<br>            <span class="hljs-type">int</span> j = <span class="hljs-built_in">distance</span>(rides.<span class="hljs-built_in">begin</span>(), it);<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[j]+ed-st+tip);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rides.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-最大单词长度乘积"><a href="#3-最大单词长度乘积" class="headerlink" title="3. 最大单词长度乘积"></a>3. 最大单词长度乘积</h1><p>给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。<br><img src="/img/%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">masks</span><span class="hljs-params">(words.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;words.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string str = words[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s:str)&#123;<br>                masks[i] |= <span class="hljs-number">1</span> &lt;&lt; (s - <span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;words.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j&lt;words.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>((masks[i] &amp; masks[j]) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-type">int</span> tmp = words[i].<span class="hljs-built_in">size</span>()*words[j].<span class="hljs-built_in">size</span>();<br>                    result = <span class="hljs-built_in">max</span>(result,tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p>给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。<br><img src="/img/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kelement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(index1 == m)&#123;<br>                <span class="hljs-keyword">return</span> nums2[index2+k<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(index2 == n)&#123;<br>                <span class="hljs-keyword">return</span> nums1[index1+k<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[index1], nums2[index2]);<br>            &#125;<br>            <span class="hljs-type">int</span> newindex1 = <span class="hljs-built_in">min</span>(m<span class="hljs-number">-1</span>,index1+k/<span class="hljs-number">2</span><span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> newindex2 = <span class="hljs-built_in">min</span>(n<span class="hljs-number">-1</span>,index2+k/<span class="hljs-number">2</span><span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> val1 = nums1[newindex1];<br>            <span class="hljs-type">int</span> val2 = nums2[newindex2];<br>            <span class="hljs-keyword">if</span>(val1&lt;=val2)&#123;<br>                k -= newindex1-index1+<span class="hljs-number">1</span>;<br>                index1 = newindex1+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                k -= newindex2-index2+<span class="hljs-number">1</span>;<br>                index2 = newindex2+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> total = m+n;<br><br>        <span class="hljs-keyword">if</span>(total%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">kelement</span>(nums1,nums2,(total+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> ((<span class="hljs-built_in">kelement</span>(nums1,nums2,(total)/<span class="hljs-number">2</span>)+<span class="hljs-built_in">kelement</span>(nums1,nums2,(total)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))/<span class="hljs-number">2.0</span>);<br>        &#125;<br>        <br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL Sources Learning-1</title>
    <link href="/2023/12/09/STL%20Sources%20Learning-1/"/>
    <url>/2023/12/09/STL%20Sources%20Learning-1/</url>
    
    <content type="html"><![CDATA[<h1 id="查看GCC对各种C-特性的支持程度"><a href="#查看GCC对各种C-特性的支持程度" class="headerlink" title="查看GCC对各种C++特性的支持程度"></a>查看GCC对各种C++特性的支持程度</h1><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span> defined(__sgi)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;__sgi&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span> defined(__GNUC__)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;__GNUC__&quot;</span> &lt;&lt;endl;<br>    cout &lt;&lt; __GNUC__ &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;__GNUC_MINOR__&lt;&lt;endl;<br>    <span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 2</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NO_DRAND48</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_DRAND48 defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_DRAND48 undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 3</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_STATIC_TEMPLATE_MEMBER_BUG</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 4</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_CLASS_PARTIAL_SPECIALIZATION</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 5</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_EXPLICIT_FUNCTION_TMPL_ARGS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_EXPLICIT_FUNCTION_TMPL_ARGS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 6</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_MEMBER_TEMPLATES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_MEMBER_TEMPLATES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_MEMBER_TEMPLATES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 7</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_LIMITED_DEFAULT_TEMPLATES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_LIMITED_DEFAULT_TEMPLATES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_LIMITED_DEFAULT_TEMPLATES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 8</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NON_TYPE_TMPL_PARAM_BUG</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NON_TYPE_TMPL_PARAM_BUG defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NON_TYPE_TMPL_PARAM_BUG undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 9</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __SGI_STL_NO_ARROW_OPERATOR</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__SGI_STL_NO_ARROW_OPERATOR defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__SGI_STL_NO_ARROW_OPERATOR undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 10</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_USE_EXCEPTIONS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_EXCEPTIONS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_EXCEPTIONS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 11</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_USE_NAMESPACES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_NAMESPACES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_NAMESPACES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 12</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_SGI_THREADS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_SGI_THREADS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_SGI_THREADS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 13</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_WIN32THREADS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_WIN32THREADS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_WIN32THREADS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 14</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NO_NAMESPACES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_NAMESPACES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_NAMESPACES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 15</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_TYPENAME</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_TYPENAME defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_TYPENAME undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 16</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_BOOL</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_BOOL defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_BOOL undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 17</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_EXPLICIT</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_EXPLICIT defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_EXPLICIT undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 18</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_ASSERTIONS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_ASSERTIONS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_ASSERTIONS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day2</title>
    <link href="/2023/12/09/LeedCode/LeedCode-20231209/"/>
    <url>/2023/12/09/LeedCode/LeedCode-20231209/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-下一个更大的数值平衡数"><a href="#1-下一个更大的数值平衡数" class="headerlink" title="1. 下一个更大的数值平衡数"></a>1. 下一个更大的数值平衡数</h1><p>如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。<br>给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalance</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (x&gt;<span class="hljs-number">0</span>)&#123;<br>            count[x%<span class="hljs-number">10</span>]++;<br>            x = x/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count[i] != i)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n+<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">1224444</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBalance</span>(i))&#123;<span class="hljs-keyword">return</span> i;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-出租车的最大盈利"><a href="#2-出租车的最大盈利" class="headerlink" title="2.  出租车的最大盈利"></a>2.  出租车的最大盈利</h1><p>你驾驶出租车行驶在一条有 n 个地点的路上。这 n 个地点从近到远编号为 1 到 n ，你想要从 1 开到 n ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。<br>乘客信息用一个下标从 0 开始的二维数组 rides 表示，其中 rides[i] &#x3D; [starti, endi, tipi] 表示第 i 位乘客需要从地点 starti 前往 endi ，愿意支付 tipi 元的小费。<br>每一位 你选择接单的乘客 i ，你可以 盈利 endi - starti + tipi 元。你同时 最多 只能接一个订单。<br>给你 n 和 rides ，请你返回在最优接单方案下，你能盈利 最多 多少元。<br>注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(rides.<span class="hljs-built_in">begin</span>(), rides.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];&#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(rides.size()+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt; rides.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> st = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ed = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> tip = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(rides.<span class="hljs-built_in">begin</span>(),rides.<span class="hljs-built_in">begin</span>()+i, st+<span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> val) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt; val;&#125;);<br>            <span class="hljs-type">int</span> j = <span class="hljs-built_in">distance</span>(rides.<span class="hljs-built_in">begin</span>(), it);<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[j]+ed-st+tip);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rides.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="3-超级丑数"><a href="#3-超级丑数" class="headerlink" title="3. 超级丑数"></a>3. 超级丑数</h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。<br>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。<br>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthSuperUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; primes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = primes.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">long</span>&gt; result;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">primes_list</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> start_point= <span class="hljs-number">0</span>;<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">long</span> primes_min = INT_MAX;<br>            <span class="hljs-type">long</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;m; j++)&#123;<br>                tmp = result[primes_list[j]]*primes[j];<br>                <span class="hljs-keyword">if</span>(tmp &gt; result.<span class="hljs-built_in">back</span>())&#123;<br>                    <span class="hljs-keyword">if</span>(tmp &lt; primes_min)&#123;<br>                        primes_min = tmp;<br>                        flag = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(primes_min);<br>            primes_list[flag]++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>                <span class="hljs-keyword">if</span>(i != flag &amp;&amp; result[primes_list[i]]*primes[i] == primes_min)&#123;<br>                    primes_list[i]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p><!--版权归LeedCode所有-->]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeedCode-Day1</title>
    <link href="/2023/12/08/LeedCode/LeedCode-20231208/"/>
    <url>/2023/12/08/LeedCode/LeedCode-20231208/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-买卖股票的最佳时机含手续费"><a href="#1-买卖股票的最佳时机含手续费" class="headerlink" title="1. 买卖股票的最佳时机含手续费"></a>1. 买卖股票的最佳时机含手续费</h1><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> buy = -prices[<span class="hljs-number">0</span>]-fee;<br>        <span class="hljs-type">int</span> sell = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> newbuy = <span class="hljs-built_in">max</span>(buy, sell-prices[i]-fee);<br>            <span class="hljs-type">int</span> newsell = <span class="hljs-built_in">max</span>(sell, buy+prices[i]);<br>            buy = newbuy;<br>            sell = newsell;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-买卖芯片的最佳时机数组"><a href="#2-买卖芯片的最佳时机数组" class="headerlink" title="2. 买卖芯片的最佳时机数组"></a>2. 买卖芯片的最佳时机数组</h1><p>prices 记录了某芯片近期的交易价格，其中 prices[i] 表示的 i 天该芯片的价格。你只能选择 某一天 买入芯片，并选择在 未来的某一个不同的日子 卖出该芯片。请设计一个算法计算并返回你从这笔交易中能获取的最大利润。<br>如果你不能获取任何利润，返回 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestTiming</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> smallest = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(smallest &lt; prices[i]) result = <span class="hljs-built_in">max</span>(result, prices[i]-smallest);<br>            <span class="hljs-keyword">else</span> smallest = prices[i]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-稀疏矩阵的乘法"><a href="#3-稀疏矩阵的乘法" class="headerlink" title="3. 稀疏矩阵的乘法"></a>3. 稀疏矩阵的乘法</h1><p>给定两个 稀疏矩阵 ：大小为 m x k 的稀疏矩阵 mat1 和大小为 k x n 的稀疏矩阵 mat2 ，返回 mat1 x mat2 的结果。你可以假设乘法总是可能的<br><img src="/img/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">multiply</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat2) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; newmat2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;mat2[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;mat2.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(mat2[i][j]);<br>            &#125;<br>            newmat2.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;mat1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt;tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;newmat2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;mat1[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); k++)&#123;<br>                    value += mat1[i][k]*newmat2[j][k];<br>                &#125;<br>                tmp.<span class="hljs-built_in">push_back</span>(value);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br>@版权归LeedCode所有<br><br></code></pre></td></tr></table></figure><!--版权归LeedCode所有-->]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
