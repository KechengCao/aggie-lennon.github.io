<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>5.Optimized Surface Loading and Soft Strenching</title>
    <link href="/2024/01/08/SDL/5.Optimized%20Surface%20Loading%20and%20Soft%20Strenching/"/>
    <url>/2024/01/08/SDL/5.Optimized%20Surface%20Loading%20and%20Soft%20Strenching/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考博客：<a href="https://lazyfoo.net/tutorials/SDL/05_optimized_surface_loading_and_soft_stretching/index.php">Lazy Foo’ Productions</a><br>实例代码取自Lazy Foo’<br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*This source code copyrighted by Lazy Foo&#x27; Productions 2004-2024</span><br><span class="hljs-comment">and may not be redistributed without written permission.*/</span><br><br><span class="hljs-comment">//Using SDL, standard IO, and strings</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//Screen dimension constants</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_WIDTH = <span class="hljs-number">640</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_HEIGHT = <span class="hljs-number">480</span>;<br><br><span class="hljs-comment">//Starts up SDL and creates window</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Loads media</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Frees media and shuts down SDL</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Loads individual image</span><br><span class="hljs-function">SDL_Surface* <span class="hljs-title">loadSurface</span><span class="hljs-params">( std::string path )</span></span>;<br><br><span class="hljs-comment">//The window we&#x27;ll be rendering to</span><br>SDL_Window* gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The surface contained by the window</span><br>SDL_Surface* gScreenSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Current displayed image</span><br>SDL_Surface* gStretchedSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Initialization flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Initialize SDL</span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">SDL_Init</span>( SDL_INIT_VIDEO ) &lt; <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;SDL could not initialize! SDL Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Create window</span><br>gWindow = <span class="hljs-built_in">SDL_CreateWindow</span>( <span class="hljs-string">&quot;SDL Tutorial&quot;</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );<br><span class="hljs-keyword">if</span>( gWindow == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Window could not be created! SDL Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Get window surface</span><br>gScreenSurface = <span class="hljs-built_in">SDL_GetWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Loading success flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Load stretching surface</span><br>gStretchedSurface = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;stretch.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gStretchedSurface == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load stretching image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Free loaded image</span><br><span class="hljs-built_in">SDL_FreeSurface</span>( gStretchedSurface );<br>gStretchedSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Destroy window</span><br><span class="hljs-built_in">SDL_DestroyWindow</span>( gWindow );<br>gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Quit SDL subsystems</span><br><span class="hljs-built_in">SDL_Quit</span>();<br>&#125;<br><br><span class="hljs-function">SDL_Surface* <span class="hljs-title">loadSurface</span><span class="hljs-params">( std::string path )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//The final optimized image</span><br>SDL_Surface* optimizedSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Load image at specified path</span><br>SDL_Surface* loadedSurface = <span class="hljs-built_in">SDL_LoadBMP</span>( path.<span class="hljs-built_in">c_str</span>() );<br><span class="hljs-keyword">if</span>( loadedSurface == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to load image %s! SDL Error: %s\n&quot;</span>, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">SDL_GetError</span>() );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Convert surface to screen format</span><br>optimizedSurface = <span class="hljs-built_in">SDL_ConvertSurface</span>( loadedSurface, gScreenSurface-&gt;format, <span class="hljs-number">0</span> );<br><span class="hljs-keyword">if</span>( optimizedSurface == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to optimize image %s! SDL Error: %s\n&quot;</span>, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">SDL_GetError</span>() );<br>&#125;<br><br><span class="hljs-comment">//Get rid of old loaded surface</span><br><span class="hljs-built_in">SDL_FreeSurface</span>( loadedSurface );<br>&#125;<br><br><span class="hljs-keyword">return</span> optimizedSurface;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* args[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Start up SDL and create window</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">init</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to initialize!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Load media</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">loadMedia</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load media!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Main loop flag</span><br><span class="hljs-type">bool</span> quit = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//Event handler</span><br>SDL_Event e;<br><br><span class="hljs-comment">//While application is running</span><br><span class="hljs-keyword">while</span>( !quit )<br>&#123;<br><span class="hljs-comment">//Handle events on queue</span><br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">SDL_PollEvent</span>( &amp;e ) != <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-comment">//User requests quit</span><br><span class="hljs-keyword">if</span>( e.type == SDL_QUIT )<br>&#123;<br>quit = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Apply the image stretched</span><br>SDL_Rect stretchRect;<br>stretchRect.x = <span class="hljs-number">0</span>;<br>stretchRect.y = <span class="hljs-number">0</span>;<br>stretchRect.w = SCREEN_WIDTH;<br>stretchRect.h = SCREEN_HEIGHT;<br><span class="hljs-built_in">SDL_BlitScaled</span>( gStretchedSurface, <span class="hljs-literal">NULL</span>, gScreenSurface, &amp;stretchRect );<br><br><span class="hljs-comment">//Update the surface</span><br><span class="hljs-built_in">SDL_UpdateWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Free resources and close SDL</span><br><span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在之前我们的教程中我们图片都是拿来直接用了，这对于少量图片的加载没有什么影响，但面对海量的图片时却会造成低效。因此，我们在显示图片之前会先将转化为优化后的格式，然后再通过拉伸的方式去除图片中不必要的部分。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface* <span class="hljs-title">loadSurface</span><span class="hljs-params">( std::string path )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//The final optimized image</span><br>SDL_Surface* optimizedSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Load image at specified path</span><br>SDL_Surface* loadedSurface = <span class="hljs-built_in">SDL_LoadBMP</span>( path.<span class="hljs-built_in">c_str</span>() );<br><span class="hljs-keyword">if</span>( loadedSurface == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to load image %s! SDL Error: %s\n&quot;</span>, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">SDL_GetError</span>() );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Convert surface to screen format</span><br>optimizedSurface = <span class="hljs-built_in">SDL_ConvertSurface</span>( loadedSurface, gScreenSurface-&gt;format, <span class="hljs-number">0</span> );<br><span class="hljs-keyword">if</span>( optimizedSurface == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to optimize image %s! SDL Error: %s\n&quot;</span>, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">SDL_GetError</span>() );<br>&#125;<br><br><span class="hljs-comment">//Get rid of old loaded surface</span><br><span class="hljs-built_in">SDL_FreeSurface</span>( loadedSurface );<br>&#125;<br><br><span class="hljs-keyword">return</span> optimizedSurface;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述这段代码之中，与之前的loadSurface不同，这里调用了<a href="/2024/01/05/SDL/Dictionary/SDL_ConvertSurface/" title="SDL_ConvertSurface">SDL_ConvertSurface</a>来将读取到的图片转换为屏幕所对应的格式。那什么时屏幕所对应的格式呢？关于这一部分的知识涉及到位图的一些知识，本文不做详细讨论，感兴趣的朋友可点下面链接<a href="https://zh.wikipedia.org/wiki/BMP">click to jump</a>。<br>注意到这代码中还有一个细节就是不要忘记在转换格式之后释放原来存储surface的内存。原因在于，在转换过程中原来的surface并没有被影响，一份复制被创建了出来，而我们需要的是那份新的复制。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Apply the image stretched</span><br>SDL_Rect stretchRect;<br>stretchRect.x = <span class="hljs-number">0</span>;<br>stretchRect.y = <span class="hljs-number">0</span>;<br>stretchRect.w = SCREEN_WIDTH;<br>stretchRect.h = SCREEN_HEIGHT;<br><span class="hljs-built_in">SDL_BlitScaled</span>( gStretchedSurface, <span class="hljs-literal">NULL</span>, gScreenSurface, &amp;stretchRect );<br><br><span class="hljs-comment">//Update the surface</span><br><span class="hljs-built_in">SDL_UpdateWindowSurface</span>( gWindow );<br></code></pre></td></tr></table></figure><p>上面这段代码显示的是SDL_BlitScaled()的引用，该函数的作用可以类比于裁剪功能。在裁剪之前我们当然需要决定一个落点，然后在决定之后决定裁剪矩形的长和宽。</p>]]></content>
    
    
    <categories>
      
      <category>Game Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_BlitScaled</title>
    <link href="/2024/01/08/SDL/Dictionary/SDL_BlitScaled/"/>
    <url>/2024/01/08/SDL/Dictionary/SDL_BlitScaled/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-BlitScaled"><a href="#SDL-BlitScaled" class="headerlink" title="SDL_BlitScaled"></a>SDL_BlitScaled</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_BlitScaled">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用此功能可以将缩放surface复制到目标surface。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_BlitScaled</span><span class="hljs-params">(SDL_Surface* src,<span class="hljs-type">const</span> SDL_Rect* srcrect,SDL_Surface* dst,SDL_Rect* dstrect)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>src: 要从中复制的 SDL_Surface 结构<br>srcrect: 表示要复制的矩形的 SDL_Rect 结构，或 NULL 来复制整个屏幕<br>dst: 作为 blit 目标的 SDL_Surface 结构<br>dstrect: 表示复制到的矩形的 SDL_Rect 结构</p><p>关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a><br>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Key Presses</title>
    <link href="/2024/01/07/SDL/4.Key%20Presses/"/>
    <url>/2024/01/07/SDL/4.Key%20Presses/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考博客：<a href="https://lazyfoo.net/tutorials/SDL/04_key_presses/index.php">Lazy Foo’ Productions</a><br>实例代码取自Lazy Foo’<br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*This source code copyrighted by Lazy Foo&#x27; Productions 2004-2024</span><br><span class="hljs-comment">and may not be redistributed without written permission.*/</span><br><br><span class="hljs-comment">//Using SDL, standard IO, and strings</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//Screen dimension constants</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_WIDTH = <span class="hljs-number">640</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_HEIGHT = <span class="hljs-number">480</span>;<br><br><span class="hljs-comment">//Key press surfaces constants</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KeyPressSurfaces</span><br>&#123;<br>KEY_PRESS_SURFACE_DEFAULT,<br>KEY_PRESS_SURFACE_UP,<br>KEY_PRESS_SURFACE_DOWN,<br>KEY_PRESS_SURFACE_LEFT,<br>KEY_PRESS_SURFACE_RIGHT,<br>KEY_PRESS_SURFACE_TOTAL<br>&#125;;<br><br><span class="hljs-comment">//Starts up SDL and creates window</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Loads media</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Frees media and shuts down SDL</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Loads individual image</span><br><span class="hljs-function">SDL_Surface* <span class="hljs-title">loadSurface</span><span class="hljs-params">( std::string path )</span></span>;<br><br><span class="hljs-comment">//The window we&#x27;ll be rendering to</span><br>SDL_Window* gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The surface contained by the window</span><br>SDL_Surface* gScreenSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The images that correspond to a keypress</span><br>SDL_Surface* gKeyPressSurfaces[ KEY_PRESS_SURFACE_TOTAL ];<br><br><span class="hljs-comment">//Current displayed image</span><br>SDL_Surface* gCurrentSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Initialization flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Initialize SDL</span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">SDL_Init</span>( SDL_INIT_VIDEO ) &lt; <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;SDL could not initialize! SDL Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Create window</span><br>gWindow = <span class="hljs-built_in">SDL_CreateWindow</span>( <span class="hljs-string">&quot;SDL Tutorial&quot;</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );<br><span class="hljs-keyword">if</span>( gWindow == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Window could not be created! SDL Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Get window surface</span><br>gScreenSurface = <span class="hljs-built_in">SDL_GetWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Loading success flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Load default surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;press.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load default image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load up surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;up.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load up image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load down surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;down.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load down image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load left surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;left.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load left image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load right surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;right.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load right image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Deallocate surfaces</span><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KEY_PRESS_SURFACE_TOTAL; ++i )<br>&#123;<br><span class="hljs-built_in">SDL_FreeSurface</span>( gKeyPressSurfaces[ i ] );<br>gKeyPressSurfaces[ i ] = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//Destroy window</span><br><span class="hljs-built_in">SDL_DestroyWindow</span>( gWindow );<br>gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Quit SDL subsystems</span><br><span class="hljs-built_in">SDL_Quit</span>();<br>&#125;<br><br><span class="hljs-function">SDL_Surface* <span class="hljs-title">loadSurface</span><span class="hljs-params">( std::string path )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Load image at specified path</span><br>SDL_Surface* loadedSurface = <span class="hljs-built_in">SDL_LoadBMP</span>( path.<span class="hljs-built_in">c_str</span>() );<br><span class="hljs-keyword">if</span>( loadedSurface == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to load image %s! SDL Error: %s\n&quot;</span>, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">SDL_GetError</span>() );<br>&#125;<br><br><span class="hljs-keyword">return</span> loadedSurface;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* args[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Start up SDL and create window</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">init</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to initialize!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Load media</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">loadMedia</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load media!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Main loop flag</span><br><span class="hljs-type">bool</span> quit = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//Event handler</span><br>SDL_Event e;<br><br><span class="hljs-comment">//Set default current surface</span><br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ];<br><br><span class="hljs-comment">//While application is running</span><br><span class="hljs-keyword">while</span>( !quit )<br>&#123;<br><span class="hljs-comment">//Handle events on queue</span><br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">SDL_PollEvent</span>( &amp;e ) != <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-comment">//User requests quit</span><br><span class="hljs-keyword">if</span>( e.type == SDL_QUIT )<br>&#123;<br>quit = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//User presses a key</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( e.type == SDL_KEYDOWN )<br>&#123;<br><span class="hljs-comment">//Select surfaces based on key press</span><br><span class="hljs-keyword">switch</span>( e.key.keysym.sym )<br>&#123;<br><span class="hljs-keyword">case</span> SDLK_UP:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SDLK_DOWN:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SDLK_LEFT:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SDLK_RIGHT:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Apply the current image</span><br><span class="hljs-built_in">SDL_BlitSurface</span>( gCurrentSurface, <span class="hljs-literal">NULL</span>, gScreenSurface, <span class="hljs-literal">NULL</span> );<br><br><span class="hljs-comment">//Update the surface</span><br><span class="hljs-built_in">SDL_UpdateWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Free resources and close SDL</span><br><span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>承接上文的面向事件编程，本文就一些具体的事件来举例如何实现面向事件编程。键盘现今已成为个人电脑的标配，本文就拿键盘中的上，下，左，右方向键来举例如何实现面向事件编程。本文照例采用代码块分析的方法来之一解析代码。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Key press surfaces constants</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KeyPressSurfaces</span><br>&#123;<br>KEY_PRESS_SURFACE_DEFAULT,<br>KEY_PRESS_SURFACE_UP,<br>KEY_PRESS_SURFACE_DOWN,<br>KEY_PRESS_SURFACE_LEFT,<br>KEY_PRESS_SURFACE_RIGHT,<br>KEY_PRESS_SURFACE_TOTAL<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码通过枚举类类型来初始化一系列我们之后将会使用到的关于keyboard的surface，自上而下值为从0到5。这里的作用也是将KeyPressSurfaces做为下面程序的数组下标。这里有些读者可能会有疑问为什么不直接用数字去表示下标。不妨试想一个surface数组，其中有四个surfaces分别代表键盘的up,left,right,down。如果只是用0-3去简单的表示数组下标，对于小的程序或许没有什么影响，但对于大型项目的话，可读性会非常的差，而且别人维护起来也会非常困难。所以说使用符号化的常数是需要养成的一个良好的习惯。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Loads individual image</span><br><span class="hljs-function">SDL_Surface* <span class="hljs-title">loadSurface</span><span class="hljs-params">( std::string path )</span></span>;<br><br><span class="hljs-comment">//The window we&#x27;ll be rendering to</span><br>SDL_Window* gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The surface contained by the window</span><br>SDL_Surface* gScreenSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The images that correspond to a keypress</span><br>SDL_Surface* gKeyPressSurfaces[ KEY_PRESS_SURFACE_TOTAL ];<br><br><span class="hljs-comment">//Current displayed image</span><br>SDL_Surface* gCurrentSurface = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>上述代码是声明了一些本程序中将会使用的SDL_Windows，SDL_Surface和SDL_Surface数组。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface* <span class="hljs-title">loadSurface</span><span class="hljs-params">( std::string path )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Load image at specified path</span><br>SDL_Surface* loadedSurface = <span class="hljs-built_in">SDL_LoadBMP</span>( path.<span class="hljs-built_in">c_str</span>() );<br><span class="hljs-keyword">if</span>( loadedSurface == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to load image %s! SDL Error: %s\n&quot;</span>, path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">SDL_GetError</span>() );<br>&#125;<br><br><span class="hljs-keyword">return</span> loadedSurface;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数是实例中新出现的函数，由于我们程序中使用了SDL_Surface数组，当我们需要批量将图片导入SDL_Surface中时，我们将其打包为一个函数进行统一调用。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Loading success flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Load default surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;press.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load default image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load up surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;up.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load up image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load down surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;down.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load down image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load left surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;left.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load left image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//Load right surface</span><br>gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ] = <span class="hljs-built_in">loadSurface</span>( <span class="hljs-string">&quot;right.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ] == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load right image!\n&quot;</span> );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序是对于loadMedia函数的定义，同样是由于使用了SDL_Surface数组的原因，我们需要通过我们之前定义的loadSurface方法一一为SDL_Surface指明图像所在的相对路径。笔者个人觉得这里的代码虽然保证了最大的可读性，但是太过于啰嗦，以至于前面loadSurface函数的存在显得多此一举。如果尝试使用for loop, 并不会使代码的可读性变差，只需要将单一loop的逻辑阐明清楚，并且将循环之间的过渡也很好的写出来，这将大幅减少代码的长度。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Deallocate surfaces</span><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KEY_PRESS_SURFACE_TOTAL; ++i )<br>&#123;<br><span class="hljs-built_in">SDL_FreeSurface</span>( gKeyPressSurfaces[ i ] );<br>gKeyPressSurfaces[ i ] = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//Destroy window</span><br><span class="hljs-built_in">SDL_DestroyWindow</span>( gWindow );<br>gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Quit SDL subsystems</span><br><span class="hljs-built_in">SDL_Quit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是对于close函数的定义，同样由于SDL_Surface数组的定义，这里的操作稍有不同。为了释放SDL_Surface数组的资源，这里用了for循环，就像之前说的，我们使用枚举类型来定义数组的下标，所以在for循环中，KEY_PRESS_SURFACE作为了循环的终止条件。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>( !quit )<br>&#123;<br><span class="hljs-comment">//Handle events on queue</span><br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">SDL_PollEvent</span>( &amp;e ) != <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-comment">//User requests quit</span><br><span class="hljs-keyword">if</span>( e.type == SDL_QUIT )<br>&#123;<br>quit = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//User presses a key</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( e.type == SDL_KEYDOWN )<br>&#123;<br><span class="hljs-comment">//Select surfaces based on key press</span><br><span class="hljs-keyword">switch</span>( e.key.keysym.sym )<br>&#123;<br><span class="hljs-keyword">case</span> SDLK_UP:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_UP ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SDLK_DOWN:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DOWN ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SDLK_LEFT:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_LEFT ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SDLK_RIGHT:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_RIGHT ];<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>gCurrentSurface = gKeyPressSurfaces[ KEY_PRESS_SURFACE_DEFAULT ];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段便是main程序中的代码事件轮询部分，与之间空白框架不同，这次在退出事件判断之后加了一个键盘按键判断。首先判断键盘是否按下，当确认键盘已经按下时再确认具体按下的值，通过switch case来加载对应的图片。值得注意的是，这里除了键盘的上，下，左，右按键外还存在一个default,其对应的情况便是当用户按下除上，下，左，右之外的按键。<br><br /><br><br /></p><p>那这个实例程序的分析就到这里，但笔者这里还有一件事情想在这里和大家讨论。有很多人觉得代码写得越简洁越好，但是对于合作型的大型项目而言，更重要的是可读性和代码的健壮性。首先是可读性，从上面的示例代码中可以发现有很多的注释，有些注释甚至让人觉得啰嗦，但这些都是必要的。除此之外变量的命名也十分易懂。其次是健壮性，在示例代码中有许多对于异常情况处理的语句，这其中个人认为有两个目的：1. 防止程序发生崩溃。2. 便于测试人员后期，测试和debug。</p>]]></content>
    
    
    <categories>
      
      <category>Game Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_AudioDeviceEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_AudioDeviceEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_AudioDeviceEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-AudioDeviceEvent"><a href="#SDL-AudioDeviceEvent" class="headerlink" title="SDL_AudioDeviceEvent"></a>SDL_AudioDeviceEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_AudioDeviceEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含音频设备事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_AUDIODEVICEADDED</a>, or <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_AUDIODEVICEREMOVED</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 which: SDL_AUDIODEVICEADDED 事件的音频设备索引（在下一次 <a href="/2024/01/07/SDL/Dictionary/SDL_GetNumAudioDevices/" title="SDL_GetNumAudioDevices">SDL_GetNumAudioDevices()</a> 调用之前有效）、SDL_AUDIODEVICEREMOVED 事件的 SDL_AudioDeviceID<br>Uint8 iscapture: 如果是音频输出设备则为零，如果是音频捕获设备则非零</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_ControllerButtonEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_ControllerButtonEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_ControllerButtonEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-ControllerButtonEvent"><a href="#SDL-ControllerButtonEvent" class="headerlink" title="SDL_ControllerButtonEvent"></a>SDL_ControllerButtonEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_ControllerButtonEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含游戏控制器按钮事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_CONTROLLERBUTTONDOWN</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_CONTROLLERBUTTONUP</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_JoystickID which: 操纵杆实例 ID<br>Uint8 button: 控制器按钮 (<a href="/2024/01/07/SDL/Dictionary/SDL_GameControllerButton/" title="SDL_GameControllerButton">SDL_GameControllerButton</a>)<br>Uint8 state: SDL_PRESSED 或 SDL_RELEASED</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_ControllerAxisEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_ControllerAxisEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_ControllerAxisEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-ControllerAxisEvent"><a href="#SDL-ControllerAxisEvent" class="headerlink" title="SDL_ControllerAxisEvent"></a>SDL_ControllerAxisEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_ControllerAxisEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含游戏控制器轴运动事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_CONTROLLERAXISMOTION</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_JoystickID which: 操纵杆实例 ID<br>Uint8 axis: 控制器轴 (<a href="/2024/01/07/SDL/Dictionary/SDL_GameControllerAxis/" title="SDL_GameControllerAxis">SDL_GameControllerAxis</a>)<br>Sint16 value： 轴值（范围：-32768 到 32767）</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_DollarGestureEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_DollarGestureEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_DollarGestureEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-DollarGestureEvent"><a href="#SDL-DollarGestureEvent" class="headerlink" title="SDL_DollarGestureEvent"></a>SDL_DollarGestureEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_DollarGestureEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含复杂手势事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_DOLLARGESTUR</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_DOLLARRECORD</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_TouchID touchId: 触摸设备 ID<br>SDL_GestureID gestureId: 与所执行的笔划最接近的手势的唯一 ID<br>Uint32 numFingers: 用于绘制笔划的手指数量<br>float error: 手势模板和实际执行的手势之间的差异（误差越小匹配越好）<br>float x: 标准化手势中心<br>float y: 标准化手势中心</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_ControllerDeviceEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_ControllerDeviceEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_ControllerDeviceEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-ControllerDeviceEvent"><a href="#SDL-ControllerDeviceEvent" class="headerlink" title="SDL_ControllerDeviceEvent"></a>SDL_ControllerDeviceEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_ControllerDeviceEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含控制器设备事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_CONTROLLERDEVICEADDED</a>, <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_CONTROLLERDEVICEREMOVED</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_CONTROLLERDEVICEREMAPPED</a><br>Uint32 timestamp: 事件的时间戳<br>Sint32 which: SDL_CONTROLLERDEVICEADDED 事件的操纵杆设备索引或 SDL_CONTROLLERDEVICEREMOVED 或 SDL_CONTROLLERDEVICEREMAPPED 事件的实例 ID</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_DropEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_DropEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_DropEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-DropEvent"><a href="#SDL-DropEvent" class="headerlink" title="SDL_DropEvent"></a>SDL_DropEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_DropEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含用于请求系统打开文件的事件的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_DROPFILE</a>,<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_DROPTEXT</a>,<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_DROPBEGIN</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_DROPCOMPLETE</a><br>Uint32 timestamp: 事件的时间戳<br>char* file: 文件名在 BEGIN&#x2F;COMPLETE 上为 NULL, 应使用 SDL_free() 释放<br>Uint32 windowID: 掉落的窗户（如果有</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GameControllerAxis</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_GameControllerAxis/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_GameControllerAxis/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GameControllerAxis"><a href="#SDL-GameControllerAxis" class="headerlink" title="SDL_GameControllerAxis"></a>SDL_GameControllerAxis</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GameControllerAxis">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>控制器中可用的枚举。</p><h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><p>SDL_CONTROLLER_AXIS_INVALID： -1<br>SDL_CONTROLLER_AXIS_LEFTX： 0<br>SDL_CONTROLLER_AXIS_LEFTY： 1<br>SDL_CONTROLLER_AXIS_RIGHTX： 2<br>SDL_CONTROLLER_AXIS_RIGHTY： 3<br>SDL_CONTROLLER_AXIS_TRIGGERLEFT： 4<br>SDL_CONTROLLER_AXIS_TRIGGERRIGHT： 5<br>SDL_CONTROLLER_AXIS_MAX： 6</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetNumAudioDevices</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_GetNumAudioDevices/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_GetNumAudioDevices/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetNumAudioDevices"><a href="#SDL-GetNumAudioDevices" class="headerlink" title="SDL_GetNumAudioDevices"></a>SDL_GetNumAudioDevices</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetNumAudioDevices">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取内置音频设备的数量。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_GetNumAudioDevices</span><span class="hljs-params">(<span class="hljs-type">int</span> iscapture)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>iscapture: 零表示请求播放设备，非零表示请求录音设备</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回当前驱动程序公开的可用设备的数量；如果无法确定显式设备列表，则返回 -1。返回值 -1 并不一定意味着出现错误情况。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GameControllerButton</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_GameControllerButton/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_GameControllerButton/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GameControllerButton"><a href="#SDL-GameControllerButton" class="headerlink" title="SDL_GameControllerButton"></a>SDL_GameControllerButton</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GameControllerButton">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>控制器中可用的枚举。</p><h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><p>SDL_CONTROLLER_BUTTON_INVALID: -1<br>SDL_CONTROLLER_BUTTON_A: 0<br>SDL_CONTROLLER_BUTTON_B: 1<br>SDL_CONTROLLER_BUTTON_X: 2<br>SDL_CONTROLLER_BUTTON_Y: 3<br>SDL_CONTROLLER_BUTTON_BACK: 4<br>SDL_CONTROLLER_BUTTON_GUIDE: 5<br>SDL_CONTROLLER_BUTTON_START: 6<br>SDL_CONTROLLER_BUTTON_LEFTSTICK:7<br>SDL_CONTROLLER_BUTTON_RIGHTSTICK: 8<br>SDL_CONTROLLER_BUTTON_LEFTSHOULDER: 9<br>SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: 10<br>SDL_CONTROLLER_BUTTON_DPAD_UP: 11<br>SDL_CONTROLLER_BUTTON_DPAD_DOWN: 12<br>SDL_CONTROLLER_BUTTON_DPAD_LEFT: 13<br>SDL_CONTROLLER_BUTTON_DPAD_RIGHT: 14<br>SDL_CONTROLLER_BUTTON_MISC1: 15<br>SDL_CONTROLLER_BUTTON_PADDLE1: 16<br>SDL_CONTROLLER_BUTTON_PADDLE2: 17<br>SDL_CONTROLLER_BUTTON_PADDLE3: 18<br>SDL_CONTROLLER_BUTTON_PADDLE4: 19<br>SDL_CONTROLLER_BUTTON_TOUCHPAD: 20<br>SDL_CONTROLLER_BUTTON_MAX: 21</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_JoyAxisEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_JoyAxisEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_JoyAxisEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-JoyAxisEvent"><a href="#SDL-JoyAxisEvent" class="headerlink" title="SDL_JoyAxisEvent"></a>SDL_JoyAxisEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_JoyAxisEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含操纵杆轴运动事件信息的结构</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_JOYAXISMOTION</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_JoystickID which：报告事件的操纵杆实例ID<br>Uint8 axis：发生变化的轴的索引<br>Sint16 value：轴的当前位置（范围：-32768 到 32767）</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_JoyButtonEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_JoyButtonEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_JoyButtonEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-JoyButtonEvent"><a href="#SDL-JoyButtonEvent" class="headerlink" title="SDL_JoyButtonEvent"></a>SDL_JoyButtonEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_JoyButtonEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含操纵杆按钮事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: 事件类型<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_JOYBUTTONDOWN</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_JOYBUTTONUP</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_JoystickID which：报告事件的操纵杆的实例ID<br>Uint8 button:发生变化的按钮的索引<br>Uint8 state: 按钮的状态； SDL_PRESSED 或 SDL_RELEASED</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_JoyBallEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_JoyBallEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_JoyBallEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-JoyBallEvent"><a href="#SDL-JoyBallEvent" class="headerlink" title="SDL_JoyBallEvent"></a>SDL_JoyBallEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_JoyBallEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含操纵杆轨迹球运动事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_JOYBALLMOTION</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_JoystickID which：报告事件的操纵杆实例ID<br>Uint8 ball：发生变化的轨迹球的索引<br>Sint16 xrel:X方向的相对运动<br>Sint16 yrel:Y方向的相对运动</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_JoyDeviceEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_JoyDeviceEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_JoyDeviceEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-JoyDeviceEvent"><a href="#SDL-JoyDeviceEvent" class="headerlink" title="SDL_JoyDeviceEvent"></a>SDL_JoyDeviceEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_JoyDeviceEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含操纵杆设备事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: 事件类型<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_JOYDEVICEADDED</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_JOYDEVICEREMOVED</a><br>Uint32 timestamp: 事件的时间戳<br>Sint32 which:SDL_JOYDEVICEADDED 事件的操纵杆设备索引或 SDL_JOYDEVICEREMOVED 事件的实例 ID</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_KeyboardEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_KeyboardEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_KeyboardEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-KeyboardEvent"><a href="#SDL-KeyboardEvent" class="headerlink" title="SDL_KeyboardEvent"></a>SDL_KeyboardEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_KeyboardEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含键盘按钮事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type：事件类型；<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_KEYDOWN</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_KEYUP</a><br>Uint32 timestamp：事件的时间戳<br>Uint32 windowID：具有键盘焦点的窗口（如果有）<br>Uint8 state：the state of the key; SDL_PRESSED or SDL_RELEASED<br>Uint8 repeat：如果这是按键重复则非零<br>SDL_Keysym keysym：表示按下或释放的键的<a href="/2024/01/07/SDL/Dictionary/SDL_Keysym/" title="SDL_Keysym">SDL_Keysym</a> </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_JoyHatEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_JoyHatEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_JoyHatEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-JoyHatEvent"><a href="#SDL-JoyHatEvent" class="headerlink" title="SDL_JoyHatEvent"></a>SDL_JoyHatEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_JoyHatEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含操纵杆帽位置变化事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_JOYHATMOTION</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_JoystickID which：报告事件的操纵杆的实例ID<br>Uint8 hat：改变的帽子索引<br>Uint8 value: 帽子的新位置</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Keycode</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_Keycode/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_Keycode/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Keycode"><a href="#SDL-Keycode" class="headerlink" title="SDL_Keycode"></a>SDL_Keycode</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Keycode">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>SDL 虚拟键表示。</p><h3 id="key-value"><a href="#key-value" class="headerlink" title="key&amp;&amp;value"></a>key&amp;&amp;value</h3><p><img src="/img/SDL/SDL_Scancode&SDL_Keycode.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode1.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode2.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode3.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode4.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode5.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode6.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode7.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Keymod</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_Keymod/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_Keymod/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Keymod"><a href="#SDL-Keymod" class="headerlink" title="SDL_Keymod"></a>SDL_Keymod</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Keymod">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>键修饰符掩码的枚举。</p><h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><p>KMOD_NONE: 0（无修饰符适用）<br>KMOD_LSHIFT:左 Shift 键已按下<br>KMOD_RSHIFT:右 Shift 键已按下<br>KMOD_LCTRL:左 Ctrl (Control) 键已按下<br>KMOD_RCTRL:按下右侧 Ctrl (Control) 键<br>KMOD_LALT:左 Alt 键按下<br>KMOD_RALT:右 Alt 键按下<br>KMOD_LGUI:左侧 GUI 键（通常是 Windows 键）按下<br>KMOD_RGUI:右 GUI 键（通常是 Windows 键）按下了<br>KMOD_NUM:Num Lock 键（可能位于扩展键盘上）按下<br>KMOD_CAPS:Caps Lock 键已按下<br>KMOD_MODE:!AltGr 键已按下<br>KMOD_SCROLL:Scroll Lock 键按下（自 SDL 2.0.18 起可用）<br>KMOD_CTRL:(KMOD_LCTRL|KMOD_RCTRL)<br>KMOD_SHIFT:(KMOD_LSHIFT|KMOD_RSHIFT)<br>KMOD_ALT:(KMOD_LALT|KMOD_RALT)<br>KMOD_GUI:(KMOD_LGUI|KMOD_RGUI)</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_MouseButtonEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_MouseButtonEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_MouseButtonEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-MouseButtonEvent"><a href="#SDL-MouseButtonEvent" class="headerlink" title="SDL_MouseButtonEvent"></a>SDL_MouseButtonEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_MouseButtonEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含鼠标按钮事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: 事件类型<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_MOUSEBUTTONDOWN</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_MOUSEBUTTONUP</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 windowID:具有鼠标焦点的窗口（如果有）<br>Uint32 which:鼠标实例 ID，或 SDL_TOUCH_MOUSEID；<br>Uint8 button:改变的按钮；<br>Uint8 state:按钮的状态； SDL_PRESSED 或 SDL_RELEASED<br>Uint8 clicks:1 表示单击，2 表示双击，等等（&gt;&#x3D; SDL 2.0.2）<br>Sint32 x:X坐标，相对于窗口<br>Sint32 y:Y 坐标，相对于窗口</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Keysym</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_Keysym/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_Keysym/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Keysym"><a href="#SDL-Keysym" class="headerlink" title="SDL_Keysym"></a>SDL_Keysym</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Keysym">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含关键事件中使用的关键信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>SDL_Scancode scancode:SDL 物理键码。关于SDL_Scancode的描述可参考<a href="/2024/01/07/SDL/Dictionary/SDL_Scancode/" title="SDL_Scancode">SDL_Scancode</a><br>SDL_Keycode sym:SDL 虚拟键码。关于SDL_Keycode的描述可参考<a href="/2024/01/07/SDL/Dictionary/SDL_Keycode/" title="SDL_Keycode">SDL_Keycode</a><br>Uint16 mod:当前键修饰符。关于SDL_Keymod的描述可参考<a href="/2024/01/07/SDL/Dictionary/SDL_Keymod/" title="SDL_Keymod">SDL_Keymod</a><br>Uint32 unused</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_MouseWheelEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_MouseWheelEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_MouseWheelEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-MouseWheelEvent"><a href="#SDL-MouseWheelEvent" class="headerlink" title="SDL_MouseWheelEvent"></a>SDL_MouseWheelEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_MouseWheelEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含鼠标滚轮事件信息的结构体。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_MOUSEWHEEL</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 windowID:具有鼠标焦点的窗口（如果有）<br>Uint32 which:鼠标实例 ID，或 SDL_TOUCH_MOUSEID；<br>Sint32 x:水平滚动的量，向右为正，向左为负<br>Sint32 y:垂直滚动的量，远离用户为正，朝向用户为负<br>Uint32 direction:SDL_MOUSEWHEEL_NORMAL or SDL_MOUSEWHEEL_FLIPPED;<br>float preciseX:水平滚动量，向右为正，向左为负，浮动精度<br>float preciseY:垂直滚动的量，远离用户为正，朝向用户为负，具有浮动精度</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_MultiGestureEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_MultiGestureEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_MultiGestureEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-MultiGestureEvent"><a href="#SDL-MultiGestureEvent" class="headerlink" title="SDL_MultiGestureEvent"></a>SDL_MultiGestureEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_MultiGestureEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含多个手指手势事件信息的结构体。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_MULTIGESTURE</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_TouchID touchId:触摸设备 ID<br>float dTheta:手指在此运动期间旋转的量（以弧度为单位）<br>float dDist:在此动作期间手指捏的量<br>float x:标准化手势中心<br>float y:标准化手势中心<br>Uint16 numFingers:手势中使用的手指数量</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_QuitEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_QuitEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_QuitEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-QuitEvent"><a href="#SDL-QuitEvent" class="headerlink" title="SDL_QuitEvent"></a>SDL_QuitEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_QuitEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含“退出请求”事件的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_QUIT</a><br>Uint32 timestamp: 事件的时间戳</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_MouseMotionEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_MouseMotionEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_MouseMotionEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-MouseMotionEvent"><a href="#SDL-MouseMotionEvent" class="headerlink" title="SDL_MouseMotionEvent"></a>SDL_MouseMotionEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_MouseMotionEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含鼠标移动事件信息的结构体。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: 事件类型<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_MOUSEMOTION</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 windowID:具有鼠标焦点的窗口（如果有）<br>Uint32 which:鼠标实例 ID，或 SDL_TOUCH_MOUSEID；<br>Uint32 state:按钮的状态；<br>Sint32 x:X坐标，相对于窗口<br>Sint32 y:Y 坐标，相对于窗口<br>Sint32 xrel:X方向的相对运动<br>Sint32 yrel:Y方向相对运动</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_RegisterEvents</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_RegisterEvents/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_RegisterEvents/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-RegisterEvents"><a href="#SDL-RegisterEvents" class="headerlink" title="SDL_RegisterEvents"></a>SDL_RegisterEvents</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_RegisterEvents">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>分配一组用户定义的事件，并返回该组事件的开始事件编号。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Uint32 <span class="hljs-title">SDL_RegisterEvents</span><span class="hljs-params">(<span class="hljs-type">int</span> numevents)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>numevents：要分配的事件数</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回开始事件编号，如果没有足够的用户定义事件，则返回 (Uint32)-1。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_TextEditingEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_TextEditingEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_TextEditingEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-TextEditingEvent"><a href="#SDL-TextEditingEvent" class="headerlink" title="SDL_TextEditingEvent"></a>SDL_TextEditingEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_TextEditingEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含键盘文本编辑事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_TEXTEDITING</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 windowID: 具有键盘焦点的窗口（如果有）<br>char[32] text: UTF-8 编码中以 null 结尾的编辑文本<br>Sint32 start: 开始编辑的位置<br>Sint32 length:从起点开始编辑的字符数</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_TextInputEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_TextInputEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_TextInputEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-TextInputEvent"><a href="#SDL-TextInputEvent" class="headerlink" title="SDL_TextInputEvent"></a>SDL_TextInputEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_TextInputEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含键盘文本输入事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_TEXTINPUT</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 windowID: 具有键盘焦点的窗口（如果有）<br>char[32] text: UTF-8 编码中以 null 结尾的编辑文本</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Scancode</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_Scancode/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_Scancode/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Scancode"><a href="#SDL-Scancode" class="headerlink" title="SDL_Scancode"></a>SDL_Scancode</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Scancode">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>SDL 键盘扫描码表示的枚举。</p><h3 id="key-value"><a href="#key-value" class="headerlink" title="key&amp;&amp;value"></a>key&amp;&amp;value</h3><p><img src="/img/SDL/SDL_Scancode&SDL_Keycode.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode1.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode2.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode3.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode4.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode5.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode6.png"><br><img src="/img/SDL/SDL_Scancode&SDL_Keycode7.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SysWMEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_SysWMEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_SysWMEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SysWMEvent"><a href="#SDL-SysWMEvent" class="headerlink" title="SDL_SysWMEvent"></a>SDL_SysWMEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SysWMEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含视频驱动程序相关系统事件的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_SYSWMEVENT</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_SysWMmsg* msg: 驱动程序相关数据，在 SDL_syswm.h 中定义</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_TouchFingerEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_TouchFingerEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_TouchFingerEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-TouchFingerEvent"><a href="#SDL-TouchFingerEvent" class="headerlink" title="SDL_TouchFingerEvent"></a>SDL_TouchFingerEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_TouchFingerEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含手指触摸事件信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_FINGERMOTION</a>,<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_FINGERDOWN</a>or<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_FINGERUP</a><br>Uint32 timestamp: 事件的时间戳<br>SDL_TouchID touchId: 触摸设备 ID<br>SDL_FingerID fingerId: 手指 ID<br>float x:触摸事件的 x 轴位置，标准化 (0…1)<br>float y:触摸事件的 y 轴位置，标准化 (0…1)<br>float dx:在 x 轴上移动的距离，标准化 (-1…1)<br>float dy:y 轴移动的距离，标准化 (-1…1)<br>float pressure:施加的压力量，标准化 (0…1)<br>Uint32 windowID:手指下方的窗口（如果有）</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_UserEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_UserEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_UserEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-UserEvent"><a href="#SDL-UserEvent" class="headerlink" title="SDL_UserEvent"></a>SDL_UserEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_UserEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含应用程序定义的事件类型的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: value obtained from<a href="/2024/01/07/SDL/Dictionary/SDL_RegisterEvents/" title="SDL_RegisterEvents">SDL_RegisterEvents</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 windowID: 关联的窗口（如果有）<br>Sint32 code:用户定义的事件代码<br>void* data1:用户定义的数据指针<br>void* data2:用户定义的数据指针</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_WindowEventID</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_WindowEventID/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_WindowEventID/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-WindowEventID"><a href="#SDL-WindowEventID" class="headerlink" title="SDL_WindowEventID"></a>SDL_WindowEventID</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_WindowEventID">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>窗口事件的枚举。</p><h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><p>SDL_WINDOWEVENT_NONE：（没用过）<br>SDL_WINDOWEVENT_SHOWN：窗口已显示<br>SDL_WINDOWEVENT_HIDDEN：窗口已被隐藏<br>SDL_WINDOWEVENT_EXPOSED：窗口已暴露，应重新绘制<br>SDL_WINDOWEVENT_MOVED：窗口已移动到data1、data2<br>SDL_WINDOWEVENT_RESIZED：窗口大小已调整为 data1xdata2；此事件始终先于 SDL_WINDOWEVENT_SIZE_CHANGED<br>SDL_WINDOWEVENT_SIZE_CHANGED：窗口大小已更改，无论是由于 API 调用还是通过系统或用户更改了窗口大小；如果大小被外部事件（即用户或窗口管理器）更改，则此事件后跟随 SDL_WINDOWEVENT_RESIZED<br>SDL_WINDOWEVENT_MINIMIZED：窗口已最小化<br>SDL_WINDOWEVENT_MAXIMIZED：窗口已最大化<br>SDL_WINDOWEVENT_RESTORED：窗口已恢复到正常大小和位置<br>SDL_WINDOWEVENT_ENTER：窗口已获得鼠标焦点<br>SDL_WINDOWEVENT_LEAVE：窗口失去了鼠标焦点<br>SDL_WINDOWEVENT_FOCUS_GAINED：窗口已获得键盘焦点<br>SDL_WINDOWEVENT_FOCUS_LOST：窗口失去键盘焦点<br>SDL_WINDOWEVENT_CLOSE：窗口管理器请求关闭窗口<br>SDL_WINDOWEVENT_TAKE_FOCUS：窗口正在被提供焦点（应该对其自身或子窗口执行 SDL_SetWindowInputFocus()，或者忽略）(&gt;&#x3D; SDL 2.0.5)<br>SDL_WINDOWEVENT_HIT_TEST：（应该对其自身或子窗口执行 SDL_SetWindowInputFocus()，或者忽略）(&gt;&#x3D; SDL 2.0.5)<br>SDL_WINDOWEVENT_ICCPROF_CHANGED：（应该对其自身或子窗口执行 SDL_SetWindowInputFocus()，或者忽略）(&gt;&#x3D; SDL 2.0.5)<br>SDL_WINDOWEVENT_DISPLAY_CHANGED：窗口已移动到显示 data1。 (&gt;&#x3D; SDL 2.0.18)</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_WindowEvent</title>
    <link href="/2024/01/07/SDL/Dictionary/SDL_WindowEvent/"/>
    <url>/2024/01/07/SDL/Dictionary/SDL_WindowEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-WindowEvent"><a href="#SDL-WindowEvent" class="headerlink" title="SDL_WindowEvent"></a>SDL_WindowEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_WindowEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含窗口状态更改事件数据的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><p>Uint32 type: <a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_WINDOWEVENT</a><br>Uint32 timestamp: 事件的时间戳<br>Uint32 windowID: 关联的窗口（如果有）<br>Uint8 event:<a href="/2024/01/07/SDL/Dictionary/SDL_WindowEventID/" title="SDL_WindowEventID">SDL_WindowEventID</a><br>Sint32 data1:事件相关数据<br>Sint32 data2:事件相关数据</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.Event Driven Programming</title>
    <link href="/2024/01/06/SDL/3.Event%20Driven%20Programming/"/>
    <url>/2024/01/06/SDL/3.Event%20Driven%20Programming/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考博客：<a href="https://lazyfoo.net/tutorials/SDL/03_event_driven_programming/index.php">Lazy Foo’ Productions</a><br>实例代码取自Lazy Foo’<br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*This source code copyrighted by Lazy Foo&#x27; Productions 2004-2024</span><br><span class="hljs-comment">and may not be redistributed without written permission.*/</span><br><br><span class="hljs-comment">//Using SDL and standard IO</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//Screen dimension constants</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_WIDTH = <span class="hljs-number">640</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_HEIGHT = <span class="hljs-number">480</span>;<br><br><span class="hljs-comment">//Starts up SDL and creates window</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Loads media</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Frees media and shuts down SDL</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//The window we&#x27;ll be rendering to</span><br>SDL_Window* gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The surface contained by the window</span><br>SDL_Surface* gScreenSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The image we will load and show on the screen</span><br>SDL_Surface* gXOut = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Initialization flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Initialize SDL</span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">SDL_Init</span>( SDL_INIT_VIDEO ) &lt; <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;SDL could not initialize! SDL_Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Create window</span><br>gWindow = <span class="hljs-built_in">SDL_CreateWindow</span>( <span class="hljs-string">&quot;SDL Tutorial&quot;</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );<br><span class="hljs-keyword">if</span>( gWindow == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Window could not be created! SDL_Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Get window surface</span><br>gScreenSurface = <span class="hljs-built_in">SDL_GetWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Loading success flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Load splash image</span><br>gXOut = <span class="hljs-built_in">SDL_LoadBMP</span>( <span class="hljs-string">&quot;x.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gXOut == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to load image %s! SDL Error: %s\n&quot;</span>, <span class="hljs-string">&quot;x.bmp&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Deallocate surface</span><br><span class="hljs-built_in">SDL_FreeSurface</span>( gXOut );<br>gXOut = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Destroy window</span><br><span class="hljs-built_in">SDL_DestroyWindow</span>( gWindow );<br>gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Quit SDL subsystems</span><br><span class="hljs-built_in">SDL_Quit</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* args[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Start up SDL and create window</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">init</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to initialize!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Load media</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">loadMedia</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load media!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Main loop flag</span><br><span class="hljs-type">bool</span> quit = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//Event handler</span><br>SDL_Event e;<br><br><span class="hljs-comment">//While application is running</span><br><span class="hljs-keyword">while</span>( !quit )<br>&#123;<br><span class="hljs-comment">//Handle events on queue</span><br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">SDL_PollEvent</span>( &amp;e ) != <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-comment">//User requests quit</span><br><span class="hljs-keyword">if</span>( e.type == SDL_QUIT )<br>&#123;<br>quit = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Apply the image</span><br><span class="hljs-built_in">SDL_BlitSurface</span>( gXOut, <span class="hljs-literal">NULL</span>, gScreenSurface, <span class="hljs-literal">NULL</span> );<br><br><span class="hljs-comment">//Update the surface</span><br><span class="hljs-built_in">SDL_UpdateWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Free resources and close SDL</span><br><span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之前学习了如何将图片通过SDL库显示出来，但游戏不单单只有显示图片这么简单，今天就更近一步。在游戏中会存在许多事件，这些事件可以来自玩家也可以来自游戏本身，这一切的实现都基于SDL中的事件处理系统。通过查看<a href="/2024/01/05/SDL/Dictionary/SDL_Event/" title="SDL_Event">SDL_Event</a>结构可以查看具体的事件类，这里我们直接看代码。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>( !quit )<br>&#123;<br><span class="hljs-comment">//Handle events on queue</span><br><span class="hljs-keyword">while</span>( <span class="hljs-built_in">SDL_PollEvent</span>( &amp;e ) != <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-comment">//User requests quit</span><br><span class="hljs-keyword">if</span>( e.type == SDL_QUIT )<br>&#123;<br>quit = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码框架可以作为一种模板使用，但就像我所说的这里只是一个框架，框架里面并没有实质性的内容，当然作为学习代码还是不错的选择。我们可以将栈当作游戏事件的储存容器。 每当有新的事件发生时便会把事件压入栈中。Loop while(!quit)会以循环轮询的方式去自顶向下读取栈中 的内容，<a href="/2024/01/05/SDL/Dictionary/SDL_PollEvent/" title="SDL_PollEvent">SDL_PollEvent()</a>自顶向下的方向读取栈中的事件。当读取到SDL__QUIT事件时会退出循环轮询。<br><br /><br><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Apply the image</span><br><span class="hljs-built_in">SDL_BlitSurface</span>( gXOut, <span class="hljs-literal">NULL</span>, gScreenSurface, <span class="hljs-literal">NULL</span> );<br><br><span class="hljs-comment">//Update the surface</span><br><span class="hljs-built_in">SDL_UpdateWindowSurface</span>( gWindow );<br></code></pre></td></tr></table></figure><p>这段代码中显示图片不是目的，图片的显示代表着事件轮询的结束，在实际情况中我们可以根据我们的需求将图片显示改成其它功能。</p>]]></content>
    
    
    <categories>
      
      <category>Game Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.Getting an image on the screen</title>
    <link href="/2024/01/05/SDL/2.Getting%20an%20image%20on%20the%20screen/"/>
    <url>/2024/01/05/SDL/2.Getting%20an%20image%20on%20the%20screen/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考链接：<a href="https://lazyfoo.net/tutorials/SDL/02_getting_an_image_on_the_screen/index.php">Click to jump</a><br>参考博客：Lazy Foo’ Productions</p><p>对于下面示例代码将采用分块学习的方式去学习SDL库函数的使用<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*This source code copyrighted by Lazy Foo&#x27; Productions 2004-2024</span><br><span class="hljs-comment">and may not be redistributed without written permission.*/</span><br><br><span class="hljs-comment">//Using SDL and standard IO</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//Screen dimension constants</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_WIDTH = <span class="hljs-number">640</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_HEIGHT = <span class="hljs-number">480</span>;<br><br><span class="hljs-comment">//Starts up SDL and creates window</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Loads media</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Frees media and shuts down SDL</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//The window we&#x27;ll be rendering to</span><br>SDL_Window* gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The surface contained by the window</span><br>SDL_Surface* gScreenSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The image we will load and show on the screen</span><br>SDL_Surface* gHelloWorld = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Initialization flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Initialize SDL</span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">SDL_Init</span>( SDL_INIT_VIDEO ) &lt; <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;SDL could not initialize! SDL_Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Create window</span><br>gWindow = <span class="hljs-built_in">SDL_CreateWindow</span>( <span class="hljs-string">&quot;SDL Tutorial&quot;</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );<br><span class="hljs-keyword">if</span>( gWindow == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Window could not be created! SDL_Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Get window surface</span><br>gScreenSurface = <span class="hljs-built_in">SDL_GetWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Loading success flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Load splash image</span><br>gHelloWorld = <span class="hljs-built_in">SDL_LoadBMP</span>( <span class="hljs-string">&quot;hello_world.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gHelloWorld == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to load image %s! SDL Error: %s\n&quot;</span>, <span class="hljs-string">&quot;hello_world.bmp&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Deallocate surface</span><br><span class="hljs-built_in">SDL_FreeSurface</span>( gHelloWorld );<br>gHelloWorld = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Destroy window</span><br><span class="hljs-built_in">SDL_DestroyWindow</span>( gWindow );<br>gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Quit SDL subsystems</span><br><span class="hljs-built_in">SDL_Quit</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* args[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Start up SDL and create window</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">init</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to initialize!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Load media</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">loadMedia</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load media!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Apply the image</span><br><span class="hljs-built_in">SDL_BlitSurface</span>( gHelloWorld, <span class="hljs-literal">NULL</span>, gScreenSurface, <span class="hljs-literal">NULL</span> );<br><br><span class="hljs-comment">//Update the surface</span><br><span class="hljs-built_in">SDL_UpdateWindowSurface</span>( gWindow );<br><br>            <span class="hljs-comment">//Hack to get window to stay up</span><br>            SDL_Event e; <br>            <span class="hljs-type">bool</span> quit = <span class="hljs-literal">false</span>; <br>            <span class="hljs-keyword">while</span>( quit == <span class="hljs-literal">false</span> )&#123; <br>                    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">SDL_PollEvent</span>( &amp;e ) )&#123;<br>                         <span class="hljs-keyword">if</span>( e.type == SDL_QUIT ) quit = <span class="hljs-literal">true</span>;<br>                    &#125; <br>            &#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//Free resources and close SDL</span><br><span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便撰写本文, 这里把所有东西都塞在main函数之中，但在实际项目中，必须尽可能地将代码分成不同地模块：一方面是为了养成良好地写代码习惯，另一方面是便于后期地测试和维护。为了方便读者的理解，本文采用代码分块分析的方式。我们首先从下面代码开始分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Using SDL and standard IO</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;SDL.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//Screen dimension constants</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_WIDTH = <span class="hljs-number">640</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_HEIGHT = <span class="hljs-number">480</span>;<br><br><span class="hljs-comment">//Starts up SDL and creates window</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Loads media</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//Frees media and shuts down SDL</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>上面代码干了三件事：1. 包含本文件所需地头文件。2. 声明全局变量，这些变量一般是下面程序中反复使用地常量（注意在平时写项目代码的时候应尽可能避免使用全局变量）3. 声明函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//The window we&#x27;ll be rendering to</span><br>SDL_Window* gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The surface contained by the window</span><br>SDL_Surface* gScreenSurface = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//The image we will load and show on the screen</span><br>SDL_Surface* gHelloWorld = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>这代码同样是声明变量，但与上面讨论的不同。在上面的代码中bool属于STL库，而SDL_Window和SDL_Surface属于SDL库。下面笔者介绍SDL_Window，SDL_Surface以及对应的函数用法</p><h2 id="SDL-Window"><a href="#SDL-Window" class="headerlink" title="SDL_Window"></a>SDL_Window</h2><p>SDL_Window为一种结构体，描述的是窗体对象，呈现在设备上的是一个窗体，是所有图像的载体。有下列函数会用到SDL_Windows结构体。<br>相关函数及其用法：</p><a href="/2024/01/03/SDL/Dictionary/SDL_CreateWindow/" title="SDL_CreateWindow">SDL_CreateWindow()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_CreateWindowFrom/" title="SDL_CreateWindowFrom">SDL_CreateWindowFrom()</a><br />  <a href="/2024/01/03/SDL/Dictionary/SDL_DestroyWindow/" title="SDL_DestroyWindow">SDL_DestroyWindow()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_GetWindowData/" title="SDL_GetWindowData">SDL_GetWindowData()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_GetWindowFlags/" title="SDL_GetWindowFlags">SDL_GetWindowFlags()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_GetWindowGrab/" title="SDL_GetWindowGrab">SDL_GetWindowGrab()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_GetWindowPosition/" title="SDL_GetWindowPosition">SDL_GetWindowPosition()</a><br />  <a href="/2024/01/03/SDL/Dictionary/SDL_GetWindowSize/" title="SDL_GetWindowSize">SDL_GetWindowSize()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_GetWindowTitle/" title="SDL_GetWindowTitle">SDL_GetWindowTitle()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_HideWindow/" title="SDL_HideWindow">SDL_HideWindow()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_MaximizeWindow/" title="SDL_MaximizeWindow">SDL_MaximizeWindow()</a><br />  <a href="/2024/01/03/SDL/Dictionary/SDL_MinimizeWindo/" title="SDL_MinimizeWindow">SDL_MinimizeWindow()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_RaiseWindow/" title="SDL_RaiseWindow">SDL_RaiseWindow()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_RestoreWindow/" title="SDL_RestoreWindow">SDL_RestoreWindow()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowData/" title="SDL_SetWindowData">SDL_SetWindowData()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowFullscreen/" title="SDL_SetWindowFullscreen">SDL_SetWindowFullscreen()</a><br />  <a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowGrab/" title="SDL_SetWindowGrab">SDL_SetWindowGrab()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowIcon/" title="SDL_SetWindowIcon">SDL_SetWindowIcon()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowPosition/" title="SDL_SetWindowPosition">SDL_SetWindowPosition()</a><br />  <a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowSize/" title="SDL_SetWindowSize">SDL_SetWindowSize()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowBordered/" title="SDL_SetWindowBordered">SDL_SetWindowBordered()</a><br />  <a href="/2024/01/03/SDL/Dictionary/SDL_SetWindowTitle/" title="SDL_SetWindowTitle">SDL_SetWindowTitle()</a><br /><a href="/2024/01/03/SDL/Dictionary/SDL_ShowWindow/" title="SDL_ShowWindow">SDL_ShowWindow()</a><br /><h2 id="SDL-Surface"><a href="#SDL-Surface" class="headerlink" title="SDL_Surface"></a>SDL_Surface</h2><p>SDL_Surface是一个用于Surface间相互拷贝buffer数据的像素集合.其中Blitting 是指位边界块传输或块信息传输。假设您有一个 Surface（您的屏幕）。 您想在屏幕上画一个圆圈。 所以你要做的是，绘制圆并将缓冲区的圆块传输到屏幕缓冲区，这个过程称为“Blitting”。<br>相关函数及其用法：</p><a href="/2024/01/05/SDL/Dictionary/SDL_BlitSurface/" title="SDL_BlitSurface">SDL_BlitSurface()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_ConvertSurface/" title="SDL_ConvertSurface">SDL_ConvertSurface()</a><br />  <a href="/2024/01/05/SDL/Dictionary/SDL_CreateRGBSurface/" title="SDL_CreateRGBSurface">SDL_CreateRGBSurface()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_CreateRGBSurfaceFrom/" title="SDL_CreateRGBSurfaceFrom">SDL_CreateRGBSurfaceFrom()</a><br />  <a href="/2024/01/05/SDL/Dictionary/SDL_FillRect/" title="SDL_FillRect">SDL_FillRect()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_FillRects/" title="SDL_FillRects">SDL_FillRects()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_FreeSurface/" title="SDL_FreeSurface">SDL_FreeSurface()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_GetClipRect/" title="SDL_GetClipRect">SDL_GetClipRect()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_Color/" title="SDL_Color">SDL_Color()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_GetSurfaceAlphaMod/" title="SDL_GetSurfaceAlphaMod">SDL_GetSurfaceAlphaMod()</a><br />  <a href="/2024/01/05/SDL/Dictionary/SDL_GetSurfaceBlendMode/" title="SDL_GetSurfaceBlendMode">SDL_GetSurfaceBlendMode()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_GetSurfaceColorMod/" title="SDL_GetSurfaceColorMod">SDL_GetSurfaceColorMod()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_LoadBMP_RW/" title="SDL_LoadBMP_RW">SDL_LoadBMP_RW()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_LockSurface/" title="SDL_LockSurface">SDL_LockSurface()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_LowerBlit/" title="SDL_LowerBlit">SDL_LowerBlit()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_MUSTLOCK/" title="SDL_MUSTLOCK">SDL_MUSTLOCK()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SaveBMP_RW/" title="SDL_SaveBMP_RW">SDL_SaveBMP_RW()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SetClipRect/" title="SDL_SetClipRect">SDL_SetClipRect()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SetColorKey/" title="SDL_SetColorKey">SDL_SetColorKey()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceAlphaMod/" title="SDL_SetSurfaceAlphaMod">SDL_SetSurfaceAlphaMod()</a><br />  <a href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceBlendMode/" title="SDL_SetSurfaceBlendMode">SDL_SetSurfaceBlendMode()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceColorMod/" title="SDL_SetSurfaceColorMod">SDL_SetSurfaceColorMod()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SetSurfacePalette/" title="SDL_SetSurfacePalette">SDL_SetSurfacePalette()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceRLE/" title="SDL_SetSurfaceRLE">SDL_SetSurfaceRLE()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_SoftStretch/" title="SDL_SoftStretch">SDL_SoftStretch()</a><br /><a href="/2024/01/05/SDL/Dictionary/SDL_UnlockSurface/" title="SDL_UnlockSurface">SDL_UnlockSurface()</a><br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Initialization flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Initialize SDL</span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">SDL_Init</span>( SDL_INIT_VIDEO ) &lt; <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;SDL could not initialize! SDL_Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Create window</span><br>gWindow = <span class="hljs-built_in">SDL_CreateWindow</span>( <span class="hljs-string">&quot;SDL Tutorial&quot;</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );<br><span class="hljs-keyword">if</span>( gWindow == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Window could not be created! SDL_Error: %s\n&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Get window surface</span><br>gScreenSurface = <span class="hljs-built_in">SDL_GetWindowSurface</span>( gWindow );<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是对于init()函数的定义，<a href="/2024/01/05/SDL/Dictionary/SDL_Init/" title="SDL_Init">SDL_Init( SDL_INIT_VIDEO )&lt;0</a>首先是检查视频子系统初始化是否成功。失败将打印错误，成功将创建窗口gWindow。如过窗口创建失败将打印错误，如果窗口创建成功<a href="/2024/01/05/SDL/Dictionary/SDL_GetWindowSurface/" title="SDL_GetWindowSurface">SDL_GetWindowSurface()</a>函数将返回窗口关联的surface gScreenSurface。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadMedia</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Loading success flag</span><br><span class="hljs-type">bool</span> success = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//Load splash image</span><br>gHelloWorld = <span class="hljs-built_in">SDL_LoadBMP</span>( <span class="hljs-string">&quot;hello_world.bmp&quot;</span> );<br><span class="hljs-keyword">if</span>( gHelloWorld == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Unable to load image %s! SDL Error: %s\n&quot;</span>, <span class="hljs-string">&quot;hello_world.bmp&quot;</span>, <span class="hljs-built_in">SDL_GetError</span>() );<br>success = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> success;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是对于loadMedia()函数的定义。<a href="/2024/01/05/SDL/Dictionary/SDL_LoadBMP/" title="SDL_LoadBMP">SDL_LoadBMP()</a>函数从括号中的相对路径中获取bmp文件，如果失败打印错误信息。如果读者这里报Parameter ‘src’ is invalid的错误，首先先检查相对路径写的是否正确，其次是bmp的文件是否放在了正确的工作目录中。不同的编译器对于工作目录的定义不同，这里读者可以根据自己的情况google查阅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Deallocate surface</span><br><span class="hljs-built_in">SDL_FreeSurface</span>( gHelloWorld );<br>gHelloWorld = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Destroy window</span><br><span class="hljs-built_in">SDL_DestroyWindow</span>( gWindow );<br>gWindow = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Quit SDL subsystems</span><br><span class="hljs-built_in">SDL_Quit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是对于close()函数的定义。首先从窗口开始，调用<a href="/2024/01/05/SDL/Dictionary/SDL_FreeSurface/" title="SDL_FreeSurface">SDL_FreeSurface()</a>来释放surface，然后再调用<a href="/2024/01/03/SDL/Dictionary/SDL_DestroyWindow/" title="SDL_DestroyWindow">SDL_DestroyWindow()</a>来销毁窗口，最后调用<a href="/2024/01/05/SDL/Dictionary/SDL_Quit/" title="SDL_Quit">SDL_Quit()</a>来销毁所有子系统。每次做完上述三步的每一步后记得将指针指向NULL，这将会是一个好习惯。请不要指望C++会自动帮你去释放资源，为了以防万一，请每次手动释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* args[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Start up SDL and create window</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">init</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to initialize!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Load media</span><br><span class="hljs-keyword">if</span>( !<span class="hljs-built_in">loadMedia</span>() )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Failed to load media!\n&quot;</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//Apply the image</span><br><span class="hljs-built_in">SDL_BlitSurface</span>( gHelloWorld, <span class="hljs-literal">NULL</span>, gScreenSurface, <span class="hljs-literal">NULL</span> );<br><br><span class="hljs-comment">//Update the surface</span><br><span class="hljs-built_in">SDL_UpdateWindowSurface</span>( gWindow );<br><br>            <span class="hljs-comment">//Hack to get window to stay up</span><br>            SDL_Event e; <br>            <span class="hljs-type">bool</span> quit = <span class="hljs-literal">false</span>; <br>            <span class="hljs-keyword">while</span>( quit == <span class="hljs-literal">false</span> )&#123; <br>                    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">SDL_PollEvent</span>( &amp;e ) )&#123;<br>                         <span class="hljs-keyword">if</span>( e.type == SDL_QUIT ) quit = <span class="hljs-literal">true</span>;<br>                    &#125; <br>            &#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//Free resources and close SDL</span><br><span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码便是主函数调用，看到这里大家应该对如何把我们准备的图片显示到屏幕上还是懵的，看完这一段代码中心中的疑惑能够解开。跳过上面已经讨论过的内容，我们直接看<a href="/2024/01/05/SDL/Dictionary/SDL_BlitSurface/" title="SDL_BlitSurface">SDL_BlitSurface()</a>函数。 gScreenSurface之前我们已将其关联到了窗口，gHelloWorld则带着我们需要的图片，那如何将图片显示到窗口(屏幕)上来呢？我们直接将gHelloWorld的内容复制到gScreenSurface上即可，并且在复制完之后通过<a href="/2024/01/05/SDL/Dictionary/SDL_UpdateWindowSurface/" title="SDL_UpdateWindowSurface">SDL_UpdateWindowSurface()</a>更新窗口。构建SDL_Event e，并且不断轮询当前待处理的事件，当事件类型变为SDL_QUIT时退出循环，也就退出窗口。最后别忘释放资源和关闭SDL。</p>]]></content>
    
    
    <categories>
      
      <category>Game Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_BlitSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_BlitSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_BlitSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-BlitSurface"><a href="#SDL-BlitSurface" class="headerlink" title="SDL_BlitSurface"></a>SDL_BlitSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_BlitSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用此功能可以将屏幕快速复制到目标屏幕。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_BlitSurface</span><span class="hljs-params">(SDL_Surface* src, <span class="hljs-type">const</span> SDL_Rect* srcrect, SDL_Surface* dst,SDL_Rect*dstrect)</span></span><br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>src: 要从中复制的 SDL_Surface 结构<br>srcrect: 表示要复制的矩形的 SDL_Rect 结构，或 NULL 来复制整个屏幕<br>dst: 作为 blit 目标的 SDL_Surface 结构<br>dstrect: 表示复制到的矩形的 SDL_Rect 结构</p><p>关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a><br>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果 blit 成功，则返回 0；如果失败，则返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Color</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_Color/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_Color/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Color"><a href="#SDL-Color" class="headerlink" title="SDL_Color"></a>SDL_Color</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Color">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>代表颜色的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><ol><li>Uint8 r: 0-255 范围内的红色分量</li><li>Uint8 g: 0-255 范围内的绿色分量</li><li>Uint8 b: 0-255 范围内的蓝色分量</li><li>Uint8 a: 0-255 范围内的阿尔法分量</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_ConvertSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_ConvertSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_ConvertSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-ConvertSurface"><a href="#SDL-ConvertSurface" class="headerlink" title="SDL_ConvertSurface"></a>SDL_ConvertSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_ConvertSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将一个现有的surface复制到一个指定格式的新surface</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface* <span class="hljs-title">SDL_ConvertSurface</span><span class="hljs-params">(SDL_Surface * src, <span class="hljs-type">const</span> SDL_PixelFormat * fmt, Uint32 flags)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>src: 需要转化的surface<br>fmt：新屏幕使用的SDL_PixelFormat结构<br>flags: 已被废弃，应始终设为0</p><p>关于SDL_PixelFormat的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_PixelFormat/" title="SDL_PixelFormat">SDL_PixelFormat</a><br>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回创建的新SDL_Surface结构，如果失败则返回NULL；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_FillRects</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_FillRects/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_FillRects/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-FillRects"><a href="#SDL-FillRects" class="headerlink" title="SDL_FillRects"></a>SDL_FillRects</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_FillRects">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用特定颜色对一组矩形执行快速填充。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_FillRects</span><span class="hljs-params">(SDL_Surface * dst, <span class="hljs-type">const</span> SDL_Rect * rects, <span class="hljs-type">int</span> count, Uint32 color)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>dst:作为目标的SDL_Surface结构<br>rects：SDL_Rect 结构体，表示要填充的矩形，或 NULL 来填充整个屏幕<br>count：数组中矩形的数量<br>color：填充的颜色</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a><br>关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_CreateRGBSurfaceFrom</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_CreateRGBSurfaceFrom/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_CreateRGBSurfaceFrom/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-CreateRGBSurfaceFrom"><a href="#SDL-CreateRGBSurfaceFrom" class="headerlink" title="SDL_CreateRGBSurfaceFrom"></a>SDL_CreateRGBSurfaceFrom</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_CreateRGBSurfaceFrom">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用现有像素数据分配一个新的 RGB 屏幕。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface* <span class="hljs-title">SDL_CreateRGBSurfaceFrom</span><span class="hljs-params">(<span class="hljs-type">void</span> *pixels,<span class="hljs-type">int</span> width,<span class="hljs-type">int</span> height,<span class="hljs-type">int</span> depth,<span class="hljs-type">int</span> pitch,Uint32 Rmask,Uint32 Gmask,Uint32 Bmask,Uint32 Amask)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>pixels:指向现有像素数据的指针<br>width:屏幕宽度<br>heigth:屏幕的高度<br>depth:屏幕的深度<br>pitch:屏幕的间距<br>Rmask:像素的红色掩码<br>Gmask:像素的绿色掩码<br>Bmask:像素的蓝色掩码<br>Amask:像素的阿尔法掩码</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回创建的新SDL_Surface结构，如果失败则返回NULL；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_CreateRGBSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_CreateRGBSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_CreateRGBSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-CreateRGBSurface"><a href="#SDL-CreateRGBSurface" class="headerlink" title="SDL_CreateRGBSurface"></a>SDL_CreateRGBSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_CreateRGBSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>分配一个新的 RGB 屏幕。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface* <span class="hljs-title">SDL_CreateRGBSurface</span><span class="hljs-params">(Uint32 flags, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>flags:标志未使用，应设置为 0<br>width:屏幕宽度<br>heigth:屏幕的高度<br>depth:屏幕的深度<br>Rmask:像素的红色掩码<br>Gmask:像素的绿色掩码<br>Bmask:像素的蓝色掩码<br>Amask:像素的阿尔法掩码</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回创建的新SDL_Surface结构，如果失败则返回NULL；调用 SDL_GetError() 获取更多信息</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_FreeSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_FreeSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_FreeSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-FreeSurface"><a href="#SDL-FreeSurface" class="headerlink" title="SDL_FreeSurface"></a>SDL_FreeSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_FreeSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>释放 RGB 屏幕</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_FreeSurface</span><span class="hljs-params">(SDL_Surface * surface)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：需要释放的SDL_Surface</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_FillRect</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_FillRect/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_FillRect/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-FillRect"><a href="#SDL-FillRect" class="headerlink" title="SDL_FillRect"></a>SDL_FillRect</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_FillRect">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用特定颜色执行矩形的快速填充。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_FillRect</span><span class="hljs-params">(SDL_Surface * dst, <span class="hljs-type">const</span> SDL_Rect * rect, Uint32 color)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>dst:作为目标的SDL_Surface结构<br>rect：SDL_Rect 结构体，表示要填充的矩形，或 NULL 来填充整个屏幕<br>color：填充的颜色</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a><br>关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetClipRect</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_GetClipRect/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_GetClipRect/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetClipRect"><a href="#SDL-GetClipRect" class="headerlink" title="SDL_GetClipRect"></a>SDL_GetClipRect</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetClipRect">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取屏幕的颜色键(transparent pixel)</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_GetColorKey</span><span class="hljs-params">(SDL_Surface * surface, Uint32 * key)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：要查询的 SDL_Surface 结构<br>key: 透明像素的指针</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetSurfaceAlphaMod</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_GetSurfaceAlphaMod/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_GetSurfaceAlphaMod/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetSurfaceAlphaMod"><a href="#SDL-GetSurfaceAlphaMod" class="headerlink" title="SDL_GetSurfaceAlphaMod"></a>SDL_GetSurfaceAlphaMod</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetSurfaceAlphaMod">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取 blit 操作中使用的附加 alpha 值。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_GetSurfaceAlphaMod</span><span class="hljs-params">(SDL_Surface * surface,Uint8 * alpha)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：表示要剪切的屏幕的 SDL_Surface 结构<br>alpha: 一个用当前 alpha 值填充的指针</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetSurfaceBlendMode</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_GetSurfaceBlendMode/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_GetSurfaceBlendMode/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetSurfaceBlendMode"><a href="#SDL-GetSurfaceBlendMode" class="headerlink" title="SDL_GetSurfaceBlendMode"></a>SDL_GetSurfaceBlendMode</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetSurfaceBlendMode">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取用于 blit 操作的混合模式。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_GetSurfaceBlendMode</span><span class="hljs-params">(SDL_Surface * surface, SDL_BlendMode *blendMode)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：表示要剪切的屏幕的 SDL_Surface 结构<br>blendMode: 填充当前 SDL_BlendMode 的指针</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetSurfaceColorMod</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_GetSurfaceColorMod/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_GetSurfaceColorMod/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetSurfaceColorMod"><a href="#SDL-GetSurfaceColorMod" class="headerlink" title="SDL_GetSurfaceColorMod"></a>SDL_GetSurfaceColorMod</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetSurfaceColorMod">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_GetSurfaceColorMod</span><span class="hljs-params">(SDL_Surface * surface,Uint8 * r, Uint8 * g, Uint8 * b)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：表示要剪切的屏幕的 SDL_Surface 结构<br>r: 用当前红色值填充的指针<br>g: 用当前绿色值填充的指针<br>b: 用当前蓝色值填充的指针</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_LoadBMP_RW</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_LoadBMP_RW/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_LoadBMP_RW/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-LoadBMP-RW"><a href="#SDL-LoadBMP-RW" class="headerlink" title="SDL_LoadBMP_RW"></a>SDL_LoadBMP_RW</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_LoadBMP_RW">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>从可查找的 SDL 数据流加载 BMP 图像。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface* <span class="hljs-title">SDL_LoadBMP_RW</span><span class="hljs-params">(SDL_RWops * src,<span class="hljs-type">int</span> freesrc)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>src：屏幕的数据流<br>freesrc：非零， 在读取后关闭流</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回指向新 SDL_Surface 结构的指针，如果出现错误，则返回 NULL；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_LockSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_LockSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_LockSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-LockSurface"><a href="#SDL-LockSurface" class="headerlink" title="SDL_LockSurface"></a>SDL_LockSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_LockSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置直接访问像素的屏幕。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_LockSurface</span><span class="hljs-params">(SDL_Surface * surface)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：要锁定的SDL_Surface结构</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_LowerBlit</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_LowerBlit/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_LowerBlit/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-LowerBlit"><a href="#SDL-LowerBlit" class="headerlink" title="SDL_LowerBlit"></a>SDL_LowerBlit</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_LowerBlit">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>仅执行低级屏幕位块传送。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_LowerBlit</span><span class="hljs-params">(SDL_Surface * src, SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>src：要从中复制的 SDL_Surface 结构<br>srcrect：表示要复制的矩形的 SDL_Rect 结构，或 NULL 来复制整个屏幕<br>dst：作为 blit 目标的 SDL_Surface 结构<br>dstrect：表示复制到的矩形的 SDL_Rect 结构</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a><br>关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetClipRect</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_GetColorKey/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_GetColorKey/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetClipRect"><a href="#SDL-GetClipRect" class="headerlink" title="SDL_GetClipRect"></a>SDL_GetClipRect</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetClipRect">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取屏幕的剪切矩形</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_GetClipRect</span><span class="hljs-params">(SDL_Surface * surface, SDL_Rect * rect)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：表示要剪切的屏幕的 SDL_Surface 结构<br>rect: 一个 SDL_Rect 结构</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a><br>关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Palette</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_Palette/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_Palette/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Palette"><a href="#SDL-Palette" class="headerlink" title="SDL_Palette"></a>SDL_Palette</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Palette">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含调色板信息的结构。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><ol><li>int ncolors: 调色板中的颜色数量</li><li>SDL_Color* colors: 关于SDL_Color的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Color/" title="SDL_Color">SDL_Color</a></li><li>Uint32 version: 增量跟踪调色板的更改（内部使用）</li><li>int refcount: 引用计数（内部使用）</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_PixelFormat</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_PixelFormat/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_PixelFormat/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-PixelFormat"><a href="#SDL-PixelFormat" class="headerlink" title="SDL_PixelFormat"></a>SDL_PixelFormat</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_PixelFormat">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含像素格式信息的结构</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><ol><li>Uint32 format: SDL_PixelFormatEnum 值之一</li><li>SDL_Palette* palette: 关于SDL_Palette的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Palette/" title="SDL_Palette">SDL_Palette</a></li><li>Uint8 BitsPerPixel: 像素值中有效位数，例如：8、15、16、24、32</li><li>Uint8 BytesPerPixel: 保存像素值所需的字节数，例如：1、2、3、4</li><li>Uint32 Rmask: 表示像素红色分量位置的掩码</li><li>Uint32 Gmask: 表示像素绿色分量位置的掩码</li><li>Uint32 Bmask： 表示像素蓝色分量位置的掩码</li><li>Uint32 Amask： 示像素 alpha 分量位置的掩码，如果像素格式没有任何 alpha 信息，则为 0</li><li>Uint8 Rloss：内部使用</li><li>Uint8 Rloss：内部使用</li><li>Uint8 Gloss：内部使用</li><li>Uint8 Bloss：内部使用</li><li>Uint8 Aloss：内部使用</li><li>Uint8 Rshift：内部使用</li><li>Uint8 Gshift：内部使用</li><li>Uint8 Bshift：内部使用</li><li>Uint8 Ashift：内部使用</li><li>int refcount：内部使用</li><li>SDL_PixelFormat* next: 内部使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_MUSTLOCK</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_MUSTLOCK/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_MUSTLOCK/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-MUSTLOCK"><a href="#SDL-MUSTLOCK" class="headerlink" title="SDL_MUSTLOCK"></a>SDL_MUSTLOCK</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_MUSTLOCK">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用此函数可以确定是否必须锁定屏幕才能进行访问。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_bool <span class="hljs-title">SDL_MUSTLOCK</span><span class="hljs-params">(SDL_Surface* surface)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface: 要查询的 SDL_Surface 结构</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果必须锁定表面才能访问，则返回 SDL_TRUE，否则返回 SDL_FALSE。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Rect</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_Rect/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_Rect/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Rect"><a href="#SDL-Rect" class="headerlink" title="SDL_Rect"></a>SDL_Rect</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Rect">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含矩形定义的结构，原点位于左上角。</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><ol><li>int x: 矩形左上角的 x 位置</li><li>int y: 矩形左上角的 y 位置</li><li>int w: 矩形的宽度</li><li>int h: 矩形的高度</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SaveBMP_RW</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SaveBMP_RW/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SaveBMP_RW/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SaveBMP-RW"><a href="#SDL-SaveBMP-RW" class="headerlink" title="SDL_SaveBMP_RW"></a>SDL_SaveBMP_RW</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SaveBMP_RW">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将屏幕以 BMP 格式保存到可查找的 SDL 数据流。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SaveBMP_RW</span><span class="hljs-params">(SDL_Surface * surface, SDL_RWops * dst, <span class="hljs-type">int</span> freedst)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface:包含要保存的图像的 SDL_Surface 结构<br>dst:要保存到的数据流<br>freedst:非零,以在写入后关闭流</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetColorKey</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SetColorKey/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SetColorKey/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetColorKey"><a href="#SDL-SetColorKey" class="headerlink" title="SDL_SetColorKey"></a>SDL_SetColorKey</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetColorKey">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置屏幕中的颜色键（透明像素）。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SetColorKey</span><span class="hljs-params">(SDL_Surface * surface,<span class="hljs-type">int</span> flag, Uint32 key)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface:要更新的 SDL_Surface 结构<br>flag:SDL_TRUE 启用颜色键，SDL_FALSE 禁用颜色键<br>key:透明像素</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetSurfaceAlphaMod</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceAlphaMod/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SetSurfaceAlphaMod/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetSurfaceAlphaMod"><a href="#SDL-SetSurfaceAlphaMod" class="headerlink" title="SDL_SetSurfaceAlphaMod"></a>SDL_SetSurfaceAlphaMod</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetSurfaceAlphaMod">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置 blit 操作中使用的附加 alpha 值。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SetSurfaceAlphaMod</span><span class="hljs-params">(SDL_Surface * surface,Uint8 alpha)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface:要更新的 SDL_Surface 结构<br>alpha:alpha 值乘以 blit 操作</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetClipRect</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SetClipRect/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SetClipRect/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetClipRect"><a href="#SDL-SetClipRect" class="headerlink" title="SDL_SetClipRect"></a>SDL_SetClipRect</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetClipRect">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置屏幕的剪切矩形</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_bool <span class="hljs-title">SDL_SetClipRect</span><span class="hljs-params">(SDL_Surface * surface, <span class="hljs-type">const</span> SDL_Rect * rect)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface:要裁剪的 SDL_Surface 结构<br>rect:表示剪切矩形的 SDL_Rect 结构，或 NULL 以禁用剪切</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a><br>关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果矩形与表面相交，则返回 SDL_TRUE，否则 SDL_FALSE 和位图将被完全裁剪。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetSurfaceBlendMode</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceBlendMode/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SetSurfaceBlendMode/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetSurfaceBlendMode"><a href="#SDL-SetSurfaceBlendMode" class="headerlink" title="SDL_SetSurfaceBlendMode"></a>SDL_SetSurfaceBlendMode</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetSurfaceBlendMode">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置用于位块传输操作的混合模式。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SetSurfaceBlendMode</span><span class="hljs-params">(SDL_Surface * surface,SDL_BlendMode blendMode)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface:要更新的 SDL_Surface 结构<br>blendMode:用于位图混合的 SDL_BlendMode</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetSurfaceColorMod</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceColorMod/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SetSurfaceColorMod/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetSurfaceColorMod"><a href="#SDL-SetSurfaceColorMod" class="headerlink" title="SDL_SetSurfaceColorMod"></a>SDL_SetSurfaceColorMod</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetSurfaceColorMod">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置一个额外的颜色值乘以 blit 操作。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SetSurfaceColorMod</span><span class="hljs-params">(SDL_Surface * surface,Uint8 r, Uint8 g, Uint8 b)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：表示要剪切的屏幕的 SDL_Surface 结构<br>r: 用当前红色值填充的指针<br>g: 用当前绿色值填充的指针<br>b: 用当前蓝色值填充的指针</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetSurfacePalette</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SetSurfacePalette/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SetSurfacePalette/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetSurfacePalette"><a href="#SDL-SetSurfacePalette" class="headerlink" title="SDL_SetSurfacePalette"></a>SDL_SetSurfacePalette</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetSurfacePalette">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置屏幕使用的调色板。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SetSurfacePalette</span><span class="hljs-params">(SDL_Surface * surface,SDL_Palette * palette)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：要更新的 SDL_Surface 结构<br>palette: 要使用的 SDL_Palette 结构</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a><br>关于SDL_Palette的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Palette/" title="SDL_Palette">SDL_Palette</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetSurfaceRLE</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SetSurfaceRLE/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SetSurfaceRLE/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetSurfaceRLE"><a href="#SDL-SetSurfaceRLE" class="headerlink" title="SDL_SetSurfaceRLE"></a>SDL_SetSurfaceRLE</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetSurfaceRLE">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置屏幕的 RLE 加速提示。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SetSurfaceRLE</span><span class="hljs-params">(SDL_Surface * surface,<span class="hljs-type">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：要优化的 SDL_Surface 结构<br>flag: 0 禁用，非零启用 RLE 加速</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SoftStretch</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_SoftStretch/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_SoftStretch/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SoftStretch"><a href="#SDL-SoftStretch" class="headerlink" title="SDL_SoftStretch"></a>SDL_SoftStretch</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SoftStretch">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在相同格式的两个屏幕之间执行快速、低质量的拉伸位块传输。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SoftStretch</span><span class="hljs-params">(SDL_Surface * src,<span class="hljs-type">const</span> SDL_Rect * srcrect,SDL_Surface * dst,<span class="hljs-type">const</span> SDL_Rect * dstrect)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：表示要剪切的屏幕的 SDL_Surface 结构<br>r: 用当前红色值填充的指针<br>g: 用当前绿色值填充的指针<br>b: 用当前蓝色值填充的指针</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Surface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_Surface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_Surface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Surface"><a href="#SDL-Surface" class="headerlink" title="SDL_Surface"></a>SDL_Surface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Surface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>一个结构包含了一系列像素集合，并且会用在软件位块传输中</p><h3 id="数据字段"><a href="#数据字段" class="headerlink" title="数据字段"></a>数据字段</h3><ol><li>Uint32 flags: 内部使用</li><li>SDL_PixelFormat* format: 关于SDL_PixelFormat的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_PixelFormat/" title="SDL_PixelFormat">SDL_PixelFormat</a></li><li>int w,h: 以像素为单位的宽度和高度（只读）</li><li>int pitch: 一行像素的长度（以字节为单位）（只读）</li><li>void* pixels: 指向实际像素数据的指针</li><li>void* userdata: 您可以设置任意指针（读写）</li><li>int locked: 用于需要锁定的屏幕（内部使用）</li><li>void* lock_data: 用于需要锁定的屏幕（内部使用）</li><li>SDL_Rect clip_rect: 关于SDL_Rect的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Rect/" title="SDL_Rect">SDL_Rect</a></li><li>SDL_BlitMap* map: 用于快速位块映射到其他屏幕的信息（内部使用）</li><li>int refcount: 可以由应用程序增加的引用计数</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_UnlockSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_UnlockSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_UnlockSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-UnlockSurface"><a href="#SDL-UnlockSurface" class="headerlink" title="SDL_UnlockSurface"></a>SDL_UnlockSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_UnlockSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>直接访问像素后释放屏幕。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_UnlockSurface</span><span class="hljs-params">(SDL_Surface * surface)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>surface：待解锁的SDL_Surface结构</p><p>关于SDL_Surface的描述可参考<a href="/2024/01/05/SDL/Dictionary/SDL_Surface/" title="SDL_Surface">SDL_Surface</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Event</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_Event/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_Event/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Event"><a href="#SDL-Event" class="headerlink" title="SDL_Event"></a>SDL_Event</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Event">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>包含不同事件类型的结构的联合。</p><p>Relationships between event types and union members:<br><img src="/img/SDL/Relationships_between_event_types_and_union_members.png"></p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>SDL_Event user_event;</p><table>    <tr>        <td>Event Type</td>         <td>Event Field</td>         <td>Event Structure</td>     </tr>    <tr>        <td>user_event.SDL_AUDIODEVICEADDED<br>user_event.SDL_AUDIODEVICEREMOVED</td>         <td>user_event.adevice</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_AudioDeviceEvent/" title="SDL_AudioDeviceEvent">SDL_AudioDeviceEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_CONTROLLERAXISMOTION</td>         <td>user_event.caxis</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_ControllerAxisEvent/" title="SDL_ControllerAxisEvent">SDL_ControllerAxisEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_CONTROLLERBUTTONDOWN<br>user_event.SDL_CONTROLLERBUTTONUP</td>         <td>user_event.cbutton</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_ControllerButtonEvent/" title="SDL_ControllerButtonEvent">SDL_ControllerButtonEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_CONTROLLERDEVICEADDED<br>user_event.SDL_CONTROLLERDEVICEREMOVED<br>user_event.SDL_CONTROLLERDEVICEREMAPPED</td>         <td>user_event.cdevice</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_ControllerDeviceEvent/" title="SDL_ControllerDeviceEvent">SDL_ControllerDeviceEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_DOLLARGESTURE<br>user_event.SDL_DOLLARGESTURE</td>         <td>user_event.dgesture</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_DollarGestureEvent/" title="SDL_DollarGestureEvent">SDL_DollarGestureEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_DROPFILE<br>user_event.SDL_DROPTEXT<br>user_event.SDL_DROPBEGIN<br>user_event.SDL_DROPCOMPLETE</td>         <td>user_event.drop</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_DropEvent/" title="SDL_DropEvent">SDL_DropEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_FINGERMOTION<br>user_event.SDL_FINGERDOWN<br>user_event.SDL_FINGERUP</td>         <td>user_event.tfinger</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_TouchFingerEvent/" title="SDL_TouchFingerEvent">SDL_TouchFingerEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_KEYDOWN<br>user_event.SDL_KEYUP</td>         <td>user_event.key</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_KeyboardEvent/" title="SDL_KeyboardEvent">SDL_KeyboardEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_JOYAXISMOTION</td>         <td>user_event.jaxis</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_JoyAxisEvent/" title="SDL_JoyAxisEvent">SDL_JoyAxisEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_JOYBALLMOTION</td>         <td>user_event.jball</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_JoyBallEvent/" title="SDL_JoyBallEvent">SDL_JoyBallEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_JOYHATMOTION</td>         <td>user_event.jhat</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_JoyHatEvent/" title="SDL_JoyHatEvent">SDL_JoyHatEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_JOYBUTTONDOWN<br>user_event.SDL_JOYBUTTONUP</td>         <td>user_event.jbutton</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_JoyButtonEvent/" title="SDL_JoyButtonEvent">SDL_JoyButtonEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_JOYDEVICEADDED<br>user_event.SDL_JOYDEVICEREMOVED</td>         <td>user_event.jdevice</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_JoyDeviceEvent/" title="SDL_JoyDeviceEvent">SDL_JoyDeviceEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_MOUSEMOTION</td>         <td>user_event.motion</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_MouseMotionEvent/" title="SDL_MouseMotionEvent">SDL_MouseMotionEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_MOUSEBUTTONDOWN<br>user_event.SDL_MOUSEBUTTONUP</td>         <td>user_event.button</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_MouseButtonEvent/" title="SDL_MouseButtonEvent">SDL_MouseButtonEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_MOUSEWHEEL</td>         <td>user_event.wheel</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_MouseWheelEvent/" title="SDL_MouseWheelEvent">SDL_MouseWheelEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_MULTIGESTURE</td>         <td>user_event.mgesture</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_MultiGestureEvent/" title="SDL_MultiGestureEvent">SDL_MultiGestureEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_QUIT</td>         <td>user_event.quit</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_QuitEvent/" title="SDL_QuitEvent">SDL_QuitEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_SYSWMEVENT</td>         <td>user_event.syswm</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_SysWMEvent/" title="SDL_SysWMEvent">SDL_SysWMEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_TEXTEDITING</td>         <td>user_event.edit</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_TextEditingEvent/" title="SDL_TextEditingEvent">SDL_TextEditingEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_TEXTINPUT</td>         <td>user_event.text</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_TextInputEvent/" title="SDL_TextInputEvent">SDL_TextInputEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_USEREVENT</td>         <td>user_event.user</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_UserEvent/" title="SDL_UserEvent">SDL_UserEvent</a></td>     </tr>    <tr>        <td>user_event.SDL_WINDOWEVENT</td>         <td>user_event.window</td>         <td><a href="/2024/01/07/SDL/Dictionary/SDL_WindowEvent/" title="SDL_WindowEvent">SDL_WindowEvent</a></td>     </tr>    <tr>        <td>Other events</td>         <td>none, use .type</td>         <td>SDL_CommonEvent</td>     </tr></table>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetError</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_GetError/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_GetError/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetError"><a href="#SDL-GetError" class="headerlink" title="SDL_GetError"></a>SDL_GetError</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetError">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>检索有关当前线程上发生的最后一个错误的消息。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">SDL_GetError</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window：查询窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回一条消息，其中包含有关所发生的特定错误的信息；如果自上次调用 SDL_ClearError() 以来尚未设置错误消息，则返回一个空字符串。 该消息仅在 SDL 函数发出错误信号时适用。 您必须检查 SDL 函数调用的返回值以确定何时适当地调用 SDL_GetError()。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetWindowSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_GetWindowSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_GetWindowSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetWindowSurface"><a href="#SDL-GetWindowSurface" class="headerlink" title="SDL_GetWindowSurface"></a>SDL_GetWindowSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetWindowSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取与窗口关联的 SDL 的surface。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface * <span class="hljs-title">SDL_GetWindowSurface</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window：查询窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回与窗口关联的表面，失败时返回 NULL；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Init</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_Init/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_Init/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Init"><a href="#SDL-Init" class="headerlink" title="SDL_Init"></a>SDL_Init</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Init">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>初始化 SDL 库。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_Init</span><span class="hljs-params">(Uint32 flags)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>flags：子系统初始化标志</p><p>flags可以是以下任何一个或组合在一起：<br>SDL_INIT_TIMER: 定时器子系统<br>SDL_INIT_AUDIO: 音频子系统<br>SDL_INIT_EVENTS: 事件子系统<br>SDL_INIT_VIDEO: 视频子系统；自动初始化事件子系统<br>SDL_INIT_JOYSTICK: 操纵杆子系统；自动初始化事件子系统<br>SDL_INIT_GAMECONTROLLER: 控制器子系统；自动初始化操纵杆子系统<br>SDL_INIT_HAPTIC: 触觉（力反馈）子系统<br>SDL_INIT_EVERYTHING: 上述所有子系统<br>SDL_INIT_NOPARACHUTE: 兼容性;该标志被忽略</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_LoadBMP</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_LoadBMP/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_LoadBMP/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-LoadBMP"><a href="#SDL-LoadBMP" class="headerlink" title="SDL_LoadBMP"></a>SDL_LoadBMP</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_LoadBMP">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>从文件路径加载 BMP 图像。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Surface* <span class="hljs-title">SDL_LoadBMP</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>file：包含 BMP 图像的文件</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回指向新 SDL_Surface 结构的指针，如果出现错误，则返回 NULL；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_PollEvent</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_PollEvent/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_PollEvent/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-PollEvent"><a href="#SDL-PollEvent" class="headerlink" title="SDL_PollEvent"></a>SDL_PollEvent</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_PollEvent">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>轮询当前待处理的事件。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_PollEvent</span><span class="hljs-params">(SDL_Event * event)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>event: 用队列中的下一个事件填充的 SDL_Event 结构，或 NULL</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果有待处理事件，则返回 1；如果没有可用事件，则返回 0。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_Quit</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_Quit/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_Quit/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-Quit"><a href="#SDL-Quit" class="headerlink" title="SDL_Quit"></a>SDL_Quit</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_Quit">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>清理所有初始化的子系统</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_Quit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_UpdateWindowSurface</title>
    <link href="/2024/01/05/SDL/Dictionary/SDL_UpdateWindowSurface/"/>
    <url>/2024/01/05/SDL/Dictionary/SDL_UpdateWindowSurface/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-UpdateWindowSurface"><a href="#SDL-UpdateWindowSurface" class="headerlink" title="SDL_UpdateWindowSurface"></a>SDL_UpdateWindowSurface</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_UpdateWindowSurface">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将窗口surface复制到屏幕上。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_UpdateWindowSurface</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window：需要更新的窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day16</title>
    <link href="/2024/01/04/LeetCode/LeetCode-20240104/"/>
    <url>/2024/01/04/LeetCode/LeetCode-20240104/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-最大宽度坡"><a href="#1-最大宽度坡" class="headerlink" title="1. 最大宽度坡"></a>1. 最大宽度坡</h1><p>给定一个整数数组 A，坡是元组 (i, j)，其中  i &lt; j 且 A[i] &lt;&#x3D; A[j]。这样的坡的宽度为 j - i。</p><p>找出 A 中的坡的最大宽度，如果不存在，返回 0 。<br><img src="/img/Leedcode/%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxWidthRamp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> start = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;start)&#123;<br>                start = nums[i];<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[st.<span class="hljs-built_in">top</span>()]&lt;=nums[i])&#123;<br>                result = <span class="hljs-built_in">max</span>(result, i-st.<span class="hljs-built_in">top</span>());<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//注意：使用动态规划会超时</span><br></code></pre></td></tr></table></figure><h1 id="2-最接近原点的-K-个点"><a href="#2-最接近原点的-K-个点" class="headerlink" title="2.  最接近原点的 K 个点"></a>2.  最接近原点的 K 个点</h1><p>给定一个数组 points ，其中 points[i] &#x3D; [xi, yi] 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点 (0,0) 最近的 k 个点。</p><p>这里，平面上两点之间的距离是 欧几里德距离（ √(x1 - x2)2 + (y1 - y2)2 ）。</p><p>你可以按 任何顺序 返回答案。除了点坐标的顺序之外，答案 确保 是 唯一 的。<br>![](&#x2F;img&#x2F;Leedcode&#x2F;最接近原点的 K 个点.png)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">kClosest</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; point_list;<br>        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> summation = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            point_list[<span class="hljs-built_in">pow</span>(points[i][<span class="hljs-number">0</span>], <span class="hljs-number">2</span>)+<span class="hljs-built_in">pow</span>(points[i][<span class="hljs-number">1</span>], <span class="hljs-number">2</span>)].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = point_list.<span class="hljs-built_in">begin</span>(); it!=point_list.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> element:it-&gt;second)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(points[element]);<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>排序优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">kClosest</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)&#123;<span class="hljs-built_in">return</span> (<span class="hljs-built_in">pow</span>(a[<span class="hljs-number">0</span>],<span class="hljs-number">2</span>)+<span class="hljs-built_in">pow</span>(a[<span class="hljs-number">1</span>],<span class="hljs-number">2</span>)) &lt; (<span class="hljs-built_in">pow</span>(b[<span class="hljs-number">0</span>],<span class="hljs-number">2</span>)+<span class="hljs-built_in">pow</span>(b[<span class="hljs-number">1</span>],<span class="hljs-number">2</span>));&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;k; i++)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(points[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-从链表中移除节点"><a href="#3-从链表中移除节点" class="headerlink" title="3. 从链表中移除节点"></a>3. 从链表中移除节点</h1><p>给你一个链表的头节点 head 。</p><p>移除每个右侧有一个更大数值的节点。</p><p>返回修改后链表的头节点 head 。<br><img src="/img/Leedcode/%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9.png"><br>递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<br><br>        head-&gt;next = <span class="hljs-built_in">removeNodes</span>(head-&gt;next);<br>        <span class="hljs-keyword">if</span>(head-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; head-&gt;val &lt; head-&gt;next-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> head -&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>单调栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        stack&lt;ListNode*&gt; st;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(INT_MAX, head);<br>        <br>        st.<span class="hljs-built_in">push</span>(dummy);<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() -&gt; val &lt; head-&gt;val)&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">top</span>() -&gt; next = head;<br>            st.<span class="hljs-built_in">push</span>(head);<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-设计一个文本编辑器"><a href="#4-设计一个文本编辑器" class="headerlink" title="4. 设计一个文本编辑器"></a>4. 设计一个文本编辑器</h1><p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p><ul><li>添加：在光标所在处添加文本。</li><li>删除：在光标所在处删除文本（模拟键盘的删除键）。</li><li>移动：将光标往左或者往右移动。<br>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候 0 &lt;&#x3D; cursor.position &lt;&#x3D; currentText.length 都成立。</li></ul><p>请你实现 TextEditor 类：</p><ul><li>TextEditor() 用空文本初始化对象。</li><li>void addText(string text) 将 text 添加到光标所在位置。添加完后光标在 text 的右边。</li><li>int deleteText(int k) 删除光标左边 k 个字符。返回实际删除的字符数目。</li><li>string cursorLeft(int k) 将光标向左移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。</li><li>string cursorRight(int k) 将光标向右移动 k 次。返回移动后光标左边 min(10, len) 个字符，其中 len 是光标左边的字符数目。<br><img src="/img/Leedcode/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    list&lt;<span class="hljs-type">char</span>&gt; l;<br>    list&lt;<span class="hljs-type">char</span>&gt;::iterator cur = l.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextEditor</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addText</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:text)&#123;<br>            l.<span class="hljs-built_in">insert</span>(cur, c);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteText</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k0 = k;<br>        <span class="hljs-keyword">for</span>(;k &amp;&amp; cur != l.<span class="hljs-built_in">begin</span>(); k--)&#123;<br>            l.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">prev</span>(cur));<br>        &#125;<br>        <span class="hljs-keyword">return</span> k0-k;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">Text</span><span class="hljs-params">()</span></span>&#123;<br>        string str = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">auto</span> it = cur;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">10</span>; k&amp;&amp;it != l.<span class="hljs-built_in">begin</span>(); k--)&#123;<br>            str += *--it;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(),str.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">cursorLeft</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(;k &amp;&amp; cur != l.<span class="hljs-built_in">begin</span>(); --k)&#123;<br>            --cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Text</span>();<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">cursorRight</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(;k &amp;&amp; cur != l.<span class="hljs-built_in">end</span>(); --k)&#123;<br>            ++cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Text</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TextEditor object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TextEditor* obj = new TextEditor();</span><br><span class="hljs-comment"> * obj-&gt;addText(text);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteText(k);</span><br><span class="hljs-comment"> * string param_3 = obj-&gt;cursorLeft(k);</span><br><span class="hljs-comment"> * string param_4 = obj-&gt;cursorRight(k);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="5-上下翻转二叉树"><a href="#5-上下翻转二叉树" class="headerlink" title="5. 上下翻转二叉树"></a>5. 上下翻转二叉树</h1><p>给你一个二叉树的根节点 root ，请你将此二叉树上下翻转，并返回新的根节点。</p><p>你可以按下面的步骤翻转一棵二叉树：</p><ol><li>原来的左子节点变成新的根节点</li><li>原来的根节点变成新的右子节点</li><li>原来的右子节点变成新的左子节点<br><img src="/img/Leedcode/%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>    TreeNode* ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">upsideDownBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span> || root-&gt;left == <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">return</span> root;&#125;<br>        TreeNode* tmp = <span class="hljs-built_in">cycle</span>(root);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">cycle</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<br>        TreeNode* leftnode = <span class="hljs-literal">nullptr</span>;<br>        TreeNode* rightnode = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root -&gt; left)&#123;leftnode = <span class="hljs-built_in">cycle</span>(root -&gt; left);&#125;<br>        <span class="hljs-keyword">if</span>(root -&gt; right)&#123;rightnode = <span class="hljs-built_in">cycle</span>(root -&gt; right);&#125;<br>        <br>        <span class="hljs-keyword">if</span>(leftnode == <span class="hljs-literal">nullptr</span> &amp;&amp; rightnode == <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">return</span> root;&#125;<br>        root -&gt; left = <span class="hljs-literal">nullptr</span>;<br>        root -&gt; right = <span class="hljs-literal">nullptr</span>;<br>        leftnode -&gt;left = rightnode;<br>        leftnode -&gt;right = root;<br>        <span class="hljs-keyword">if</span>(index)&#123;ans = leftnode;&#125;<br>        index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="6-经营摩天轮的最大利润"><a href="#6-经营摩天轮的最大利润" class="headerlink" title="6. 经营摩天轮的最大利润"></a>6. 经营摩天轮的最大利润</h1><p>你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 &#x2F; 4 周。</p><p>给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p><p>你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。</p><p>返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。<br><img src="/img/Leedcode/%E7%BB%8F%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperationsMaxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; customers, <span class="hljs-type">int</span> boardingCost, <span class="hljs-type">int</span> runningCost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> n = customers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> revenue = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> remain = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            presum[i+<span class="hljs-number">1</span>] = presum[i] + customers[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">4</span>, presum[i]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index*<span class="hljs-number">4</span>&lt;=presum[n]-dp[n])&#123;<br>            dp.<span class="hljs-built_in">push_back</span>(dp.<span class="hljs-built_in">back</span>()+<span class="hljs-number">4</span>);<br>            index++;<br>        &#125;<br>        dp.<span class="hljs-built_in">push_back</span>(presum[n]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;dp.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            revenue = dp[i]*boardingCost - i*runningCost;<br>            <span class="hljs-keyword">if</span>(revenue &gt; res)&#123;<br>                res = revenue;<br>                result = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperationsMaxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; customers, <span class="hljs-type">int</span> boardingCost, <span class="hljs-type">int</span> runningCost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> wait = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> revenue = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max_res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(wait || index&lt;customers.<span class="hljs-built_in">size</span>())&#123;<br>            wait += index&lt;customers.<span class="hljs-built_in">size</span>()? customers[index]:<span class="hljs-number">0</span>;<br>            up = <span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, wait);<br>            wait -= up;<br>            index++;<br>            revenue += up*boardingCost - runningCost;<br>            <span class="hljs-keyword">if</span>(revenue &gt; max_res)&#123;<br>                max_res = revenue;<br>                result = index;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="7-统计重复个数"><a href="#7-统计重复个数" class="headerlink" title="7. 统计重复个数"></a>7. 统计重复个数</h1><p>定义 str &#x3D; [s, n] 表示 str 由 n 个字符串 s 连接构成。</p><ul><li><p>例如，str &#x3D;&#x3D; [“abc”, 3] &#x3D;&#x3D;”abcabcabc” 。<br>如果可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。</p></li><li><p>例如，根据定义，s1 &#x3D; “abc” 可以从 s2 &#x3D; “abdbec” 获得，仅需要删除加粗且用斜体标识的字符。<br>现在给你两个字符串 s1 和 s2 和两个整数 n1 和 n2 。由此构造得到两个字符串，其中 str1 &#x3D; [s1, n1]、str2 &#x3D; [s2, n2] 。</p></li></ul><p>请你找出一个最大整数 m ，以满足 str &#x3D; [str2, m] 可以从 str1 获得。<br><img src="/img/Leedcode/%E7%BB%9F%E8%AE%A1%E9%87%8D%E5%A4%8D%E4%B8%AA%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxRepetitions</span><span class="hljs-params">(string s1, <span class="hljs-type">int</span> n1, string s2, <span class="hljs-type">int</span> n2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n_s1 = s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n_s2 = s2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; dp;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n_s2; i++)&#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;n_s1; k++)&#123;<br>                <span class="hljs-keyword">if</span>(s1[k] == s2[j])&#123;<br>                    ++j;<br>                    <span class="hljs-keyword">if</span>(j == n_s2)&#123;<br>                        cnt++;<br>                        j = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            dp.<span class="hljs-built_in">push_back</span>(&#123;cnt,j&#125;);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; n1&gt;<span class="hljs-number">0</span>; n1--)&#123;<br>            result += dp[j].first;<br>            j = dp[j].second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result/n2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="8-找出出现至少三次的最长特殊子字符串II"><a href="#8-找出出现至少三次的最长特殊子字符串II" class="headerlink" title="8. 找出出现至少三次的最长特殊子字符串II"></a>8. 找出出现至少三次的最长特殊子字符串II</h1><p>给你一个仅由小写英文字母组成的字符串 s 。</p><p>如果一个字符串仅由单一字符组成，那么它被称为 特殊 字符串。例如，字符串 “abc” 不是特殊字符串，而字符串 “ddd”、”zz” 和 “f” 是特殊字符串。</p><p>返回在 s 中出现 至少三次 的 最长特殊子字符串 的长度，如果不存在出现至少三次的特殊子字符串，则返回 -1 。</p><p>子字符串 是字符串中的一个连续 非空 字符序列。<br><img src="/img/Leedcode/%E6%89%BE%E5%87%BA%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91%E4%B8%89%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2II.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumLength</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">alpha_list</span>(<span class="hljs-number">26</span>);<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span> == n || s[i] != s[i+<span class="hljs-number">1</span>])&#123;<br>                alpha_list[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push_back</span>(cnt);<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;vec: alpha_list)&#123;<br>            <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">continue</span>;&#125;<br>            <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>            vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            result = <span class="hljs-built_in">max</span>(&#123;vec[<span class="hljs-number">0</span>]<span class="hljs-number">-2</span>,<span class="hljs-built_in">min</span>(vec[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, vec[<span class="hljs-number">1</span>]), vec[<span class="hljs-number">2</span>], result&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result? result:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="9-被列覆盖的最多行数"><a href="#9-被列覆盖的最多行数" class="headerlink" title="9. 被列覆盖的最多行数"></a>9. 被列覆盖的最多行数</h1><p>给你一个下标从 0 开始、大小为 m x n 的二进制矩阵 matrix ；另给你一个整数 numSelect，表示你必须从 matrix 中选择的 不同 列的数量。</p><p>如果一行中所有的 1 都被你选中的列所覆盖，则认为这一行被 覆盖 了。</p><p>形式上，假设 s &#x3D; {c1, c2, …., cnumSelect} 是你选择的列的集合。对于矩阵中的某一行 row ，如果满足下述条件，则认为这一行被集合 s 覆盖：</p><ul><li>对于满足 matrix[row][col] &#x3D;&#x3D; 1 的每个单元格 matrix[row][col]（0 &lt;&#x3D; col &lt;&#x3D; n - 1），col 均存在于 s 中，或者</li><li>row 中 不存在 值为 1 的单元格。<br>你需要从矩阵中选出 numSelect 个列，使集合覆盖的行数最大化。</li></ul><p>返回一个整数，表示可以由 numSelect 列构成的集合 覆盖 的 最大行数 。<br><img src="/img/Leedcode/%E8%A2%AB%E5%88%97%E8%A6%86%E7%9B%96%E7%9A%84%E6%9C%80%E5%A4%9A%E8%A1%8C%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumRows</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> numSelect)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">row_binary</span><span class="hljs-params">(row)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;col; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j])&#123;<br>                    row_binary[i] |= <span class="hljs-number">1</span>&lt;&lt;j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> mask=<span class="hljs-number">1</span>; mask &lt; <span class="hljs-number">1</span>&lt;&lt;col; mask++)&#123;<br>            <span class="hljs-keyword">if</span>(__builtin_popcount(mask) != numSelect)&#123;<span class="hljs-keyword">continue</span>;&#125;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> vec:row_binary)&#123;<br>                <span class="hljs-keyword">if</span>((vec &amp; mask) == vec)&#123;cnt++;&#125;<br>            &#125;<br>            result = <span class="hljs-built_in">max</span>(result, cnt);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_CreateWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_CreateWindow/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_CreateWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-CreateWindow"><a href="#SDL-CreateWindow" class="headerlink" title="SDL_CreateWindow"></a>SDL_CreateWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_CreateWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>创建一个自定义位置，尺寸和flags的窗口</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Window* <span class="hljs-title">SDL_CreateWindow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *title, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, Uint32 flags)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>Title: 窗口的标题， UTF-8的格式<br>x: 窗口x的位置， SDL_WINDOWPOS_CENTERED, 或者 SDL_WINDOWPOS_UNDEFINED<br>y: 窗口y的位置，SDL_WINDOWPOS_CENTERED, 或者 SDL_WINDOWPOS_UNDEFINED<br>w：窗口的宽度<br>h：窗口的高度<br>flags: 0 或者下列的一个或多个<br>flags的可能组合：<br>1.SDL_WINDOW_FULLSCREEN： 全屏窗口。<br>2.SDL_WINDOW_FULLSCREEN_DESKTOP: 以桌面分辨率的全屏窗口。<br>3.SDL_WINDOW_OPENGL: 可以以为OpenGL为内容的窗口。<br>4.SDL_WINDOW_VULKAN: 可以以Vulkan为实例的窗口。<br>5.SDL_WINDOW_METAL: 可以以Metal为实例的窗口。<br>6.SDL_WINDOW_HIDDEN: 窗口不可见。<br>7.SDL_WINDOW_BORDERLESS: 没有窗口修饰。<br>8.SDL_WINDOW_RESIZABLE: 窗口不能改变大小。<br>9.SDL_WINDOW_MINIMIZED: 最小化窗口。<br>10.SDL_WINDOW_MAXIMIZED: 最大化窗口。<br>11.SDL_WINDOW_INPUT_GRABBED: 窗口已获取输入焦点。<br>12.SDL_WINDOW_ALLOW_HIGHDPI: 如果支持(&gt;&#x3D; SDL 2.0.1)， 应该在高DPI模式下创建窗口。<br>13. SDL_WINDOW_SHOWN 被 SDL_CreateWindow() 忽略</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回已创建的窗口或失败时返回 NULL；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_CreateWindowFrom</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_CreateWindowFrom/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_CreateWindowFrom/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-CreateWindowFrom"><a href="#SDL-CreateWindowFrom" class="headerlink" title="SDL_CreateWindowFrom"></a>SDL_CreateWindowFrom</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_CreateWindowFrom">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>从本地窗口创建一个SDL window.</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_Window* <span class="hljs-title">SDL_CreateWindowFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>data: 指向驱动依赖窗口创建数据的指针</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回已创建的窗口或失败时返回 NULL；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetWindowData</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_GetWindowData/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_GetWindowData/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetWindowData"><a href="#SDL-GetWindowData" class="headerlink" title="SDL_GetWindowData"></a>SDL_GetWindowData</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetWindowData">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>拿取关联SDL_Window的数据指针</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">SDL_GetWindowData</span><span class="hljs-params">(SDL_Window * window, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要访问的SDL_Window<br>name: 返回数据指针的名字</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回与名称关联的值。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_DestroyWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_DestroyWindow/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_DestroyWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-DestroyWindow"><a href="#SDL-DestroyWindow" class="headerlink" title="SDL_DestroyWindow"></a>SDL_DestroyWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_DestroyWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>销毁一个窗口</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_DestoryWindow</span><span class="hljs-params">(SDL_Window* window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 被销毁的窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetWindowFlags</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_GetWindowFlags/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_GetWindowFlags/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetWindowFlags"><a href="#SDL-GetWindowFlags" class="headerlink" title="SDL_GetWindowFlags"></a>SDL_GetWindowFlags</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetWindowFlags">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>拿取SDL_Window的flag<br>关于flag的描述可参考<a href="/2024/01/03/SDL/Dictionary/SDL_CreateWindow/" title="SDL_CreateWindow">SDL_CreateWindow</a></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Uint32 <span class="hljs-title">SDL_GetWindowFlags</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要访问的SDL_Window</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回与窗口关联的 SDL_WindowFlags 的掩码。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetWindowGrab</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_GetWindowGrab/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_GetWindowGrab/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetWindowGrab"><a href="#SDL-GetWindowGrab" class="headerlink" title="SDL_GetWindowGrab"></a>SDL_GetWindowGrab</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetWindowGrab">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>返回SDL_TRUE如果input被抓取到，否则返回SDL_FALSE</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SDL_bool <span class="hljs-title">SDL_GetWindowGrab</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要访问的SDL_Window</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果输入被抓取，则返回 SDL_TRUE，否则返回 SDL_FALSE。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetWindowPosition</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_GetWindowPosition/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_GetWindowPosition/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetWindowPosition"><a href="#SDL-GetWindowPosition" class="headerlink" title="SDL_GetWindowPosition"></a>SDL_GetWindowPosition</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetWindowPosition">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取窗口的位置</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_GetWindowPosition</span><span class="hljs-params">(SDL_Window * window, <span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要访问的SDL_Window<br>x: 需要的话，指针中将指向窗口的x position。如果不需要就为Null<br>y: 需要的话，指针中将指向窗口的y position。如果不需要就为Null</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetWindowSize</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_GetWindowSize/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_GetWindowSize/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetWindowSize"><a href="#SDL-GetWindowSize" class="headerlink" title="SDL_GetWindowSize"></a>SDL_GetWindowSize</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetWindowSize">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>得到窗口的客户区大小<br>客户区：指图中的青色部分:即蓝色方框内区域。<br>非客户区：就是指蓝色方框之外的窗口区域,包括程序图标,标题栏,菜单,最大最小&#x2F;关闭按纽,左右两个框和底下的状态条。<br><img src="/img/SDL/%E5%AE%A2%E6%88%B7%E5%8C%BA_%E9%9D%9E%E5%AE%A2%E6%88%B7%E5%8C%BA.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_GetWindowSize</span><span class="hljs-params">(SDL_Window * window, <span class="hljs-type">int</span> *w, <span class="hljs-type">int</span> *h)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要访问的SDL_Window<br>w: 需要的话，指针中将指向窗口的宽度。如果不需要就为Null<br>h: 需要的话，指针中将指向窗口的高度。如果不需要就为Null</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_GetWindowTitle</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_GetWindowTitle/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_GetWindowTitle/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-GetWindowTitle"><a href="#SDL-GetWindowTitle" class="headerlink" title="SDL_GetWindowTitle"></a>SDL_GetWindowTitle</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_GetWindowTitle">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>得到窗口的标题</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">SDL_GetWindowTitle</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要访问的SDL_Window</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回 UTF-8 格式的窗口标题，如果没有标题，则返回“”。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_MinimizeWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_MinimizeWindo/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_MinimizeWindo/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-MinimizeWindow"><a href="#SDL-MinimizeWindow" class="headerlink" title="SDL_MinimizeWindow"></a>SDL_MinimizeWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_MinimizeWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在图像层面一个窗口最小化</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_MinimizeWindow</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要最小化的窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_HideWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_HideWindow/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_HideWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-HideWindow"><a href="#SDL-HideWindow" class="headerlink" title="SDL_HideWindow"></a>SDL_HideWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_HideWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>隐藏一个窗口</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_HideWindow</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要访问的SDL_Window</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_MaximizeWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_MaximizeWindow/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_MaximizeWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-MaximizeWindow"><a href="#SDL-MaximizeWindow" class="headerlink" title="SDL_MaximizeWindow"></a>SDL_MaximizeWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_MaximizeWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使一个窗口尽可能大</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_MaximizeWindow</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要最大化的窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_RaiseWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_RaiseWindow/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_RaiseWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-RaiseWindow"><a href="#SDL-RaiseWindow" class="headerlink" title="SDL_RaiseWindow"></a>SDL_RaiseWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_RaiseWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使一个窗口上升至其他窗口之上，并且重新对焦输入</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_RaiseWindow</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要上升的窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_RestoreWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_RestoreWindow/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_RestoreWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-RestoreWindow"><a href="#SDL-RestoreWindow" class="headerlink" title="SDL_RestoreWindow"></a>SDL_RestoreWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_RestoreWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>恢复一个被最大化或被最小化的窗口的大小和位置</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_RestoreWindow</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要恢复的窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowBordered</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowBordered/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowBordered/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowBordered"><a href="#SDL-SetWindowBordered" class="headerlink" title="SDL_SetWindowBordered"></a>SDL_SetWindowBordered</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowBordered">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置窗口的边框状态。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_SetWindowBordered</span><span class="hljs-params">(SDL_Window * window, SDL_bool bordered)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 要更改其边框状态的窗口<br>bordered: SDL_FALSE 删除边框，SDL_TRUE 添加边框</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowData</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowData/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowData/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowData"><a href="#SDL-SetWindowData" class="headerlink" title="SDL_SetWindowData"></a>SDL_SetWindowData</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowData">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将任意命名的指针与窗口关联。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">SDL_SetWindowData</span><span class="hljs-params">(SDL_Window * window, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *userdata)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要关联指针的窗口<br>name: 指针的名字<br>userdata: 关联的指针</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowFullscreen</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowFullscreen/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowFullscreen/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowFullscreen"><a href="#SDL-SetWindowFullscreen" class="headerlink" title="SDL_SetWindowFullscreen"></a>SDL_SetWindowFullscreen</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowFullscreen">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置全屏窗口的状态</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SDL_SetWindowFullscreen</span><span class="hljs-params">(SDL_Window * window, Uint32 flags)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要改变的窗口<br>关于flag的描述可参考<a href="/2024/01/03/SDL/Dictionary/SDL_CreateWindow/" title="SDL_CreateWindow">SDL_CreateWindow</a></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时返回 0，失败时返回负错误代码；调用 SDL_GetError() 获取更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowGrab</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowGrab/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowGrab/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowGrab"><a href="#SDL-SetWindowGrab" class="headerlink" title="SDL_SetWindowGrab"></a>SDL_SetWindowGrab</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowGrab">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置一个窗口的输入抓取模式</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_SetWindowGrab</span><span class="hljs-params">(SDL_Window * window, SDL_bool grabbed)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 应设置输入抓取模式的窗口<br>grabbed: SDL_TRUE 获取输入或 SDL_FALSE 释放输入</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowIcon</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowIcon/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowIcon/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowIcon"><a href="#SDL-SetWindowIcon" class="headerlink" title="SDL_SetWindowIcon"></a>SDL_SetWindowIcon</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowIcon">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置窗口的图标。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_SetWindowIcon</span><span class="hljs-params">(SDL_Window * window, SDL_Surface * icon)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要改变的窗口<br>icon: 包含窗口图标的 SDL_Surface 结构</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowPosition</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowPosition/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowPosition/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowPosition"><a href="#SDL-SetWindowPosition" class="headerlink" title="SDL_SetWindowPosition"></a>SDL_SetWindowPosition</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowPosition">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置窗口的位置。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_SetWindowPosition</span><span class="hljs-params">(SDL_Window * window, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要改变位置的窗口<br>x: 窗口中的x坐标或者SDL_WINDOWPOS_CENTERED或者SDL_WINDOWPOS_UNDEFINED<br>y：窗口中的y坐标或者SDL_WINDOWPOS_CENTERED或者SDL_WINDOWPOS_UNDEFINED</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_ShowWindow</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_ShowWindow/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_ShowWindow/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-ShowWindow"><a href="#SDL-ShowWindow" class="headerlink" title="SDL_ShowWindow"></a>SDL_ShowWindow</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_ShowWindow">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>展示一个窗口</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_ShowWindow</span><span class="hljs-params">(SDL_Window * window)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 想要展示的窗口</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowSize</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowSize/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowSize/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowSize"><a href="#SDL-SetWindowSize" class="headerlink" title="SDL_SetWindowSize"></a>SDL_SetWindowSize</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowSize">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置窗口客户区的大小。<br>客户区：指图中的青色部分:即蓝色方框内区域。<br>非客户区：就是指蓝色方框之外的窗口区域,包括程序图标,标题栏,菜单,最大最小&#x2F;关闭按纽,左右两个框和底下的状态条。<br><img src="/img/SDL/%E5%AE%A2%E6%88%B7%E5%8C%BA_%E9%9D%9E%E5%AE%A2%E6%88%B7%E5%8C%BA.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_SetWindowSize</span><span class="hljs-params">(SDL_Window * window, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要改变的窗口<br>w: 屏幕坐标中窗口的宽度（以像素为单位）必须 &gt; 0<br>h：屏幕坐标中窗口的高度（以像素为单位）必须 &gt; 0</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDL_SetWindowTitle</title>
    <link href="/2024/01/03/SDL/Dictionary/SDL_SetWindowTitle/"/>
    <url>/2024/01/03/SDL/Dictionary/SDL_SetWindowTitle/</url>
    
    <content type="html"><![CDATA[<h1 id="SDL-SetWindowTitle"><a href="#SDL-SetWindowTitle" class="headerlink" title="SDL_SetWindowTitle"></a>SDL_SetWindowTitle</h1><span id="more"></span><p>参考链接：<a href="https://wiki.libsdl.org/SDL2/SDL_SetWindowTitle">Click to jump</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>设置窗口的标题。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SDL_SetWindowTitle</span><span class="hljs-params">(SDL_Window * window, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *title)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>window: 需要改变的窗口<br>title：UTF-8 格式的所需窗口标题</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>SDL Dictionary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.Start using SDL in Windows</title>
    <link href="/2024/01/02/SDL/1.SDL_Start%20using%20SDL%20in%20Windows/"/>
    <url>/2024/01/02/SDL/1.SDL_Start%20using%20SDL%20in%20Windows/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取"><a href="#在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取" class="headerlink" title="在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取"></a>在介绍SDL环境配置之前先放一些笔者个人觉得有用的链接，有需要的读者自取</h2><p>SDL官网地址：<a href="https://www.libsdl.org/">Click to jump</a><br>SDL2下载地址：<a href="https://github.com/libsdl-org/SDL_image/releases">Click to jump</a><br>Lazy Foo’ Productions: <a href="https://lazyfoo.net/tutorials/SDL/">Click to jump</a><br>CodeBlocks下载地址：<a href="https://www.codeblocks.org/downloads/">Click to jump</a><br>MinGw下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/">Click to jump</a></p><h2 id="配置SDL"><a href="#配置SDL" class="headerlink" title="配置SDL"></a>配置SDL</h2><ol><li>   下载SDL头文件和二进制文件<br>下载链接：<a href="https://github.com/libsdl-org/SDL/releases/tag/release-2.28.5">Click to jump</a><br><img src="/img/SDL/SDL2_downloading_github.png"></li></ol><p>将文件下载下来并解压得到下列文件。这里需要使用的有两个文件夹，一个是i686-w64-mingw32另一个是x86_64-w64-mingw32.这其中第一个代表32bit binaries而后者为64bit binaries。为了最大化的保证兼容性，我们使用32bit的。不论你主机是32位的还是64位的都可以得到支持。剪切文件夹，笔者将其复制到C盘并为了方便识别加以重命名，最后得到路径C:\mingw_dev_lib。<br><img src="/img/SDL/SDL2_downloading_filelist.png"></p><ol start="2"><li><p>在CB中新建一个project，笔者在这里将其命名位SDL2<br><img src="/img/SDL/creat_new_project_in_CB.png"></p></li><li><p>添加complier directory<br>首先在project list中右击新建的project进入project&#x2F;targets options<br><img src="/img/SDL/CB_project_lists.png"><br>点击project&#x2F;targets options进入oject’s build options<br><img src="/img/SDL/CB_project_property.png"><br>进入C:\mingw_dev_lib（详细步骤见（1））其中的include&#x2F;SDL2,复制当前的文件地址拷贝入下列窗口中。<br>注意：在拷贝复制前依次点击search directions-&gt;complier, 确保输入在正确的空白框。<br>左侧框中一定要选择SDL2确保设置能同时作用到Debug和Release。<br>这一步如果出错，在示例代码build时会报 can’t find SDL.h的错误。<br><img src="/img/SDL/CB_search_directories_complier.png"></p></li><li><p>添加linker directory<br>进入C:\mingw_dev_lib（详细步骤见（1））其中的lib,复制当前的文件地址并拷入下列窗口中。<br>注意：在拷贝复制前依次点击search directions-&gt;linker, 确保输入在正确的空白框。<br>左侧框中一定要选择SDL2确保设置能同时作用到Debug和Release。<br>这一步如果出错，在示例代码build时会报 can’t find -ISDL2 or -ISDL2main的错误。<br><img src="/img/SDL/CB_linker_directory.png"></p></li><li><p>添加other linker options<br>点击Linker settings,在other linker options中输入-lmingw32 -lSDL2main -lSDL2<br><img src="/img/SDL/CB_other_linker.png"></p></li><li><p>将build type under build targets 改为Console application<br>这里选择console application主要是为了看到console output，如果读者不想看到可以选择GUI application.<br><img src="/img/SDL/CB_build_type.png"></p></li><li><p>setup the dll file<br>进入C:\mingw_dev_lib\bin（详细步骤见（1））拷贝SDL2.dll至CB项目目录下</p></li><li><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SDL.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    SDL_Window *window;<br><br>    <span class="hljs-built_in">SDL_Init</span>(SDL_INIT_VIDEO);<br><br>    window = <span class="hljs-built_in">SDL_CreateWindow</span>(<br>        <span class="hljs-string">&quot;Test&quot;</span>,<br>        SDL_WINDOWPOS_UNDEFINED,<br>        SDL_WINDOWPOS_UNDEFINED,<br>        <span class="hljs-number">640</span>,<br>        <span class="hljs-number">480</span>,<br>        SDL_WINDOW_SHOWN<br>    );<br><br>    <span class="hljs-built_in">SDL_Delay</span>(<span class="hljs-number">3000</span>);<br><br>    <span class="hljs-built_in">SDL_DestroyWindow</span>(window);<br>    <span class="hljs-built_in">SDL_Quit</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其他注意事项<br>笔者在操作的时候遇到一个大坑，本着前人踩坑，后人避坑的想法，笔者在这里帮大家总结经验。由于在步骤1）的时候选择的是支持32bit的，这对于操作系统的位数确实没有限制，但是对CB的MinGW确实有版本的限制。通过在指定目录下运行gcc -v可以查看当前CB的MinGw的版本。请确保自己CB的MinGw版本是i686开头的，否则会报can’t find -ISDL2 or -ISDL2main的错误。<br><img src="/img/SDL/CB_gcc-v.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Game Development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day15</title>
    <link href="/2023/12/31/LeetCode/LeetCode-20231231/"/>
    <url>/2023/12/31/LeetCode/LeetCode-20231231/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-商品折扣后的最终价格"><a href="#1-商品折扣后的最终价格" class="headerlink" title="1. 商品折扣后的最终价格"></a>1. 商品折扣后的最终价格</h1><p>给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;&#x3D; prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。<br><img src="/img/Leedcode/%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">finalPrices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;prices)</span> </span>&#123;<br>        stack&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; st;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; prices[i]&lt;=st.<span class="hljs-built_in">top</span>()[<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">auto</span> tmp = st.<span class="hljs-built_in">top</span>();<br>                result[tmp[<span class="hljs-number">0</span>]] = tmp[<span class="hljs-number">1</span>]-prices[i];<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(&#123;i, prices[i]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> tmp = st.<span class="hljs-built_in">top</span>();<br>            result[tmp[<span class="hljs-number">0</span>]] = tmp[<span class="hljs-number">1</span>];<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>单调栈优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">finalPrices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;prices)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>()&gt;prices[i])&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            result[i] = st.<span class="hljs-built_in">empty</span>()?prices[i]:prices[i]-st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">push</span>(prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-删除给定值的叶子节点"><a href="#2-删除给定值的叶子节点" class="headerlink" title="2.  删除给定值的叶子节点"></a>2.  删除给定值的叶子节点</h1><p>给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。</p><p>注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。</p><p>也就是说，你需要重复此过程直到不能继续删除。<br><img src="/img/Leedcode/%E5%88%A0%E9%99%A4%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">removeLeafNodes</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<br>        TreeNode* leftnode = <span class="hljs-built_in">removeLeafNodes</span>(root-&gt;left, target);<br>        TreeNode* rightnode = <span class="hljs-built_in">removeLeafNodes</span>(root-&gt;right, target);<br>        root-&gt;left = leftnode;<br>        root-&gt;right = rightnode;<br>        <span class="hljs-keyword">if</span>(leftnode == <span class="hljs-literal">nullptr</span> &amp;&amp; rightnode == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;val == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-统计放置房子的方式数"><a href="#3-统计放置房子的方式数" class="headerlink" title="3. 统计放置房子的方式数"></a>3. 统计放置房子的方式数</h1><p>一条街道上共有 n * 2 个 地块 ，街道的两侧各有 n 个地块。每一边的地块都按从 1 到 n 编号。每个地块上都可以放置一所房子。</p><p>现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 109 + 7 取余后再返回。</p><p>注意，如果一所房子放置在这条街某一侧上的第 i 个地块，不影响在另一侧的第 i 个地块放置房子。<br><img src="/img/Leedcode/%E7%BB%9F%E8%AE%A1%E6%94%BE%E7%BD%AE%E6%88%BF%E5%AD%90%E7%9A%84%E6%96%B9%E5%BC%8F%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> MOD = <span class="hljs-number">7</span>+<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>            dp[i] = (dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>])%MOD;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)dp[n]*dp[n]%MOD;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-统计最高分的节点数目"><a href="#3-统计最高分的节点数目" class="headerlink" title="3. 统计最高分的节点数目"></a>3. 统计最高分的节点数目</h1><p>给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] &#x3D;&#x3D; -1 。</p><p>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。</p><p>请你返回有 最高得分 节点的 数目 。<br><img src="/img/Leedcode/%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countHighestScoreNodes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; parents)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = parents.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-type">long</span> best_result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            g[parents[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; treenum = [&amp;](<span class="hljs-type">int</span> num)&#123;<br>            <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> child:g[num])&#123;<br>                <span class="hljs-type">int</span> sub_result = <span class="hljs-built_in">treenum</span>(child);<br>                result *= sub_result;<br>                cnt += sub_result;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num)&#123;result *= n - cnt - <span class="hljs-number">1</span>;&#125;<br><br>            <span class="hljs-keyword">if</span>(result &gt; best_result)&#123;<br>                ans = <span class="hljs-number">1</span>;<br>                best_result = result;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result == best_result)&#123;ans++;&#125;<br><br>            <span class="hljs-keyword">return</span> cnt + <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-type">int</span> tmp =  <span class="hljs-built_in">treenum</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inside the C++ Object Model-3</title>
    <link href="/2023/12/31/Inside%20the%20C++%20Object%20Model/Inside%20the%20C++%20Object%20Model-3/"/>
    <url>/2023/12/31/Inside%20the%20C++%20Object%20Model/Inside%20the%20C++%20Object%20Model-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Default-Constructor的构造操作"><a href="#Default-Constructor的构造操作" class="headerlink" title="Default Constructor的构造操作"></a>Default Constructor的构造操作</h1><span id="more"></span><p>生成nontrivial default constructor的4种情况：</p><h2 id="1-带有Default-Constructor的member-class-object"><a href="#1-带有Default-Constructor的member-class-object" class="headerlink" title="1.带有Default Constructor的member class object"></a>1.带有Default Constructor的member class object</h2><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-built_in">Foo</span>()<br>        <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>) <br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Foo foo;<br>    <span class="hljs-type">char</span> *str;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span></span>&#123;<br>    Bar bar;<br>    <span class="hljs-keyword">if</span>(str)&#123;&#125;...<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，由于class Foo default constructor的存在，编译器为class Bar合成了一个default constructor。编译器合成Bear default constructor的目的是来调用已经定义的Foo default constructor来处理class Bar中内含的Foo foo，因为这是编译器自身的需要。至于class foo中的str并没有被初始化，因为str的使用是程序员提出的需求，那自然str的初始化是程序员该负责的事情。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> </span><br><span class="hljs-function"><span class="hljs-title">Bar::Bar</span><span class="hljs-params">()</span></span>&#123;<br>    foo.Foo::<span class="hljs-built_in">Foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++不同的编译模块中，为了避免合成多个default constructor，可以通过把default constructor, copy constructor, destructor, assignment copy operator都已inline的方式完成。如果函数过于复杂，就合成一个explicit non-inline static实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bar::<span class="hljs-built_in">Bar</span>()&#123;str = <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p>还记得上文提到的str初始化问题吗，假设现在你在程序中加入了上述代码，细心的读者可能会提出疑问。编译器对于两个不同的default constructor采取什么行动呢？对于Class A, 如果包含一个或一个以上的class object member，Class A的每一个constructor必须调用member class的default constructor，其调用方式是通过扩张已经存在的constructors，在其中安插代码来完成。结合上面的例子我们能得到下面这个扩充后的constructor。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bar::<span class="hljs-built_in">Bar</span>()&#123;<br>    foo.Foo::<span class="hljs-built_in">Foo</span>();<br>    str = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那如果Class A中内含了多个class object member，其都需要constructor的初始化操作，那C++编译器会为每一个constructor以class object member 声明顺序来安插每一个class object member 所对应的default constructor代码。并且这些代码会安放在explicit user code 之前。通过下面的示例代码，读者能有一个更为直观的理解。<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Class定义：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snow_White</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Dopey dopey;<br>    Sneezy sneezy;<br>    Bashful bashful;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mumble;<br>&#125;<br><span class="hljs-comment">//编辑器中的default constructor:</span><br>Snow_White::<span class="hljs-built_in">Snow_White</span>()&#123;<br>    mumble = <span class="hljs-number">2048</span>;<br>&#125;<br><span class="hljs-comment">//编辑器扩张后的default constructor:</span><br>Snow_White::<span class="hljs-built_in">Snow_White</span>()&#123;<br>    dopey.Dopey::<span class="hljs-built_in">Dopey</span>();<br>    sneezy.Sneezy::<span class="hljs-built_in">Sneezy</span>();<br>    bashful.Bashful::<span class="hljs-built_in">Bashful</span>();<br>    <br>    mumble = <span class="hljs-number">2048</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-带有Default-Constructor的Base-Class"><a href="#2-带有Default-Constructor的Base-Class" class="headerlink" title="2.带有Default Constructor的Base Class"></a>2.带有Default Constructor的Base Class</h2><p>这里可以分为两种情况：对于本身没有任何constructors的derived class来说，如果base class含有default constructor。那就会根据声明顺序调用上一层base class的default constructor。第二种情况是对于derived class中含有constructors但是不包含base class的default constructor。Derived class面对这种情况不会合成新的default constructor。如果derived class中还存在像string这样同样带有default constructor的class object member。那些default constructor同样会被加入到derived class现有的constructor之中，只不过加入的顺序在base class constructor之后。</p><h2 id="3-带有一个Virtual-Function-的Class"><a href="#3-带有一个Virtual-Function-的Class" class="headerlink" title="3.带有一个Virtual Function 的Class"></a>3.带有一个Virtual Function 的Class</h2><p>下面两种情况会合成出default constructor：<br>1.Class 声明或继承virtual function<br>2.Class 派生自一个继承串链，其中存在virtual base classes<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget&amp; widget)</span></span>&#123;<br>    widget.<span class="hljs-built_in">flip</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>    Bell b;<br>    Whistle w;<br>    <span class="hljs-built_in">flip</span>(b);<br>    <span class="hljs-built_in">flip</span>(w);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述的代码，Widget为Bell和Whistle的父类。编译器会干两件事情：生成一个virtual function table存放class中virtual function地址。对于每个class object生成vptr来指示virtual function table的地址。<br>对于这个例子中的Bell class object b和Whistle class object w，编译器会通过default constructor为其各的vptr设定初值。如果class object本身存在constructor，编译器则会直接在其中安插代码确保vptr的正确初始化。</p><h2 id="4-带有一个Virtual-Function-的Class"><a href="#4-带有一个Virtual-Function-的Class" class="headerlink" title="4.带有一个Virtual Function 的Class"></a>4.带有一个Virtual Function 的Class</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Inside the C++ Object Model-2</title>
    <link href="/2023/12/31/Inside%20the%20C++%20Object%20Model/Inside%20the%20C++%20Object%20Model-2/"/>
    <url>/2023/12/31/Inside%20the%20C++%20Object%20Model/Inside%20the%20C++%20Object%20Model-2/</url>
    
    <content type="html"><![CDATA[<h1 id="关于C-对象"><a href="#关于C-对象" class="headerlink" title="关于C++对象"></a>关于C++对象</h1><span id="more"></span><ol><li>   一个class object需要多少内存？</li></ol><ul><li>Class object中的nonstatic data member的大小总和</li><li>由于alignment的需求而填补的空间</li><li>为了支持virtual而产生的额外空间</li></ul><p>示例代码及object和pointer内存布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooAnimal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> loc;<br>    string name;<br>&#125;;<br><br><span class="hljs-function">ZooAnimal <span class="hljs-title">za</span><span class="hljs-params">(<span class="hljs-string">&quot;Zoey&quot;</span>)</span></span>;<br>ZooAnimal *pza = &amp;za;<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1_classobject%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"><br>在这个例子中由于使用的是32位机器，所以int类型位4bytes。 而string由两部分组成：4-byte字符指针和字符串长度整数，加起来一共8bytes。最后是vptr指针用来支持virtual。说到指针，读者可能会疑惑对于指向不同类型的指针（如指向整数的指针和指向class的指针）之间会有什么区别。对于指针来说没有什么不同之处，无论是在指针表示法还是在指针内容本身上面。其不同在于根据指针内容所寻址出来的object类型上面，编译器会根据所指定的指针类型来解释通过寻址得到的object的类型。也正是由于这个原因，对于void的类型指针我们无法操作它所指向的object，原因在于我们压根没有告诉编译器指针所指向的类型，更无从谈起对object进行相应的操作。</p><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>示例代码及object和pointer内存布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooAnimal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ZooAnimal</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> loc;<br>    string name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bear</span>: <span class="hljs-keyword">public</span> ZooAnimal&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Bear</span>();<br>    ~<span class="hljs-built_in">Bear</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">dance</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Dances</span>&#123;...&#125;;<br>    Dances dances_known;<br>    <span class="hljs-type">int</span> cell_block;<br>&#125;;<br><br><span class="hljs-function">Bear <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;Yogi&quot;</span>)</span></span>;<br>Bear *pb = &amp;b;<br>Bear &amp;rb = *pb;<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1_derivedclassobject%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"><br>我们可以画出上述布局图，其中圆圈内的数字表示所占byte数，灰色部分为class Bear相对于class ZooAnimal多出来的部分，但这只是相较于ZooAnimal多出来的一部分，剩下的在虚函数表中。结合我们之前在C++对象模型中学习的虚函数表的知识，我们也能画出虚表中的布局图像。对于pointer pb亦或是reference rb都只需要一个word的空间，及4bytes在这个例子中，而对于Bear object b则需要24bytes。24bytes可由两部分组成：16bytes的ZooAnimal object和Bear多出来的部分。这里有一点需要注意这里的虚表指针类型仍为ZooAnimal。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>object和pointer内存布局：<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/object%E5%92%8Cpointer%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80_%E5%A4%9A%E7%BB%A7%E6%89%BF.png"><br>在这图中Derived class继承自Base1 class和Base2 class。在derived class中绿色部分有三个含义：1. 左侧部分表示继承自Base1和Base2。2. 右侧表示derived class对于Base1和Base2的override。3. 不论左侧和右侧，绿色部分的排序均按照声明的顺序排列。灰色部分表示derived class自己的部分，对于左侧nonstatic data member来说，derived class自己的data member排在base data member后面。Derived class自己的虚函数放在第一个虚函数表中base虚函数之后。</p><h2 id="关于继承问题的一些讨论"><a href="#关于继承问题的一些讨论" class="headerlink" title="关于继承问题的一些讨论"></a>关于继承问题的一些讨论</h2><h3 id="1-衍生类使用父类member"><a href="#1-衍生类使用父类member" class="headerlink" title="1.衍生类使用父类member"></a>1.衍生类使用父类member</h3><p>对于上面单继承给出的例子，我们继续给出一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bear b;<br>ZooAnimal *pz = &amp;b;<br>Bear *pb = &amp;b;<br></code></pre></td></tr></table></figure><p>鉴于Bear是ZooAnimal的衍生类， pb能涵盖的object为Bear，而pz所涵盖的只有Bear中的ZooAnimal。除了virtual和ZooAnimal class中出现的members, pz不能用来处理Bear class中出现的members。但有两种方法可以实现pz对Bear member cell_back的处理：<br>1.(static_cast&lt;Bear*&gt;(pz))-&gt;cell_back<br>2.If(Bear *pb2 &#x3D; dynamic_cast&lt;Bear*&gt;(pz)){pb2 -&gt; cell_back;}</p><h3 id="2-衍生类初始化父类"><a href="#2-衍生类初始化父类" class="headerlink" title="2.衍生类初始化父类"></a>2.衍生类初始化父类</h3><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Bear b;<br>ZooAnimal za = b;<br>za.<span class="hljs-built_in">rotate</span>();<br></code></pre></td></tr></table></figure><p>以上代码会带来两个问题：</p><ul><li>为什么rotate使用的还是ZooAnimal实例？<br>首先ZooAnimal 和 Bear是两个完全不同的object， 但从继承关系上来看，Bear object所占用的内存就比ZooAnimal大，把Bear实例直接赋值给ZooAnimal无疑是十分荒唐的。</li><li>为什么za的vptr不指向Bear的vltb？<br>编译器会在初始化和指定操作之间做出仲裁。对于含有一个或一个以上vptrs的object, 那些vptrs不会被初始化或者改变</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day14</title>
    <link href="/2023/12/28/LeetCode/LeetCode-20231228/"/>
    <url>/2023/12/28/LeetCode/LeetCode-20231228/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-最长的斐波那契子序列的长度"><a href="#1-最长的斐波那契子序列的长度" class="headerlink" title="1. 最长的斐波那契子序列的长度"></a>1. 最长的斐波那契子序列的长度</h1><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><ul><li>n &gt;&#x3D; 3</li><li>对于所有 i + 2 &lt;&#x3D; n，都有 X_i + X_{i+1} &#x3D; X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</li></ul><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）<br><img src="/img/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; arr_mapping;<br>        <span class="hljs-type">int</span> max_num = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            arr_mapping[arr[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-2</span>; i++)&#123;<br>            <span class="hljs-type">int</span> num_i=arr[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;n<span class="hljs-number">-1</span>; j++)&#123;<br>                num_i=arr[i];<br>                <span class="hljs-type">int</span> length = <span class="hljs-number">2</span>;<br>                <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> num_j=arr[j];<br>                <span class="hljs-keyword">while</span>(arr_mapping.<span class="hljs-built_in">find</span>(num_i+num_j) != arr_mapping.<span class="hljs-built_in">end</span>())&#123;<br>                    length++;<br>                    tmp = num_i;<br>                    num_i = num_j;<br>                    num_j = tmp+num_j;<br>                &#125;<br>                max_num = <span class="hljs-built_in">max</span>(max_num, length);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max_num == <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">return</span> max_num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>动态规划优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; arr_mapping;<br>        <span class="hljs-type">int</span> max_num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            arr_mapping[arr[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(arr_mapping.<span class="hljs-built_in">find</span>(arr[i]-arr[j]) != arr_mapping.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-number">2</span>*arr[j]&gt;arr[i])&#123;<br>                    k = arr_mapping[arr[i]-arr[j]];<br>                    dp[j][i] = <span class="hljs-built_in">max</span>(dp[k][j]+<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>                &#125;<br>                max_num = <span class="hljs-built_in">max</span>(max_num,dp[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_num;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="2-最深叶节点的最近公共祖先"><a href="#2-最深叶节点的最近公共祖先" class="headerlink" title="2.  最深叶节点的最近公共祖先"></a>2.  最深叶节点的最近公共祖先</h1><p>给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。</p><p>回想一下：</p><ul><li>叶节点 是二叉树中没有子节点的节点</li><li>树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1</li><li>如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。</li></ul><p><img src="/img/%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.png"><br>自上而下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode* ans = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> maxdepth = <span class="hljs-number">-1</span>;<br><br>        function&lt;<span class="hljs-type">int</span>(TreeNode*, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](TreeNode* node, <span class="hljs-type">int</span> depth)&#123;<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>                maxdepth = <span class="hljs-built_in">max</span>(depth, maxdepth);<br>                <span class="hljs-keyword">return</span> depth;<br>            &#125;<br>            <span class="hljs-type">int</span> maxleftlength = <span class="hljs-built_in">dfs</span>(node-&gt;left, depth+<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> maxrightlength = <span class="hljs-built_in">dfs</span>(node-&gt;right, depth+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(maxleftlength == maxrightlength &amp;&amp; maxleftlength == maxdepth)&#123;<br>                ans = node;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxleftlength,maxrightlength);<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>自底向上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, TreeNode*&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-literal">nullptr</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">auto</span>[leftheight, ica_left] = <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>        <span class="hljs-keyword">auto</span>[righheight, ica_right] = <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(leftheight&gt;righheight)&#123;<span class="hljs-keyword">return</span> &#123;leftheight+<span class="hljs-number">1</span>, ica_left&#125;;&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(righheight&gt;leftheight)&#123;<span class="hljs-keyword">return</span> &#123;righheight+<span class="hljs-number">1</span>, ica_right&#125;;&#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> &#123;leftheight+<span class="hljs-number">1</span>,node&#125;;&#125;<br><br><br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root).second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-判断矩阵经轮转后是否一致"><a href="#3-判断矩阵经轮转后是否一致" class="headerlink" title="3. 判断矩阵经轮转后是否一致"></a>3. 判断矩阵经轮转后是否一致</h1><p>给你两个大小为 n x n 的二进制矩阵 mat 和 target 。现 以 90 度顺时针轮转 矩阵 mat 中的元素 若干次 ，如果能够使 mat 与 target 一致，返回 true ；否则，返回 false 。<br><img src="/img/%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E7%BB%8F%E8%BD%AE%E8%BD%AC%E5%90%8E%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findRotation</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = mat.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;<span class="hljs-number">4</span>; k++)&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span> &amp;&amp; mat[i][j]==target[j][n<span class="hljs-number">-1</span>-i] || k==<span class="hljs-number">1</span> &amp;&amp; mat[i][j]==target[n<span class="hljs-number">-1</span>-i][n<span class="hljs-number">-1</span>-j] || k==<span class="hljs-number">2</span> &amp;&amp; mat[i][j]==target[n<span class="hljs-number">-1</span>-j][i] || k==<span class="hljs-number">3</span> &amp;&amp; mat[i][j]==target[i][j])&#123;<span class="hljs-keyword">continue</span>;&#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        flag = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day13</title>
    <link href="/2023/12/26/LeetCode/LeetCode-20231226/"/>
    <url>/2023/12/26/LeetCode/LeetCode-20231226/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-按既定顺序创建目标数组"><a href="#1-按既定顺序创建目标数组" class="headerlink" title="1. 按既定顺序创建目标数组"></a>1. 按既定顺序创建目标数组</h1><p>给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：</p><ul><li>目标数组 target 最初为空。</li><li>按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。</li><li>重复上一步，直到在 nums 和 index 中都没有要读取的元素。<br>请你返回目标数组。</li></ul><p>题目保证数字插入位置总是存在。<br><img src="/img/%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//本题注意vector中insert的使用</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">createTargetArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; index)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result; <br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> tmp = result.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span>(tmp<span class="hljs-number">-1</span>&lt;index[i])&#123;result.<span class="hljs-built_in">push_back</span>(nums[i]);&#125;<br>            <span class="hljs-keyword">else</span>&#123;result.<span class="hljs-built_in">insert</span>(result.<span class="hljs-built_in">begin</span>()+index[i], nums[i]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-转变数组后最接近目标值的数组和"><a href="#2-转变数组后最接近目标值的数组和" class="headerlink" title="2.  转变数组后最接近目标值的数组和"></a>2.  转变数组后最接近目标值的数组和</h1><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 arr 中的数字。<br><img src="/img/%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> real = INT_MAX;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result3 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result4 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>] + arr[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(target - presum[i] - arr[i]*(n-i));<br>            <span class="hljs-keyword">if</span>(real &gt; diff)&#123;<br>                index = i;<br>                real = diff; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">return</span> arr[n<span class="hljs-number">-1</span>];&#125;<br>        result1 = <span class="hljs-built_in">abs</span>(target-presum[index])/(n-index);<br>        result2 = <span class="hljs-built_in">abs</span>(target-presum[index+<span class="hljs-number">1</span>])/(n-index<span class="hljs-number">-1</span>);<br>        result2 = <span class="hljs-built_in">max</span>(result1,result2);<br>        result3 = result1 + <span class="hljs-number">1</span>;<br>        result4 = result2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target - presum[index] - result1*(n-index)) &lt; <span class="hljs-built_in">abs</span>(target - presum[index+<span class="hljs-number">1</span>] - result2*(n-index<span class="hljs-number">-1</span>)))&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target - presum[index] - result3*(n-index)) &lt; <span class="hljs-built_in">abs</span>(target - presum[index] - result1*(n-index)))&#123;<br>                result = result3;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;result = result1;&#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target - presum[index+<span class="hljs-number">1</span>] - result4*(n-index<span class="hljs-number">-1</span>)) &lt; <span class="hljs-built_in">abs</span>(target - presum[index+<span class="hljs-number">1</span>] - result2*(n-index<span class="hljs-number">-1</span>)))&#123;<br>                result = result4;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;result = result2;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-差值数组不同的字符串"><a href="#3-差值数组不同的字符串" class="headerlink" title="3. 差值数组不同的字符串"></a>3. 差值数组不同的字符串</h1><p>给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。</p><p>每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 &lt;&#x3D; j &lt;&#x3D; n - 2 有 difference[i][j] &#x3D; words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 ‘a’ 的位置是 0 ，’b’ 的位置是 1 ，’z’ 的位置是 25 。</p><ul><li>比方说，字符串 “acb” 的差值整数数组是 [2 - 0, 1 - 2] &#x3D; [2, -1] 。<br>words 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</li></ul><p>请你返回 words中 差值整数数组 不同的字符串。<br><img src="/img/%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">oddString</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; diff;<br>        <span class="hljs-type">int</span> n = words.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            string str = words[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;str.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(str[i]-str[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>            diff.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; reference = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec = diff[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;vec.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(reference[j] != vec[j])&#123;<br>                    index = i;<br>                    cnt++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt == n<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">return</span> words[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> words[index];&#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-获得分数的方法数"><a href="#4-获得分数的方法数" class="headerlink" title="4. 获得分数的方法数"></a>4. 获得分数的方法数</h1><p>考试中有 n 种类型的题目。给你一个整数 target 和一个下标从 0 开始的二维整数数组 types ，其中 types[i] &#x3D; [counti, marksi] 表示第 i 种类型的题目有 counti 道，每道题目对应 marksi 分。</p><p>返回你在考试中恰好得到 target 分的方法数。由于答案可能很大，结果需要对 109 +7 取余。</p><p>注意，同类型题目无法区分。</p><ul><li>比如说，如果有 3 道同类型题目，那么解答第 1 和第 2 道题目与解答第 1 和第 3 道题目或者第 2 和第 3 道题目是相同的。<br><img src="/img/%E8%8E%B7%E5%BE%97%E5%88%86%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> modul = <span class="hljs-number">7</span>+<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">waysToReachTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; types)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dp[target+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> qs:types)&#123;<br>            <span class="hljs-type">int</span> count = qs[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> mark = qs[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = target; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j&lt;= <span class="hljs-built_in">min</span>(count, i/mark);j++)&#123;<br>                    dp[i] = (dp[i] + dp[i-j*mark])%modul;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day12</title>
    <link href="/2023/12/25/LeetCode/LeetCode-20231225/"/>
    <url>/2023/12/25/LeetCode/LeetCode-20231225/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-移除栅栏得到的正方形田地的最大面积"><a href="#1-移除栅栏得到的正方形田地的最大面积" class="headerlink" title="1. 移除栅栏得到的正方形田地的最大面积"></a>1. 移除栅栏得到的正方形田地的最大面积</h1><p>有一个大型的 (m - 1) x (n - 1) 矩形田地，其两个对角分别是 (1, 1) 和 (m, n) ，田地内部有一些水平栅栏和垂直栅栏，分别由数组 hFences 和 vFences 给出。</p><p>水平栅栏为坐标 (hFences[i], 1) 到 (hFences[i], n)，垂直栅栏为坐标 (1, vFences[i]) 到 (m, vFences[i]) 。</p><p>返回通过 移除 一些栅栏（可能不移除）所能形成的最大面积的 正方形 田地的面积，或者如果无法形成正方形田地则返回 -1。</p><p>由于答案可能很大，所以请返回结果对 109 + 7 取余 后的值。</p><p>注意：田地外围两个水平栅栏（坐标 (1, 1) 到 (1, n) 和坐标 (m, 1) 到 (m, n) ）以及两个垂直栅栏（坐标 (1, 1) 到 (m, 1) 和坐标 (1, n) 到 (m, n) ）所包围。这些栅栏 不能 被移除。<br><img src="/img/%E7%A7%BB%E9%99%A4%E6%A0%85%E6%A0%8F%E5%BE%97%E5%88%B0%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%94%B0%E5%9C%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximizeSquareArea</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; hFences, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vFences)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> modul = <span class="hljs-number">7</span>+<span class="hljs-number">1e9</span>;<br>        hFences.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        hFences.<span class="hljs-built_in">push_back</span>(m);<br>        vFences.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        vFences.<span class="hljs-built_in">push_back</span>(n);<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;vFences.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=vFences.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; j&gt;i; j-- )&#123;<br>                st.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">abs</span>(vFences[j]-vFences[i]));<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;hFences.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = hFences.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; j&gt;i; j--)&#123;<br>                <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(hFences[j]-hFences[i]);<br>                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(diff))&#123;<br>                    ans = <span class="hljs-built_in">max</span>(ans, diff);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * ans * ans % modul;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-转换字符串的最小成本I"><a href="#2-转换字符串的最小成本I" class="headerlink" title="2.  转换字符串的最小成本I"></a>2.  转换字符串的最小成本I</h1><p><strong>提示</strong>：Floyd-Warshall 最短路算法<a href="https://zhuanlan.zhihu.com/p/623757829">Click to jump</a></p><p>给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。</p><p>另给你两个下标从 0 开始的字符数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符 original[i] 更改为字符 changed[i] 的成本。</p><p>你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] &#x3D;&#x3D; z  、original[j] &#x3D;&#x3D; x 以及 changed[j] &#x3D;&#x3D; y 。你就可以选择字符串中的一个字符 x 并以 z 的成本将其更改为字符 y 。</p><p>返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1 。</p><p>注意，可能存在下标 i 、j 使得 original[j] &#x3D;&#x3D; original[i] 且 changed[j] &#x3D;&#x3D; changed[i] 。<br><img src="/img/%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%ACI.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minimumCost</span><span class="hljs-params">(string source, string target, vector&lt;<span class="hljs-type">char</span>&gt;&amp; original, vector&lt;<span class="hljs-type">char</span>&gt;&amp; changed, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>,<span class="hljs-number">0x3f3f3f3f</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">26</span>; i++)&#123;<br>            dp[i][i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;original.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> x = original[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-type">int</span> y = changed[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            dp[x][y] = <span class="hljs-built_in">min</span>(dp[x][y], cost[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;<span class="hljs-number">26</span>; k++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">26</span>; i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;<span class="hljs-number">26</span>; j++)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k]+dp[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;source.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            result += dp[source[i]-<span class="hljs-string">&#x27;a&#x27;</span>][target[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(dp[source[i]-<span class="hljs-string">&#x27;a&#x27;</span>][target[i]-<span class="hljs-string">&#x27;a&#x27;</span>] ==<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day11</title>
    <link href="/2023/12/24/LeetCode/LeetCode-20231224/"/>
    <url>/2023/12/24/LeetCode/LeetCode-20231224/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-找出两数组的不同"><a href="#1-找出两数组的不同" class="headerlink" title="1. 找出两数组的不同"></a>1. 找出两数组的不同</h1><p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：</p><ul><li>answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。</li><li>answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。<br>注意：列表中的整数可以按 任意 顺序返回。<br><img src="/img/%E6%89%BE%E5%87%BA%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findDifference</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result1;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> point1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> point2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> number1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> number2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        nums1.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>()), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>        nums2.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>()), nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(point1&lt;n1 &amp;&amp; point2&lt;n2)&#123;<br>            number1 = nums1[point1];<br>            number2 = nums2[point2];<br>            <span class="hljs-keyword">if</span>(number1 == number2)&#123;<br>                point1++;<br>                point2++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(number1&lt;number2)&#123;<br>                result2.<span class="hljs-built_in">push_back</span>(number1);<br>                point1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(number2&lt;number1)&#123;<br>                result1.<span class="hljs-built_in">push_back</span>(number2);<br>                point2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(point1&lt;n1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = point1; i&lt;n1; i++)&#123;<br>                result2.<span class="hljs-built_in">push_back</span>(nums1[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(point2&lt;n2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = point2; i&lt;n2; i++)&#123;<br>                result1.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>            &#125;<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(result2);<br>        result.<span class="hljs-built_in">push_back</span>(result1);<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="2-执行逐位运算使字符串相等"><a href="#2-执行逐位运算使字符串相等" class="headerlink" title="2.  执行逐位运算使字符串相等"></a>2.  执行逐位运算使字符串相等</h1><p>给你两个下标从 0 开始的 二元 字符串 s 和 target ，两个字符串的长度均为 n 。你可以对 s 执行下述操作 任意 次：</p><ul><li>选择两个 不同 的下标 i 和 j ，其中 0 &lt;&#x3D; i, j &lt; n 。</li><li>同时，将 s[i] 替换为 (s[i] OR s[j]) ，s[j] 替换为 (s[i] XOR s[j]) 。<br>例如，如果 s &#x3D; “0110” ，你可以选择 i &#x3D; 0 和 j &#x3D; 2，然后同时将 s[0] 替换为 (s[0] OR s[2] &#x3D; 0 OR 1 &#x3D; 1)，并将 s[2] 替换为 (s[0] XOR s[2] &#x3D; 0 XOR 1 &#x3D; 1)，最终得到 s &#x3D; “1110” 。</li></ul><p>如果可以使 s 等于 target ，返回 true ，否则，返回 false 。<br><img src="/img/%E6%89%A7%E8%A1%8C%E9%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makeStringsEqual</span><span class="hljs-params">(string s, string target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; s_map;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; target_map;<br>        <span class="hljs-type">bool</span> flag;<br><br>        s_map[<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-number">0</span>;<br>        s_map[<span class="hljs-string">&#x27;1&#x27;</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            s_map[s[i]]++;<br>            target_map[target[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s==target || (target_map[<span class="hljs-string">&#x27;1&#x27;</span>]&amp;&amp;s_map[<span class="hljs-string">&#x27;1&#x27;</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-矩阵中的幸运数"><a href="#3-矩阵中的幸运数" class="headerlink" title="3. 矩阵中的幸运数"></a>3. 矩阵中的幸运数</h1><p>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数 是指矩阵中满足同时下列两个条件的元素：</p><ul><li>在同一行的所有元素中最小</li><li>在同一列的所有元素中最大<br><img src="/img/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> column = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">max_list</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, INT_MAX));<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">min_list</span><span class="hljs-params">(column,<span class="hljs-number">0</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;column; j++)&#123;<br>                <span class="hljs-type">int</span> num = matrix[i][j];<br>                <span class="hljs-keyword">if</span>(max_list[i][<span class="hljs-number">0</span>] &gt; num)&#123;<br>                    max_list[i][<span class="hljs-number">0</span>] = num;<br>                    max_list[i][<span class="hljs-number">1</span>] = j;<br>                &#125;<br>                min_list[j] = <span class="hljs-built_in">max</span>(min_list[j], num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-type">int</span> c = max_list[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(max_list[i][<span class="hljs-number">0</span>] == min_list[c] &amp;&amp; max_list[i][<span class="hljs-number">0</span>] == matrix[i][c])&#123;result.<span class="hljs-built_in">push_back</span>(max_list[i][<span class="hljs-number">0</span>]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="4-警告一小时内使用相同员工卡大于等于三次的人"><a href="#4-警告一小时内使用相同员工卡大于等于三次的人" class="headerlink" title="4. 警告一小时内使用相同员工卡大于等于三次的人"></a>4. 警告一小时内使用相同员工卡大于等于三次的人</h1><p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。</p><p>给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。</p><p>使用时间的格式是 24小时制 ，形如 “HH:MM” ，比方说 “23:51” 和 “09:49” 。</p><p>请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。</p><p>请注意 “10:00” - “11:00” 视为一个小时时间范围内，而 “22:51” - “23:52” 不被视为一小时时间范围内。<br><img src="/img/%E8%AD%A6%E5%91%8A%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%91%98%E5%B7%A5%E5%8D%A1%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%89%E6%AC%A1%E7%9A%84%E4%BA%BA.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">alertNames</span><span class="hljs-params">(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        unordered_map&lt;string, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mapping;<br>        <span class="hljs-type">int</span> n = keyName.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> hour;<br>            <span class="hljs-type">int</span> minute;<br>            <br>            hour = <span class="hljs-number">10</span>*(keyTime[i][<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + keyTime[i][<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            minute = <span class="hljs-number">10</span>*(keyTime[i][<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + keyTime[i][<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            minute = (minute + <span class="hljs-number">60</span>*hour);<br>            mapping[keyName[i]].<span class="hljs-built_in">push_back</span>(minute);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mapping.<span class="hljs-built_in">begin</span>(); it!=mapping.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; time_list = it-&gt;second;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">sort</span>(time_list.<span class="hljs-built_in">begin</span>(),time_list.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;time_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-type">int</span> reference = time_list[i];<br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> index = i;<br>                <span class="hljs-keyword">while</span>((i&lt;time_list.<span class="hljs-built_in">size</span>()) &amp;&amp; ((<span class="hljs-built_in">abs</span>(reference-time_list[i]))&lt;=<span class="hljs-number">60</span>))&#123;<br>                    cnt++;<br>                    i++;<br>                &#125;<br>                i = index;<br>                <span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">3</span>)&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;result.<span class="hljs-built_in">push_back</span>(it-&gt;first);&#125;<br>        &#125;<br>        <span class="hljs-comment">//sort(result.begin(),result.end(), [&amp;](string &amp;a, string &amp;b) &#123;return (a[0]-&#x27;a&#x27;)&lt;(b[0]-&#x27;a&#x27;);&#125;);</span><br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-坏了的计算器"><a href="#5-坏了的计算器" class="headerlink" title="5. 坏了的计算器"></a>5. 坏了的计算器</h1><p>在显示着数字 startValue 的坏计算器上，我们可以执行以下两种操作：</p><ul><li>双倍（Double）：将显示屏上的数字乘 2；</li><li>递减（Decrement）：将显示屏上的数字减 1 。<br>给定两个整数 startValue 和 target 。返回显示数字 target 所需的最小操作数。<br><img src="/img/%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">brokenCalc</span><span class="hljs-params">(<span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cycle = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(startValue &lt; target)&#123;<br>            startValue *=<span class="hljs-number">2</span>;<br>            res++;<br>            cycle++;<br>        &#125;<br>        diff = startValue - target;<br>        <span class="hljs-keyword">while</span>(diff != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> d = diff/(<span class="hljs-number">1</span> &lt;&lt; (cycle));<br>            diff -= d*(<span class="hljs-number">1</span> &lt;&lt; (cycle));<br>            cycle = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,cycle<span class="hljs-number">-1</span>);<br>            res += d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;                              <br></code></pre></td></tr></table></figure></li></ul><h1 id="6-最长上传前缀"><a href="#6-最长上传前缀" class="headerlink" title="6. 最长上传前缀"></a>6. 最长上传前缀</h1><p>给你一个 n 个视频的上传序列，每个视频编号为 1 到 n 之间的 不同 数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 最长上传前缀 。</p><p>如果 闭区间 1 到 i 之间的视频全部都已经被上传到服务器，那么我们称 i 是上传前缀。最长上传前缀指的是符合定义的 i 中的 最大值 。</p><p>请你实现 LUPrefix 类：</p><ul><li>LUPrefix(int n) 初始化一个 n 个视频的流对象。</li><li>void upload(int video) 上传 video 到服务器。</li><li>int longest() 返回上述定义的 最长上传前缀 的长度。<br><img src="/img/%E6%9C%80%E9%95%BF%E4%B8%8A%E4%BC%A0%E5%89%8D%E7%BC%80.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LUPrefix</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited;<br>    <span class="hljs-type">int</span> length;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LUPrefix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            visited.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upload</span><span class="hljs-params">(<span class="hljs-type">int</span> video)</span> </span>&#123;<br>        visited[video]=<span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longest</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(length+<span class="hljs-number">1</span>&lt;=n &amp;&amp; visited[length+<span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>)&#123;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LUPrefix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LUPrefix* obj = new LUPrefix(n);</span><br><span class="hljs-comment"> * obj-&gt;upload(video);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;longest();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="7-得到山形数组的最少删除次数"><a href="#7-得到山形数组的最少删除次数" class="headerlink" title="7. 得到山形数组的最少删除次数"></a>7. 得到山形数组的最少删除次数</h1><p>我们定义 arr 是 山形数组 当且仅当它满足：</p><ul><li>arr.length &gt;&#x3D; 3</li><li>存在某个下标 i （从 0 开始） 满足 0 &lt; i &lt; arr.length - 1 且：</li><li><ul><li>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]</li></ul></li><li><ul><li>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给你整数数组 nums​ ，请你返回将 nums 变成 山形状数组 的​ 最少 删除次数。<br><img src="/img/%E5%BE%97%E5%88%B0%E5%B1%B1%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumMountainRemovals</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n)</span>, increase_list</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(increase_list.<span class="hljs-built_in">begin</span>(), increase_list.<span class="hljs-built_in">end</span>(), x);<br>            after[i] = it-increase_list.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(it == increase_list.<span class="hljs-built_in">end</span>())&#123;<br>                increase_list.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                *it = x;<br>            &#125;<br>        &#125;<br>        increase_list.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(increase_list.<span class="hljs-built_in">begin</span>(), increase_list.<span class="hljs-built_in">end</span>(), x);<br>            pre = it-increase_list.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(it == increase_list.<span class="hljs-built_in">end</span>())&#123;<br>                increase_list.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                *it = x;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pre &gt;= <span class="hljs-number">2</span> &amp;&amp; after[i] &gt;=<span class="hljs-number">2</span>)&#123;<br>                result = <span class="hljs-built_in">max</span>(result, pre + after[i] <span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="8-移除石子使总数最小"><a href="#8-移除石子使总数最小" class="headerlink" title="8. 移除石子使总数最小"></a>8. 移除石子使总数最小</h1><p>给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次：</p><ul><li>选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] &#x2F; 2) 颗石子。<br>注意：你可以对 同一堆 石子多次执行此操作。</li></ul><p>返回执行 k 次操作后，剩下石子的 最小 总数。</p><p>floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。<br><img src="/img/%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E4%BD%BF%E6%80%BB%E6%95%B0%E6%9C%80%E5%B0%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minStoneSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(piles.begin(), piles.end())</span></span>;<br><br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> num = pq.<span class="hljs-built_in">top</span>() - pq.<span class="hljs-built_in">top</span>()/<span class="hljs-number">2</span>;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(num);<br>            k--;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>            result += pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day10</title>
    <link href="/2023/12/21/LeetCode/LeetCode-20231221/"/>
    <url>/2023/12/21/LeetCode/LeetCode-20231221/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-执行子串操作后的字典序最小字符串"><a href="#1-执行子串操作后的字典序最小字符串" class="headerlink" title="1. 执行子串操作后的字典序最小字符串"></a>1. 执行子串操作后的字典序最小字符串</h1><p>给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为：</p><ul><li>选择 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，’b’ 用 ‘a’ 替换，’a’ 用 ‘z’ 替换。<br>返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。</li></ul><p>子字符串 是字符串中的一个连续字符序列。</p><p>现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] !&#x3D; y[i] 的第一个位置 i 上，如果  x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。<br><img src="/img/%E6%89%A7%E8%A1%8C%E5%AD%90%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">smallestString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">while</span>(s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; i&lt;n )&#123;<br>                s[i]--;<br>                i++;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-keyword">return</span> s;&#125;<br>        s[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;z&#x27;</span>;<br>        <br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-HTML-实体解析器"><a href="#2-HTML-实体解析器" class="headerlink" title="2.  HTML 实体解析器"></a>2.  HTML 实体解析器</h1><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p><p>HTML 里这些特殊字符和它们对应的字符实体包括：</p><ul><li>双引号：字符实体为 &quot; ，对应的字符是 “ 。</li><li>单引号：字符实体为 &apos; ，对应的字符是 ‘ 。</li><li>与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。</li><li>大于号：字符实体为 &gt; ，对应的字符是 &gt; 。</li><li>小于号：字符实体为 &lt; ，对应的字符是 &lt; 。</li><li>斜线号：字符实体为 &frasl; ，对应的字符是 &#x2F; 。<br>给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。<br>![](&#x2F;img&#x2F;HTML 实体解析器.png)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">entityParser</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        string str = <span class="hljs-string">&quot;&quot;</span>;<br>        unordered_map&lt;string, string&gt; HTML_list = &#123;&#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>,<span class="hljs-string">&quot;\&quot;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;\&#x27;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;text.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string tmp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">int</span> index = i;<br>            <span class="hljs-keyword">if</span>(text[i] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">while</span>(index-i&lt;<span class="hljs-number">7</span> &amp;&amp; index&lt;text.<span class="hljs-built_in">size</span>())&#123;<br>                    tmp += text[index];<br>                    <span class="hljs-keyword">if</span>(text[index] == <span class="hljs-string">&#x27;;&#x27;</span>)&#123;<span class="hljs-keyword">break</span>;&#125; <br>                    index++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(HTML_list.<span class="hljs-built_in">find</span>(tmp) != HTML_list.<span class="hljs-built_in">end</span>())&#123;<br>                    i = index;<br>                    str += HTML_list[tmp];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;str += text[i];&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                str += text[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="3-判断字符串的两半是否相似"><a href="#3-判断字符串的两半是否相似" class="headerlink" title="3. 判断字符串的两半是否相似"></a>3. 判断字符串的两半是否相似</h1><p>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。</p><p>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。</p><p>如果 a 和 b 相似，返回 true ；否则，返回 false 。<br><img src="/img/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E5%8D%8A%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">halvesAreAlike</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; vowel = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            cnt += vowel.<span class="hljs-built_in">count</span>(s[i]);<br>            cnt -= vowel.<span class="hljs-built_in">count</span>(s[i+n]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</span><br></code></pre></td></tr></table></figure><h1 id="4-美丽塔-II"><a href="#4-美丽塔-II" class="headerlink" title="4. 美丽塔 II"></a>4. 美丽塔 II</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。</p><p>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。</p><p>如果以下条件满足，我们称这些塔是 美丽 的：</p><ol><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：</li></ol><ul><li>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]</li><li>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。<br><img src="/img/%E7%BE%8E%E4%B8%BD%E5%A1%94II.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[i] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                sum -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(st.<span class="hljs-built_in">top</span>()-j);<br>            &#125;<br>            sum += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[i]*(st.<span class="hljs-built_in">top</span>()-i);<br>            after[i] = sum;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        st = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[j] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> k = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                pre -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[k]*(k-st.<span class="hljs-built_in">top</span>());<br>            &#125;<br>            pre += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(j-st.<span class="hljs-built_in">top</span>());<br>            result = <span class="hljs-built_in">max</span>(result, pre + after[j+<span class="hljs-number">1</span>]);<br>            st.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day9</title>
    <link href="/2023/12/20/LeetCode/LeetCode-20231220/"/>
    <url>/2023/12/20/LeetCode/LeetCode-20231220/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-最大公因数等于-K-的子数组数目"><a href="#1-最大公因数等于-K-的子数组数目" class="headerlink" title="1. 最大公因数等于 K 的子数组数目"></a>1. 最大公因数等于 K 的子数组数目</h1><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。</p><p>子数组 是数组中一个连续的非空序列。</p><p>数组的最大公因数 是能整除数组中所有元素的最大整数。<br>![](&#x2F;img&#x2F;最大公因数等于 K 的子数组数目.png)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarrayGCD</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left&lt;nums.<span class="hljs-built_in">size</span>(); left++)&#123;<br>            <span class="hljs-type">int</span> num = nums[left];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = left; right&lt;nums.<span class="hljs-built_in">size</span>(); right++)&#123;<br>                num = <span class="hljs-built_in">gcd</span>(num,nums[right]);<br>                <span class="hljs-keyword">if</span>(num == k)&#123;result++;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> tmp = a%b;<br>            a = b;<br>            b =tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-二叉树中的伪回文路径"><a href="#2-二叉树中的伪回文路径" class="headerlink" title="2.  二叉树中的伪回文路径"></a>2.  二叉树中的伪回文路径</h1><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p>请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traceback</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt; p)</span></span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        p[node -&gt;val] ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(node -&gt; left == <span class="hljs-literal">nullptr</span> &amp;&amp; node -&gt; right == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">accumulate</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">1</span>)&#123;res++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res = <span class="hljs-built_in">traceback</span>(node -&gt; left, p) + <span class="hljs-built_in">traceback</span>(node -&gt; right, p);<br>        &#125;<br>        p[node -&gt;val] ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pseudoPalindromicPaths</span> <span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        result = <span class="hljs-built_in">traceback</span>(root, p);<br>     <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-统计无向图中无法互相到达点对数"><a href="#3-统计无向图中无法互相到达点对数" class="headerlink" title="3. 统计无向图中无法互相到达点对数"></a>3. 统计无向图中无法互相到达点对数</h1><p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p><p>请你返回 无法互相到达 的不同 点对数目 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:edges)&#123;<br>            g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>            g[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n)</span></span>;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> input) -&gt; <span class="hljs-type">int</span>&#123;<br>            <span class="hljs-type">int</span> size = <span class="hljs-number">1</span>;<br>            visit[input] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> element:g[input])&#123;<br>                <span class="hljs-keyword">if</span>(!visit[element])&#123;size += <span class="hljs-built_in">dfs</span>(element);&#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> size;<br>        &#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, connected_point = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visit[i])&#123;<br>                <span class="hljs-type">int</span> new_connection = <span class="hljs-built_in">dfs</span>(i);<br>                ans += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) connected_point * new_connection;<br>                connected_point += new_connection;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-表现良好的最长时间段"><a href="#4-表现良好的最长时间段" class="headerlink" title="4. 表现良好的最长时间段"></a>4. 表现良好的最长时间段</h1><p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。<br><img src="/img/%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(hours[i]/<span class="hljs-number">9</span>)&#123;hours[i] = <span class="hljs-number">1</span>;&#125;<br>            <span class="hljs-keyword">else</span>&#123;hours[i] = <span class="hljs-number">-1</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>]+hours[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n; j&gt;i; j--)&#123;<br>                <span class="hljs-keyword">if</span>(presum[j]-presum[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    result = <span class="hljs-built_in">max</span>(result,j-i);<br>                    <span class="hljs-keyword">break</span>;    <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//improve using stack</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>]+ (hours[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">8</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">if</span>(presum[i] &lt; presum[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; presum[i]&gt;presum[st.<span class="hljs-built_in">top</span>()])&#123;<br>                result = <span class="hljs-built_in">max</span>(result, i-st.<span class="hljs-built_in">top</span>());<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-寻找峰值"><a href="#5-寻找峰值" class="headerlink" title="5. 寻找峰值"></a>5. 寻找峰值</h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p><p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。<br><img src="/img/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> middle;<br><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; nums[middle+<span class="hljs-number">1</span>])&#123;<br>                right = middle;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[middle] &lt; nums[middle+<span class="hljs-number">1</span>])&#123;<br>                left = middle +<span class="hljs-number">1</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="6-统计区间中的整数数目"><a href="#6-统计区间中的整数数目" class="headerlink" title="6. 统计区间中的整数数目"></a>6. 统计区间中的整数数目</h1><p>给你区间的 空 集，请你设计并实现满足要求的数据结构：</p><p>新增：添加一个区间到这个区间集合中。<br>统计：计算出现在 至少一个 区间中的整数个数。<br>实现 CountIntervals 类：</p><p>CountIntervals() 使用区间的空集初始化对象<br>void add(int left, int right) 添加区间 [left, right] 到区间集合之中。<br>int count() 返回出现在 至少一个 区间中的整数个数。<br>注意：区间 [left, right] 表示满足 left &lt;&#x3D; x &lt;&#x3D; right 的所有整数 x 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E5%8C%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountIntervals</span> &#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CountIntervals</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = m.<span class="hljs-built_in">lower_bound</span>(left); it!=m.<span class="hljs-built_in">end</span>() &amp;&amp; it -&gt; second &lt;= right; m.<span class="hljs-built_in">erase</span>(it++))&#123;<br>            <span class="hljs-type">int</span> l = it-&gt;second;<br>            <span class="hljs-type">int</span> r = it-&gt;first;<br>            left = <span class="hljs-built_in">min</span>(l, left);<br>            right = <span class="hljs-built_in">max</span>(r,right);<br>            cnt -= r-l+<span class="hljs-number">1</span>;<br>        &#125;<br>        cnt += right-left+<span class="hljs-number">1</span>;<br>        m[right] = left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CountIntervals object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CountIntervals* obj = new CountIntervals();</span><br><span class="hljs-comment"> * obj-&gt;add(left,right);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;count();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inside the C++ Object Model-1</title>
    <link href="/2023/12/18/Inside%20the%20C++%20Object%20Model/Inside%20the%20C++%20Object%20Model-1/"/>
    <url>/2023/12/18/Inside%20the%20C++%20Object%20Model/Inside%20the%20C++%20Object%20Model-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-对象模式"><a href="#C-对象模式" class="headerlink" title="C++对象模式"></a>C++对象模式</h1><span id="more"></span><p>下面是示例代码，以下对于模型的介绍都围绕着示例代码展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> xval);<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Point</span>();<br>    <br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">PointCount</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os)</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-type">float</span> _x;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> _point_count;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1-简单对象模型"><a href="#1-简单对象模型" class="headerlink" title="1. 简单对象模型"></a>1. 简单对象模型</h2><p>正如名字中的简单二字，简单对象模式的设计初衷是为了降低C++编译器的复杂度，其示例代码(参考深入探索C++对象模型)和设计模型如下图。对于简单对象模式，一个对象被分成了许多slot，slot的个数对应于class中member的个数，从上到下按照在class中的申明顺序进行排列。为了适应class中member的不同类型，slot中存放的是执行具体member的指针。在进行member寻址的时候通过slot的索引值来进行查找。<br>优点：降低了C++编译器的设计复杂度。<br>缺点：降低了C++编译器的空间利用率和执行时的效率。</p><h3 id="加上继承"><a href="#加上继承" class="headerlink" title="加上继承"></a>加上继承</h3><p>假设有两个类，base_point和 derived_point，其中base_point为derived_class的父类。那么在简单对象模型中，base_point会被derived_point的一个slot来指出，slot中储存的是base_point的地址。<br>优点：由间接性导致的空间和存取时间上的额外损耗。<br>缺点：derived_point的大小与base_point的大小无关。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p><h2 id="2-表格驱动对象模型"><a href="#2-表格驱动对象模型" class="headerlink" title="2.表格驱动对象模型"></a>2.表格驱动对象模型</h2><p>表格驱动对象模型也被称为双表格模型。相比与上面的简单对象模式，表格驱动模式将class中的data member和 function member 做了一个区分，将它们分别放在Data Member Table和Function Member Table中。由此Point pt就简化为只拥有两个指针的slot,分别指向两个Table. 这里需要注意的一点是data member直接存放在Data Member Table中，而对于Function Member Table可以类比上述的简单对象模型。其中的不同点在于将Poitn pt替换成了Function Member Table并且每个slot所指向的对象只包含function member.<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E8%A1%A8%E6%A0%BC%E9%A9%B1%E5%8A%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p><h3 id="加上继承-1"><a href="#加上继承-1" class="headerlink" title="加上继承"></a>加上继承</h3><p>可以类比于VirtualTable，会产生另一个叫做Base Class Table 的表格。表格中的每个slot都包含一个base class的地址。Derived Class通过一个bptr的指针指向Base Class Table。<br>缺点：由间接性导致的空间和存取时间上的额外损耗。<br>优点：由于每个class在固定位置都会存在一个bptr指针，每一个class对于继承都保持了一致性。由于Base Class Table的存在，做到了与class本身的分离，所以在无需改变class本身的大小就能增加或是减少base class。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/base_class_table.png"></p><h2 id="3-C-对象模型"><a href="#3-C-对象模型" class="headerlink" title="3.C++对象模型"></a>3.C++对象模型</h2><p>从简单模型到C++对象模型经历了内存空间和存取时间上的优化。相比于上面的双表格模型，C++对象模型对calss的member做了更细的划分。<br>1.Nonstatic data members 放在class之中。<br>2.Static data member 放在class之外。<br>3.Static和nonstatic function member放在class之外。<br>根据上面的示例代码可以画出下面的模型图，读者可以根据C++对象模型各种元素的存放规则去图中一一对应。对于Virtual table 中指针分配的顺序是以type_info开始，并以程序中的申明顺序进行排列。对与type_info的解释，读者可以移步至这篇博客<a href="https://www.cnblogs.com/xuelisheng/p/9479288.html">Click to jump</a>，笔者个人觉得对于RTTI机制，type_info, typeid 和dynamic_cast都做了不错的解释。<br>优点：空间和存取时间效率。<br>缺点：对于nonstatic data member的改变需要进行重新编译。<br><img src="/img/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day8</title>
    <link href="/2023/12/17/LeetCode/LeetCode-20231217/"/>
    <url>/2023/12/17/LeetCode/LeetCode-20231217/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-划分数组并满足最大差限制"><a href="#1-划分数组并满足最大差限制" class="headerlink" title="1. 划分数组并满足最大差限制"></a>1. 划分数组并满足最大差限制</h1><p>给你一个长度为 n 的整数数组 nums，以及一个正整数 k 。</p><p>将这个数组划分为一个或多个长度为 3 的子数组，并满足以下条件：</p><p>nums 中的 每个 元素都必须 恰好 存在于某个子数组中。<br>子数组中 任意 两个元素的差必须小于或等于 k 。<br>返回一个 二维数组 ，包含所有的子数组。如果不可能满足条件，就返回一个空数组。如果有多个答案，返回 任意一个 即可。<br><img src="/img/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E5%B9%B6%E6%BB%A1%E8%B6%B3%E6%9C%80%E5%A4%A7%E5%B7%AE%E9%99%90%E5%88%B6.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">divideArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; empty;<br>        <br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> empty;&#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i = i + <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-type">int</span> left = nums[i];<br>            <span class="hljs-type">int</span> middle = nums[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> right = nums[i+<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(right-left&lt;=k)&#123;result.<span class="hljs-built_in">push_back</span>(&#123;left,middle,right&#125;);&#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> empty;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-使数组成为等数数组的最小代价"><a href="#2-使数组成为等数数组的最小代价" class="headerlink" title="2.  使数组成为等数数组的最小代价"></a>2.  使数组成为等数数组的最小代价</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 nums 。</p><p>你可以对 nums 执行特殊操作 任意次 （也可以 0 次）。每一次特殊操作中，你需要 按顺序 执行以下步骤：</p><p>从范围 [0, n - 1] 里选择一个下标 i 和一个 正 整数 x 。<br>将 |nums[i] - x| 添加到总代价里。<br>将 nums[i] 变为 x 。<br>如果一个正整数正着读和反着读都相同，那么我们称这个数是 回文数 。比方说，121 ，2552 和 65756 都是回文数，但是 24 ，46 ，235 都不是回文数。</p><p>如果一个数组中的所有元素都等于一个整数 y ，且 y 是一个小于 109 的 回文数 ，那么我们称这个数组是一个 等数数组 。</p><p>请你返回一个整数，表示执行任意次特殊操作后使 nums 成为 等数数组 的 最小 总代价。<br><img src="/img/%E4%BD%BF%E6%95%B0%E7%BB%84%E6%88%90%E4%B8%BA%E7%AD%89%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> input)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = input; i&lt;= <span class="hljs-number">1000000000</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTrue</span>(i))&#123;<br>                result[<span class="hljs-number">0</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = input; i&gt;=<span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isTrue</span>(i))&#123;<br>                result[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTrue</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> input)</span></span>&#123;<br>        string str = <span class="hljs-built_in">to_string</span>(input);<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(str[left] != str[right])&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minimumCost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">9223372036854775807</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> middle_down = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> middle_up = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> palindrome_number;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; tmp_list;<br>            <br>            middle_up = nums[n/<span class="hljs-number">2</span>];<br>            tmp_list = <span class="hljs-built_in">findNum</span>(middle_up);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;tmp_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(tmp_list[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(tmp_list[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list1;<br>            vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; palindrome_list2;<br>            <br>            middle_down = (nums[n/<span class="hljs-number">2</span>] + nums[(n/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>])/<span class="hljs-number">2</span>;<br>            middle_up = middle_down + <span class="hljs-number">1</span>;<br>            palindrome_list1 = <span class="hljs-built_in">findNum</span>(middle_up);<br>            palindrome_list2 = <span class="hljs-built_in">findNum</span>(middle_down);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(palindrome_list1[i] != palindrome_list2[<span class="hljs-number">0</span>] &amp;&amp; palindrome_list1[i] != palindrome_list2[<span class="hljs-number">1</span>] &amp;&amp; palindrome_list1[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(palindrome_list1[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list2.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(palindrome_list1[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    palindrome_list.<span class="hljs-built_in">push_back</span>(palindrome_list2[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;palindrome_list.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp_result = <span class="hljs-number">0</span>;<br>            <br>                palindrome_number = palindrome_list[i];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                    tmp_result += <span class="hljs-built_in">abs</span>(palindrome_number-nums[j]);<br>                &#125;<br>                result = <span class="hljs-built_in">min</span>(result,tmp_result);  <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="3-执行操作使频率分数最大"><a href="#3-执行操作使频率分数最大" class="headerlink" title="3. 执行操作使频率分数最大"></a>3. 执行操作使频率分数最大</h1><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p><p>你可以对数组执行 至多 k 次操作：</p><p>从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。<br>最终数组的频率分数定义为数组中众数的 频率 。</p><p>请你返回你可以得到的 最大 频率分数。</p><p>众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。<br><img src="/img/%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E9%A2%91%E7%8E%87%E5%88%86%E6%95%B0%E6%9C%80%E5%A4%A7.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxFrequencyScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            presum[i] = presum[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">auto</span> operation_num = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">long</span> <span class="hljs-type">long</span>&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[m]*(m-l) - presum[m] + presum[l];<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = presum[r+<span class="hljs-number">1</span>] - presum[m+<span class="hljs-number">1</span>] - (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)nums[m]*(r-m);<br>            <span class="hljs-keyword">return</span> left + right;<br>        &#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">operation_num</span>(start, (start+i)/<span class="hljs-number">2</span>, i) &gt; k)&#123;<br>                start++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans,i-start+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day7</title>
    <link href="/2023/12/16/LeetCode/LeetCode-20231216/"/>
    <url>/2023/12/16/LeetCode/LeetCode-20231216/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-元素计数"><a href="#1-元素计数" class="headerlink" title="1. 元素计数"></a>1. 元素计数</h1><p>给你一个整数数组 nums ，统计并返回在 nums 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。<br><img src="/img/%E5%85%83%E7%B4%A0%E8%AE%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> right = nums[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != left &amp;&amp; nums[i] != right)&#123;<br>                result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-统计圆内格点数目"><a href="#2-统计圆内格点数目" class="headerlink" title="2.  统计圆内格点数目"></a>2.  统计圆内格点数目</h1><p>给你一个二维整数数组 circles ，其中 circles[i] &#x3D; [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。<br><img src="/img/%E7%BB%9F%E8%AE%A1%E5%9C%86%E5%86%85%E6%A0%BC%E7%82%B9%E6%95%B0%E7%9B%AE.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countLatticePoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; circles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = INT_MAX;<br>        <span class="hljs-type">int</span> right = INT_MIN;<br>        <span class="hljs-type">int</span> up = INT_MIN;<br>        <span class="hljs-type">int</span> down = INT_MAX;<br>        <span class="hljs-type">int</span> n = circles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> cc_x = circles[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> cc_y = circles[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> r = circles[i][<span class="hljs-number">2</span>];<br>            left = <span class="hljs-built_in">min</span>(left, cc_x-r);<br>            right = <span class="hljs-built_in">max</span>(right, cc_x+r);<br>            up = <span class="hljs-built_in">max</span>(up, cc_y+r);<br>            down = <span class="hljs-built_in">min</span>(down, cc_y-r);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i&lt;=right; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = down; j&lt;=up; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index&lt;n; index++)&#123;<br>                    <span class="hljs-type">int</span> x = circles[index][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y = circles[index][<span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> R = circles[index][<span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">if</span>((i-x)*(i-x) + (j-y)*(j-y) &lt;= R*R)&#123;<br>                        result++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-反转二叉树的奇数层"><a href="#3-反转二叉树的奇数层" class="headerlink" title="3. 反转二叉树的奇数层"></a>3. 反转二叉树的奇数层</h1><p>给你一棵 完美 二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。</p><p>例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。<br>反转后，返回树的根节点。</p><p>完美 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p><p>节点的 层数 等于该节点到根节点之间的边数。<br><img src="/img/%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A5%87%E6%95%B0%E5%B1%82.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reverseOddLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-type">bool</span> isOdd = <span class="hljs-literal">false</span>;<br>        <br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;TreeNode*&gt; arr;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>                TreeNode* newnode = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(isOdd)&#123;arr.<span class="hljs-built_in">push_back</span>(newnode);&#125;<br>                <span class="hljs-keyword">if</span>(newnode -&gt; left &amp;&amp; newnode -&gt;right)&#123;<br>                    q.<span class="hljs-built_in">push</span>(newnode -&gt; left);<br>                    q.<span class="hljs-built_in">push</span>(newnode -&gt;right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isOdd)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i = i+<span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-built_in">swap</span>(arr[i] -&gt; val, arr[arr.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>] -&gt; val);<br>                &#125;<br>            &#125;<br>            isOdd ^= <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="4-图中的最短环"><a href="#4-图中的最短环" class="headerlink" title="4. 图中的最短环"></a>4. 图中的最短环</h1><p>现有一个含 n 个顶点的 双向 图，每个顶点按从 0 到 n - 1 标记。图中的边由二维整数数组 edges 表示，其中 edges[i] &#x3D; [ui, vi] 表示顶点 ui 和 vi 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p><p>返回图中 最短 环的长度。如果不存在环，则返回 -1 。</p><p>环 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。<br><img src="/img/%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E7%8E%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findShortestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">num_map</span>(n);<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;edges.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> x = edges[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edges[i][<span class="hljs-number">1</span>];<br>            num_map[x].<span class="hljs-built_in">push_back</span>(y);<br>            num_map[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">bfs</span>(i, n, num_map));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &lt; INT_MAX? ans:<span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br><br>        q.<span class="hljs-built_in">emplace</span>(st,<span class="hljs-number">-1</span>);<br>        count[st] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> [end,start] = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> newend:g[end])&#123;<br>                <span class="hljs-keyword">if</span>(count[newend] &lt; <span class="hljs-number">0</span>)&#123;<br>                    count[newend] = count[end] + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(newend,end);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newend != start)&#123;ans = <span class="hljs-built_in">min</span>(ans,count[end] + count[newend]+<span class="hljs-number">1</span>);&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-待复习</title>
    <link href="/2023/12/15/LeetCode/LeetCode-%E5%BE%85%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/12/15/LeetCode/LeetCode-%E5%BE%85%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-用邮票贴满网格图"><a href="#1-用邮票贴满网格图" class="headerlink" title="1. 用邮票贴满网格图"></a>1. 用邮票贴满网格图</h1><p>给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。</p><p>给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</p><ol><li>覆盖所有 空 格子。</li><li>不覆盖任何 被占据 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 重叠 部分。</li><li>邮票不允许 旋转 。</li><li>邮票必须完全在矩阵 内 。<br>如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。<br><img src="/img/%E7%94%A8%E9%82%AE%E7%A5%A8%E8%B4%B4%E6%BB%A1%E7%BD%91%E6%A0%BC%E5%9B%BE.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleToStamp</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> stampHeight, <span class="hljs-type">int</span> stampWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(m+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                s[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = s[i][j+<span class="hljs-number">1</span>] + s[i+<span class="hljs-number">1</span>][j] - s[i][j]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = stampHeight; i1&lt;=m; i1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = stampWidth; j1&lt;=n; j1++)&#123;<br>                <span class="hljs-type">int</span> i2 = i1-stampHeight+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> j2 = j1-stampWidth+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s[i1][j1] - s[i2<span class="hljs-number">-1</span>][j1] - s[i1][j2<span class="hljs-number">-1</span>] + s[i2<span class="hljs-number">-1</span>][j2<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    d[i2][j2]++;<br>                    d[i1+<span class="hljs-number">1</span>][j2]--;<br>                    d[i2][j1+<span class="hljs-number">1</span>]--;<br>                    d[i1+<span class="hljs-number">1</span>][j1+<span class="hljs-number">1</span>]++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] += d[i][j+<span class="hljs-number">1</span>]+d[i+<span class="hljs-number">1</span>][j] - d[i][j];<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">0</span> &amp;&amp; d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="2-美丽塔-II"><a href="#2-美丽塔-II" class="headerlink" title="2. 美丽塔 II"></a>2. 美丽塔 II</h1><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。</p><p>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。</p><p>如果以下条件满足，我们称这些塔是 美丽 的：</p><ol><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：</li></ol><ul><li>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]</li><li>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。<br>![](&#x2F;img&#x2F;美丽塔 II.png)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">after</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[i] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                sum -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(st.<span class="hljs-built_in">top</span>()-j);<br>            &#125;<br>            sum += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[i]*(st.<span class="hljs-built_in">top</span>()-i);<br>            after[i] = sum;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        st = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; maxHeights[j] &lt; maxHeights[st.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> k = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                pre -= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[k]*(k-st.<span class="hljs-built_in">top</span>());<br>            &#125;<br>            pre += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxHeights[j]*(j-st.<span class="hljs-built_in">top</span>());<br>            result = <span class="hljs-built_in">max</span>(result, pre + after[j+<span class="hljs-number">1</span>]);<br>            st.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day6</title>
    <link href="/2023/12/15/LeetCode/LeetCode-20231215/"/>
    <url>/2023/12/15/LeetCode/LeetCode-20231215/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-子数组和排序后的区间和"><a href="#1-子数组和排序后的区间和" class="headerlink" title="1. 子数组和排序后的区间和"></a>1. 子数组和排序后的区间和</h1><p>给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) &#x2F; 2 个数字的数组。</p><p>请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。<br><img src="/img/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> MODULO = <span class="hljs-number">1000000007</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        result.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                sum += nums[j];<br>                result.<span class="hljs-built_in">push_back</span>(sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left<span class="hljs-number">-1</span>; i&lt;=right<span class="hljs-number">-1</span>; i++)&#123;<br>            res += result[i];<br>            res = res%MODULO;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-将字符串翻转到单调递增"><a href="#2-将字符串翻转到单调递增" class="headerlink" title="2.  将字符串翻转到单调递增"></a>2.  将字符串翻转到单调递增</h1><p>如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。</p><p>给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。</p><p>返回使 s 单调递增的最小翻转次数。<br><img src="/img/%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>];<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>; <br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-使数组元素全部相等的最少操作次数"><a href="#3-使数组元素全部相等的最少操作次数" class="headerlink" title="3. 使数组元素全部相等的最少操作次数"></a>3. 使数组元素全部相等的最少操作次数</h1><p>给你一个正整数数组 nums 。</p><p>同时给你一个长度为 m 的整数数组 queries 。第 i 个查询中，你需要将 nums 中所有元素变成 queries[i] 。你可以执行以下操作 任意 次：</p><p>将数组里一个元素 增大 或者 减小 1 。<br>请你返回一个长度为 m 的数组 answer ，其中 answer[i]是将 nums 中所有元素变成 queries[i] 的 最少 操作次数。</p><p>注意，每次查询后，数组变回最开始的值。<br><img src="/img/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; result;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> breakpoint = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            presum[i+<span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp = queries[i];<br>            breakpoint = <span class="hljs-built_in">findlocation</span>(nums, tmp);<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = breakpoint*tmp - presum[breakpoint];<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = presum[n] - presum[breakpoint+<span class="hljs-number">1</span>]  - (n-breakpoint<span class="hljs-number">-1</span>)*tmp;<br>            result.<span class="hljs-built_in">push_back</span>(left+right + <span class="hljs-built_in">abs</span>(nums[breakpoint] - tmp));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">findlocation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">long</span> <span class="hljs-type">long</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> middle = (left+right)/<span class="hljs-number">2</span>;;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(nums[middle] == target)&#123;<span class="hljs-keyword">return</span> middle;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle] &lt; target)&#123;<br>                left  = middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = middle;<br>            &#125;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> middle;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</span><br></code></pre></td></tr></table></figure><h1 id="4-用邮票贴满网格图"><a href="#4-用邮票贴满网格图" class="headerlink" title="4. 用邮票贴满网格图"></a>4. 用邮票贴满网格图</h1><p>给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。</p><p>给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</p><ol><li>覆盖所有 空 格子。</li><li>不覆盖任何 被占据 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 重叠 部分。</li><li>邮票不允许 旋转 。</li><li>邮票必须完全在矩阵 内 。<br>如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。<br><img src="/img/%E7%94%A8%E9%82%AE%E7%A5%A8%E8%B4%B4%E6%BB%A1%E7%BD%91%E6%A0%BC%E5%9B%BE.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleToStamp</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> stampHeight, <span class="hljs-type">int</span> stampWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(m+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                s[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = s[i][j+<span class="hljs-number">1</span>] + s[i+<span class="hljs-number">1</span>][j] - s[i][j]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = stampHeight; i1&lt;=m; i1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = stampWidth; j1&lt;=n; j1++)&#123;<br>                <span class="hljs-type">int</span> i2 = i1-stampHeight+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> j2 = j1-stampWidth+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s[i1][j1] - s[i2<span class="hljs-number">-1</span>][j1] - s[i1][j2<span class="hljs-number">-1</span>] + s[i2<span class="hljs-number">-1</span>][j2<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    d[i2][j2]++;<br>                    d[i1+<span class="hljs-number">1</span>][j2]--;<br>                    d[i2][j1+<span class="hljs-number">1</span>]--;<br>                    d[i1+<span class="hljs-number">1</span>][j1+<span class="hljs-number">1</span>]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] += d[i][j+<span class="hljs-number">1</span>]+d[i+<span class="hljs-number">1</span>][j] - d[i][j];<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">0</span> &amp;&amp; d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>@版权归LeedCode所有</li></ol>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day5</title>
    <link href="/2023/12/13/LeetCode/LeetCode-20231213/"/>
    <url>/2023/12/13/LeetCode/LeetCode-20231213/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-找出所有行中最小公共元素"><a href="#1-找出所有行中最小公共元素" class="headerlink" title="1. 找出所有行中最小公共元素"></a>1. 找出所有行中最小公共元素</h1><p>给你一个 m x n 的矩阵 mat，其中每一行的元素均符合 严格递增 。请返回 所有行中的 最小公共元素 。</p><p>如果矩阵中没有这样的公共元素，就请返回 -1。<br><img src="/img/%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E8%A1%8C%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%85%AC%E5%85%B1%E5%85%83%E7%B4%A0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">smallestCommonElement</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        result = <span class="hljs-built_in">cycle</span>(<span class="hljs-number">0</span>, mat.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, mat);<br>        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cycle</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<span class="hljs-keyword">return</span> mat[left];&#125;<br>        <span class="hljs-keyword">if</span>(right - left == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">intersection</span>(mat[left], mat[right]);&#125;<br><br>        <span class="hljs-type">int</span> middle = (left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersection</span>(<span class="hljs-built_in">cycle</span>(left, middle, mat), <span class="hljs-built_in">cycle</span>(middle+<span class="hljs-number">1</span>, right, mat));<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; int_mapping;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            int_mapping[a[i]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;b.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(int_mapping.<span class="hljs-built_in">find</span>(b[i]) != int_mapping.<span class="hljs-built_in">end</span>())&#123;result.<span class="hljs-built_in">push_back</span>(b[i]);&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-构成交替字符串需要的最小交换次数"><a href="#2-构成交替字符串需要的最小交换次数" class="headerlink" title="2.  构成交替字符串需要的最小交换次数"></a>2.  构成交替字符串需要的最小交换次数</h1><p>给你一个二进制字符串 s ，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p><p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 “010” 和 “1010” 属于交替字符串，但 “0100” 不是。</p><p>任意两个字符都可以进行交换，不必相邻 。<br><img src="/img/%E6%9E%84%E6%88%90%E4%BA%A4%E6%9B%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; binary_mapping;<br>        vector&lt;<span class="hljs-type">int</span>&gt; continu_1;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        string target1=<span class="hljs-string">&quot;&quot;</span>;<br>        string target2=<span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-number">0</span>;<br>        binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            <span class="hljs-type">char</span> tmp = c;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]++;&#125;<br>            <span class="hljs-keyword">else</span>&#123;binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br><br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">1</span>)&#123;target1 += <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">-1</span>)&#123;target2 += <span class="hljs-string">&#x27;1&#x27;</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i&lt;(binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]+binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>])/<span class="hljs-number">2</span>; i++)&#123;<br>            target1 += <span class="hljs-string">&quot;10&quot;</span>;<br>            target2 += <span class="hljs-string">&quot;01&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">-1</span>)&#123;target1 += <span class="hljs-string">&#x27;1&#x27;</span>;&#125;<br>        <span class="hljs-keyword">if</span>((binary_mapping[<span class="hljs-string">&#x27;0&#x27;</span>]-binary_mapping[<span class="hljs-string">&#x27;1&#x27;</span>]) == <span class="hljs-number">1</span>)&#123;target2 += <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        result = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">binarystr_and</span>(target1, s),<span class="hljs-built_in">binarystr_and</span>(target2, s));<br><br>        result = (result == s.<span class="hljs-built_in">size</span>())?<span class="hljs-number">0</span>:result;<br>        <br>        <span class="hljs-keyword">return</span> result/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarystr_and</span><span class="hljs-params">(string a, string b)</span></span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] != b[i])&#123;result += <span class="hljs-number">1</span>;&#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-完成所有任务的最少初始能量"><a href="#3-完成所有任务的最少初始能量" class="headerlink" title="3. 完成所有任务的最少初始能量"></a>3. 完成所有任务的最少初始能量</h1><p>给你一个任务数组 tasks ，其中 tasks[i] &#x3D; [actuali, minimumi] ：</p><p>actuali 是完成第 i 个任务 需要耗费 的实际能量。<br>minimumi 是开始第 i 个任务前需要达到的最低能量。<br>比方说，如果任务为 [10, 12] 且你当前的能量为 11 ，那么你不能开始这个任务。如果你当前的能量为 13 ，你可以完成这个任务，且完成它后剩余能量为 3 。</p><p>你可以按照 任意顺序 完成任务。</p><p>请你返回完成所有任务的 最少 初始能量。<br><img src="/img/%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%9D%E5%A7%8B%E8%83%BD%E9%87%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumEffort</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = tasks.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <br><br>        <span class="hljs-built_in">sort</span>(tasks.<span class="hljs-built_in">begin</span>(), tasks.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">1</span>]-b[<span class="hljs-number">0</span>];&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            result = <span class="hljs-built_in">max</span>(result+tasks[i][<span class="hljs-number">0</span>],tasks[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOSBox development environment setup</title>
    <link href="/2023/12/12/DOSBox/DOSBox%20development%20environment%20setup/"/>
    <url>/2023/12/12/DOSBox/DOSBox%20development%20environment%20setup/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-Download-DOSBox"><a href="#1-Download-DOSBox" class="headerlink" title="1. Download DOSBox"></a>1. Download DOSBox</h1><p>DosBox download link：<a href="https://sourceforge.net/projects/dosbox/">Click to jump</a><br>DosBox offical link：<a href="https://www.dosbox.com/">Click to jump</a></p><h1 id="2-Download-the-assembly-toolkit"><a href="#2-Download-the-assembly-toolkit" class="headerlink" title="2. Download the assembly toolkit"></a>2. Download the assembly toolkit</h1><p>Download link：<a href="https://github.com/xDarkLemon/DOSBox_MASM/tree/master/masm">Click to jump</a><br>At least 4 files must be included in the toolkit</p><ul><li>masm.exe id the assembler, used to execute the assembly source code (.asm) and obtain the target program (.obj).</li><li>link.exe linkd the program, connect the target program, and get the executable program exe</li><li>debug.exe is the debugger, used to debug executable programs (.exe)</li><li>exe2bin.exe is a post-compiled command line utility available on MS-DOS and other operating systems to convert DOS MZ executable files to COM files</li></ul><h1 id="3-Install-DOSBox"><a href="#3-Install-DOSBox" class="headerlink" title="3.Install DOSBox"></a>3.Install DOSBox</h1><p><img src="/img/Dosbox%E5%AE%89%E8%A3%851.png"><br>Click Next<br><img src="/img/Dosbox%E5%AE%89%E8%A3%852.png"><br>Click Next<br><img src="/img/Dosbox%E5%AE%89%E8%A3%852.png"><br>Here I choose to install to the D drive.</p><p>Note: The selection of the directory here will affect the following instructions to mount the working directory.</p><h1 id="4-Create-a-new-working-directory"><a href="#4-Create-a-new-working-directory" class="headerlink" title="4.Create a new working directory"></a>4.Create a new working directory</h1><p><img src="/img/Dosbox%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"><br>Create a new working directory DOSBox under the D drive, and cut the installed DOSBox-0.74 to the working directory.<br><img src="/img/Dosbox%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%952.png"><br>Open the Debug directory, cut the assembly tool package masm to the directory, and create a new folder ASM to store the assembly program you wrote in the future.</p><h1 id="5-Mount-the-working-directory"><a href="#5-Mount-the-working-directory" class="headerlink" title="5.Mount the working directory"></a>5.Mount the working directory</h1><p>The purpose of mounting the working directory here is to enable dosbox to use masm.exe in the configuration tool package<br><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"></p><ul><li>Open the DOSBox installation directory and find the file DOSBox 0.74 Options.bat</li><li>Add the following command below [autoexec]:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">MOUNT F D:\DOSBox\Debug<br>set PATH=%PATH%;F:\MASM;<br>F:<br>cd F:\ASM<br><br></code></pre></td></tr></table></figure><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%952.png"><br>The purpose of this is to avoid having to manually mount it again every time you use DOSBox.<br><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%953.png"><br>Start DOSBox 0.74.exe, and the following automatic program execution will appear to verify the validity of the second part above.</li></ul><h1 id="5-Change-the-size-of-the-DOSBox-command-window"><a href="#5-Change-the-size-of-the-DOSBox-command-window" class="headerlink" title="5.Change the size of the DOSBox command window"></a>5.Change the size of the DOSBox command window</h1><p><img src="/img/Dosbox%E6%8C%82%E8%BD%BD%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%951.png"><br>Open the DOSBox installation directory and find the file DOSBox 0.74 Options.bat<br><img src="/img/%E6%9B%B4%E6%94%B9DOSBox%E5%91%BD%E4%BB%A4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F.png"><br>Find the above code block, change the output to ddraw, and windowresolution to the specific size of the command window. Change it according to your own habits. Here the author chose 1200x640 as the size of the command window.</p><p>Note: x in 1200x640 is a lowercase letter x</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Environment Setup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day4</title>
    <link href="/2023/12/12/LeetCode/LeetCode-20231212/"/>
    <url>/2023/12/12/LeetCode/LeetCode-20231212/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-罗马数字转整数"><a href="#1-罗马数字转整数" class="headerlink" title="1. 罗马数字转整数"></a>1. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。<br><img src="/img/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; roam_mapping = &#123;&#123;<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>&#125;,&#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>&#125;,&#123;<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>&#125;,&#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>&#125;&#125;;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> roam_mapping[s[<span class="hljs-number">0</span>]];&#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ; i++)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-number">5</span>*roam_mapping[s[i]] == roam_mapping[s[i+<span class="hljs-number">1</span>]]) || (<span class="hljs-number">10</span>*roam_mapping[s[i]] == roam_mapping[s[i+<span class="hljs-number">1</span>]]))&#123;<br>                result = result + roam_mapping[s[i+<span class="hljs-number">1</span>]]-roam_mapping[s[i]];<br>                i++;<br>                <span class="hljs-keyword">if</span>(i == s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;flag = <span class="hljs-literal">true</span>;&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                result +=roam_mapping[s[i]];<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)&#123;result+=roam_mapping[s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]];&#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-列举单词的全部缩写"><a href="#2-列举单词的全部缩写" class="headerlink" title="2.  列举单词的全部缩写"></a>2.  列举单词的全部缩写</h1><p>单词的 广义缩写词 可以通过下述步骤构造：先取任意数量的 不重叠、不相邻 的子字符串，再用它们各自的长度进行替换。</p><p>例如，”abcde” 可以缩写为：<br>“a3e”（”bcd” 变为 “3” ）<br>“1bcd1”（”a” 和 “e” 都变为 “1”）<br>“5” (“abcde” 变为 “5”)<br>“abcde” (没有子字符串被代替)<br>然而，这些缩写是 无效的 ：<br>“23”（”ab” 变为 “2” ，”cde” 变为 “3” ）是无效的，因为被选择的字符串是相邻的<br>“22de” (“ab” 变为 “2” ， “bc” 变为 “2”)  是无效的，因为被选择的字符串是重叠的<br>给你一个字符串 word ，返回 一个由 word 的所有可能 广义缩写词 组成的列表 。按 任意顺序 返回答案。<br><img src="/img/%E5%88%97%E4%B8%BE%E5%8D%95%E8%AF%8D%E7%9A%84%E5%85%A8%E9%83%A8%E7%BC%A9%E5%86%99.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateAbbreviations</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-built_in">traceback</span>(word,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> i, string tmp, <span class="hljs-type">int</span> cnt)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i == word.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>)&#123;tmp += <span class="hljs-built_in">to_string</span>(cnt);&#125;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp, cnt+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp + <span class="hljs-built_in">to_string</span>(cnt) + word[i], <span class="hljs-number">0</span>);&#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">traceback</span>(word, i+<span class="hljs-number">1</span>, tmp+ word[i], <span class="hljs-number">0</span>);&#125;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br><img src="/img/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        map&lt;<span class="hljs-type">int</span>, string&gt; strs_mapping;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>        <br><br>        <span class="hljs-keyword">if</span>(strs.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];&#125;<br>        <span class="hljs-built_in">sort</span>(strs.<span class="hljs-built_in">begin</span>(), strs.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> string&amp; a,<span class="hljs-type">const</span> string&amp; b)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>();&#125;);<br>        string smallest_str = strs[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">while</span>(index&lt;strs.<span class="hljs-built_in">size</span>())&#123;<br>            result = <span class="hljs-built_in">CommonStr</span>(smallest_str, strs[index]);<br>            <span class="hljs-keyword">if</span>(result == <span class="hljs-string">&quot;&quot;</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            smallest_str = result;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">CommonStr</span><span class="hljs-params">(string a, string b)</span></span>&#123;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;a.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] == b[i])&#123;<br>                result += a[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-下一个更大元素-IV"><a href="#4-下一个更大元素-IV" class="headerlink" title="4. 下一个更大元素 IV"></a>4. 下一个更大元素 IV</h1><p>给你一个下标从 0 开始的非负整数数组 nums 。对于 nums 中每一个整数，你必须找到对应元素的 第二大 整数。</p><p>如果 nums[j] 满足以下条件，那么我们称它为 nums[i] 的 第二大 整数：</p><p>j &gt; i<br>nums[j] &gt; nums[i]<br>恰好存在 一个 k 满足 i &lt; k &lt; j 且 nums[k] &gt; nums[i] 。<br>如果不存在 nums[j] ，那么第二大整数为 -1 。</p><p>比方说，数组 [1, 2, 4, 3] 中，1 的第二大整数是 4 ，2 的第二大整数是 3 ，3 和 4 的第二大整数是 -1 。<br>请你返回一个整数数组 answer ，其中 answer[i]是 nums[i] 的第二大整数。<br><img src="/img/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0_IV.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">secondGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; first_st, second_st;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; tmp;<br>            <span class="hljs-keyword">while</span>(!second_st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&gt;second_st.<span class="hljs-built_in">top</span>().second)&#123;<br>                result[second_st.<span class="hljs-built_in">top</span>().first] = nums[i];<br>                second_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!first_st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&gt;first_st.<span class="hljs-built_in">top</span>().second)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(first_st.<span class="hljs-built_in">top</span>());<br>                first_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!tmp.<span class="hljs-built_in">empty</span>())&#123;<br>                second_st.<span class="hljs-built_in">push</span>(tmp.<span class="hljs-built_in">back</span>());<br>                tmp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            first_st.<span class="hljs-built_in">push</span>(&#123;i,nums[i]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day3</title>
    <link href="/2023/12/11/LeetCode/LeetCode-20231211/"/>
    <url>/2023/12/11/LeetCode/LeetCode-20231211/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-去除重复字母"><a href="#1-去除重复字母" class="headerlink" title="1. 去除重复字母"></a>1. 去除重复字母</h1><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br><img src="/img/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alpha_list</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left_list</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; result;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            alpha_list[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        result.<span class="hljs-built_in">push</span>(s[<span class="hljs-number">0</span>]);<br>        alpha_list[s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        left_list[s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-built_in">i</span>&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> s_num = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!result.<span class="hljs-built_in">empty</span>() &amp;&amp;(left_list[s_num]))&#123;<br>                alpha_list[s_num]--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!result.<span class="hljs-built_in">empty</span>() &amp;&amp; (result.<span class="hljs-built_in">top</span>() - <span class="hljs-string">&#x27;a&#x27;</span>)&gt;(s_num) &amp;&amp; alpha_list[result.<span class="hljs-built_in">top</span>()-<span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                left_list[result.<span class="hljs-built_in">top</span>()-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                result.<span class="hljs-built_in">pop</span>();   <br>            &#125;   <br>            <span class="hljs-keyword">if</span>(left_list[s_num])&#123;<span class="hljs-keyword">continue</span>;&#125;<br>            alpha_list[s_num]--;<br>            result.<span class="hljs-built_in">push</span>(s[i]);<br>            left_list[s_num]++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!result.<span class="hljs-built_in">empty</span>())&#123;<br>            res += result.<span class="hljs-built_in">top</span>();<br>            result.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-二叉树的垂直遍历"><a href="#2-二叉树的垂直遍历" class="headerlink" title="2.  二叉树的垂直遍历"></a>2.  二叉树的垂直遍历</h1><p>给你一个二叉树的根结点，返回其结点按 垂直方向（从上到下，逐列）遍历的结果。<br>如果两个结点在同一行和列，那么顺序则为 从左到右。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E7%9B%B4%E9%81%8D%E5%8E%86.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(rides.<span class="hljs-built_in">begin</span>(), rides.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];&#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(rides.size()+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt; rides.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> st = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ed = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> tip = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(rides.<span class="hljs-built_in">begin</span>(),rides.<span class="hljs-built_in">begin</span>()+i, st+<span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> val) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt; val;&#125;);<br>            <span class="hljs-type">int</span> j = <span class="hljs-built_in">distance</span>(rides.<span class="hljs-built_in">begin</span>(), it);<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[j]+ed-st+tip);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rides.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-最大单词长度乘积"><a href="#3-最大单词长度乘积" class="headerlink" title="3. 最大单词长度乘积"></a>3. 最大单词长度乘积</h1><p>给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。<br><img src="/img/%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">masks</span><span class="hljs-params">(words.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;words.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string str = words[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s:str)&#123;<br>                masks[i] |= <span class="hljs-number">1</span> &lt;&lt; (s - <span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;words.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j&lt;words.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>((masks[i] &amp; masks[j]) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-type">int</span> tmp = words[i].<span class="hljs-built_in">size</span>()*words[j].<span class="hljs-built_in">size</span>();<br>                    result = <span class="hljs-built_in">max</span>(result,tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p>给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。<br><img src="/img/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kelement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(index1 == m)&#123;<br>                <span class="hljs-keyword">return</span> nums2[index2+k<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(index2 == n)&#123;<br>                <span class="hljs-keyword">return</span> nums1[index1+k<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[index1], nums2[index2]);<br>            &#125;<br>            <span class="hljs-type">int</span> newindex1 = <span class="hljs-built_in">min</span>(m<span class="hljs-number">-1</span>,index1+k/<span class="hljs-number">2</span><span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> newindex2 = <span class="hljs-built_in">min</span>(n<span class="hljs-number">-1</span>,index2+k/<span class="hljs-number">2</span><span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> val1 = nums1[newindex1];<br>            <span class="hljs-type">int</span> val2 = nums2[newindex2];<br>            <span class="hljs-keyword">if</span>(val1&lt;=val2)&#123;<br>                k -= newindex1-index1+<span class="hljs-number">1</span>;<br>                index1 = newindex1+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                k -= newindex2-index2+<span class="hljs-number">1</span>;<br>                index2 = newindex2+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> total = m+n;<br><br>        <span class="hljs-keyword">if</span>(total%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">kelement</span>(nums1,nums2,(total+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> ((<span class="hljs-built_in">kelement</span>(nums1,nums2,(total)/<span class="hljs-number">2</span>)+<span class="hljs-built_in">kelement</span>(nums1,nums2,(total)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))/<span class="hljs-number">2.0</span>);<br>        &#125;<br>        <br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p>]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL Sources Learning-1</title>
    <link href="/2023/12/09/STL/STL%20Sources%20Learning-1/"/>
    <url>/2023/12/09/STL/STL%20Sources%20Learning-1/</url>
    
    <content type="html"><![CDATA[<h1 id="查看GCC对各种C-特性的支持程度"><a href="#查看GCC对各种C-特性的支持程度" class="headerlink" title="查看GCC对各种C++特性的支持程度"></a>查看GCC对各种C++特性的支持程度</h1><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span> defined(__sgi)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;__sgi&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span> defined(__GNUC__)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;__GNUC__&quot;</span> &lt;&lt;endl;<br>    cout &lt;&lt; __GNUC__ &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;__GNUC_MINOR__&lt;&lt;endl;<br>    <span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 2</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NO_DRAND48</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_DRAND48 defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_DRAND48 undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 3</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_STATIC_TEMPLATE_MEMBER_BUG</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 4</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_CLASS_PARTIAL_SPECIALIZATION</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 5</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_EXPLICIT_FUNCTION_TMPL_ARGS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_EXPLICIT_FUNCTION_TMPL_ARGS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 6</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_MEMBER_TEMPLATES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_MEMBER_TEMPLATES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_MEMBER_TEMPLATES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 7</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_LIMITED_DEFAULT_TEMPLATES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_LIMITED_DEFAULT_TEMPLATES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_LIMITED_DEFAULT_TEMPLATES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 8</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NON_TYPE_TMPL_PARAM_BUG</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NON_TYPE_TMPL_PARAM_BUG defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NON_TYPE_TMPL_PARAM_BUG undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 9</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __SGI_STL_NO_ARROW_OPERATOR</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__SGI_STL_NO_ARROW_OPERATOR defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__SGI_STL_NO_ARROW_OPERATOR undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 10</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_USE_EXCEPTIONS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_EXCEPTIONS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_EXCEPTIONS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 11</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_USE_NAMESPACES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_NAMESPACES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_USE_NAMESPACES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 12</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_SGI_THREADS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_SGI_THREADS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_SGI_THREADS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 13</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_WIN32THREADS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_WIN32THREADS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_WIN32THREADS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 14</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NO_NAMESPACES</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_NAMESPACES defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NO_NAMESPACES undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 15</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_TYPENAME</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_TYPENAME defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_TYPENAME undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 16</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_BOOL</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_BOOL defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_BOOL undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 17</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_NEED_EXPLICIT</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_EXPLICIT defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_NEED_EXPLICIT undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//case 18</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __STL_ASSERTIONS</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_ASSERTIONS defined&quot;</span> &lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cout &lt;&lt; <span class="hljs-string">&quot;__STL_ASSERTIONS undefined&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day2</title>
    <link href="/2023/12/09/LeetCode/LeetCode-20231209/"/>
    <url>/2023/12/09/LeetCode/LeetCode-20231209/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-下一个更大的数值平衡数"><a href="#1-下一个更大的数值平衡数" class="headerlink" title="1. 下一个更大的数值平衡数"></a>1. 下一个更大的数值平衡数</h1><p>如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。<br>给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalance</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (x&gt;<span class="hljs-number">0</span>)&#123;<br>            count[x%<span class="hljs-number">10</span>]++;<br>            x = x/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count[i] != i)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n+<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">1224444</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBalance</span>(i))&#123;<span class="hljs-keyword">return</span> i;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-出租车的最大盈利"><a href="#2-出租车的最大盈利" class="headerlink" title="2.  出租车的最大盈利"></a>2.  出租车的最大盈利</h1><p>你驾驶出租车行驶在一条有 n 个地点的路上。这 n 个地点从近到远编号为 1 到 n ，你想要从 1 开到 n ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。<br>乘客信息用一个下标从 0 开始的二维数组 rides 表示，其中 rides[i] &#x3D; [starti, endi, tipi] 表示第 i 位乘客需要从地点 starti 前往 endi ，愿意支付 tipi 元的小费。<br>每一位 你选择接单的乘客 i ，你可以 盈利 endi - starti + tipi 元。你同时 最多 只能接一个订单。<br>给你 n 和 rides ，请你返回在最优接单方案下，你能盈利 最多 多少元。<br>注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(rides.<span class="hljs-built_in">begin</span>(), rides.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];&#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(rides.size()+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt; rides.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> st = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ed = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> tip = rides[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(rides.<span class="hljs-built_in">begin</span>(),rides.<span class="hljs-built_in">begin</span>()+i, st+<span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> val) &#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt; val;&#125;);<br>            <span class="hljs-type">int</span> j = <span class="hljs-built_in">distance</span>(rides.<span class="hljs-built_in">begin</span>(), it);<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[j]+ed-st+tip);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rides.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="3-超级丑数"><a href="#3-超级丑数" class="headerlink" title="3. 超级丑数"></a>3. 超级丑数</h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。<br>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。<br>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthSuperUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; primes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = primes.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">long</span>&gt; result;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">primes_list</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> start_point= <span class="hljs-number">0</span>;<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">long</span> primes_min = INT_MAX;<br>            <span class="hljs-type">long</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;m; j++)&#123;<br>                tmp = result[primes_list[j]]*primes[j];<br>                <span class="hljs-keyword">if</span>(tmp &gt; result.<span class="hljs-built_in">back</span>())&#123;<br>                    <span class="hljs-keyword">if</span>(tmp &lt; primes_min)&#123;<br>                        primes_min = tmp;<br>                        flag = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(primes_min);<br>            primes_list[flag]++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>                <span class="hljs-keyword">if</span>(i != flag &amp;&amp; result[primes_list[i]]*primes[i] == primes_min)&#123;<br>                    primes_list[i]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>@版权归LeedCode所有</p><!--版权归LeedCode所有-->]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-Day1</title>
    <link href="/2023/12/08/LeetCode/LeetCode-20231208/"/>
    <url>/2023/12/08/LeetCode/LeetCode-20231208/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-买卖股票的最佳时机含手续费"><a href="#1-买卖股票的最佳时机含手续费" class="headerlink" title="1. 买卖股票的最佳时机含手续费"></a>1. 买卖股票的最佳时机含手续费</h1><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> buy = -prices[<span class="hljs-number">0</span>]-fee;<br>        <span class="hljs-type">int</span> sell = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> newbuy = <span class="hljs-built_in">max</span>(buy, sell-prices[i]-fee);<br>            <span class="hljs-type">int</span> newsell = <span class="hljs-built_in">max</span>(sell, buy+prices[i]);<br>            buy = newbuy;<br>            sell = newsell;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-买卖芯片的最佳时机数组"><a href="#2-买卖芯片的最佳时机数组" class="headerlink" title="2. 买卖芯片的最佳时机数组"></a>2. 买卖芯片的最佳时机数组</h1><p>prices 记录了某芯片近期的交易价格，其中 prices[i] 表示的 i 天该芯片的价格。你只能选择 某一天 买入芯片，并选择在 未来的某一个不同的日子 卖出该芯片。请设计一个算法计算并返回你从这笔交易中能获取的最大利润。<br>如果你不能获取任何利润，返回 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestTiming</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> smallest = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;prices.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(smallest &lt; prices[i]) result = <span class="hljs-built_in">max</span>(result, prices[i]-smallest);<br>            <span class="hljs-keyword">else</span> smallest = prices[i]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-稀疏矩阵的乘法"><a href="#3-稀疏矩阵的乘法" class="headerlink" title="3. 稀疏矩阵的乘法"></a>3. 稀疏矩阵的乘法</h1><p>给定两个 稀疏矩阵 ：大小为 m x k 的稀疏矩阵 mat1 和大小为 k x n 的稀疏矩阵 mat2 ，返回 mat1 x mat2 的结果。你可以假设乘法总是可能的<br><img src="/img/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">multiply</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat2) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; newmat2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;mat2[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;mat2.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(mat2[i][j]);<br>            &#125;<br>            newmat2.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;mat1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt;tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;newmat2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k&lt;mat1[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); k++)&#123;<br>                    value += mat1[i][k]*newmat2[j][k];<br>                &#125;<br>                tmp.<span class="hljs-built_in">push_back</span>(value);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br>@版权归LeedCode所有<br><br></code></pre></td></tr></table></figure><!--版权归LeedCode所有-->]]></content>
    
    
    <categories>
      
      <category>Daily Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
