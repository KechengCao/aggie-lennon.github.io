

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Aggie Lennon">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++ DataStructure interview">
<meta property="og:type" content="article">
<meta property="og:title" content="C++_DataStructure_interview_master">
<meta property="og:url" content="http://example.com/2024/02/26/Interview/C++_DataStructure_interview_master/index.html">
<meta property="og:site_name" content="Aggie Lennon&#39;s Blog">
<meta property="og:description" content="C++ DataStructure interview">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-26T09:45:09.000Z">
<meta property="article:modified_time" content="2024-03-03T02:47:01.443Z">
<meta property="article:author" content="Aggie Lennon">
<meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++_DataStructure_interview_master - Aggie Lennon&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">C++_DataStructure_interview_master</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-26 17:45" pubdate>
          2024年2月26日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++_DataStructure_interview_master</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C-DataStructure-interview"><a href="#C-DataStructure-interview" class="headerlink" title="C++ DataStructure interview"></a>C++ DataStructure interview</h1><span id="more"></span>
<p>@列表分类参考<a target="_blank" rel="noopener" href="https://github.com/EndlessCheng/codeforces-go?tab=readme-ov-file">灵茶山艾府</a></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在C++中，栈（Stack）是一个后进先出（LIFO）的数据结构，可以使用标准模板库（STL）中的<stack>头文件中定义的stack类来实现。</p>
<h4 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h4><p>待补</p>
<h4 id="栈的底层实现"><a href="#栈的底层实现" class="headerlink" title="栈的底层实现"></a>栈的底层实现</h4><p>在 C++ 中，栈（Stack）通常是用一个动态数组或链表实现的。C++ 标准模板库（STL）中的 std::stack 容器适配器默认情况下是使用 std::deque 实现的，但它也可以配置为使用 std::vector 或 std::list。</p>
<h4 id="C-vector实现栈"><a href="#C-vector实现栈" class="headerlink" title="C++ vector实现栈"></a>C++ vector实现栈</h4><p>栈的实现可以通过动态数组（如vector）、链表或其他容器实现。以下是一个使用vector作为底层数据结构的栈实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;T&gt; elems; <span class="hljs-comment">// 使用vector作为底层容器</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; elem)</span> </span>&#123; <span class="hljs-comment">// 入栈</span><br>        elems.<span class="hljs-built_in">push_back</span>(elem);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 出栈</span><br>        <span class="hljs-keyword">if</span> (elems.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>);<br>        &#125;<br>        elems.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 查看栈顶元素</span><br>        <span class="hljs-keyword">if</span> (elems.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 检查栈是否为空</span><br>        <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 返回栈的大小</span><br>        <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="栈的种类"><a href="#栈的种类" class="headerlink" title="栈的种类"></a>栈的种类</h4><p>不同种类的栈主要是基于它们的 <strong>实现细节</strong> 和 <strong>用途</strong> 来区分的。</p>
<h5 id="顺序栈（Array-Stack）（待建立超链接）"><a href="#顺序栈（Array-Stack）（待建立超链接）" class="headerlink" title="顺序栈（Array Stack）（待建立超链接）"></a>顺序栈（Array Stack）（待建立超链接）</h5><ul>
<li>使用数组实现的栈。</li>
<li>有固定大小，可能需要手动管理数组的扩容。</li>
<li>提供快速的访问时间，因为它允许随机访问(数据可以以任意顺序被快速访问，而不需要按照顺序逐个查找)。</li>
<li>由于是连续内存，所以可能会有空间浪费。</li>
</ul>
<h5 id="链式栈-Linked-Stack-待建立超链接"><a href="#链式栈-Linked-Stack-待建立超链接" class="headerlink" title="链式栈(Linked Stack)(待建立超链接)"></a>链式栈(Linked Stack)(待建立超链接)</h5><ul>
<li>使用链表实现的栈。</li>
<li>大小可动态变化，不需要手动扩容。</li>
<li>访问时间较慢，因为需要通过指针遍历,属于顺序访问(为了读取特定数据，需要从起点开始按顺序查找直到找到所需信息)。</li>
<li>空间利用效率更高，没有空间浪费。</li>
</ul>
<h5 id="动态栈-Dynamic-Stack-待建立超链接"><a href="#动态栈-Dynamic-Stack-待建立超链接" class="headerlink" title="动态栈(Dynamic Stack)(待建立超链接)"></a>动态栈(Dynamic Stack)(待建立超链接)</h5><ul>
<li>可以无限增长的栈。</li>
<li>通常是基于数组实现的，但会在需要时自动扩容。</li>
</ul>
<h5 id="寄存器栈-Register-Stack-待建立超链接"><a href="#寄存器栈-Register-Stack-待建立超链接" class="headerlink" title="寄存器栈(Register Stack)(待建立超链接)"></a>寄存器栈(Register Stack)(待建立超链接)</h5><ul>
<li>直接使用CPU寄存器来实现的栈。</li>
<li>非常快速，但空间有限。</li>
</ul>
<h5 id="栈机-Stack-Machine-待建立超链接"><a href="#栈机-Stack-Machine-待建立超链接" class="headerlink" title="栈机(Stack Machine)(待建立超链接)"></a>栈机(Stack Machine)(待建立超链接)</h5><ul>
<li>一种计算模型，它的主要数据结构是栈，例如Java虚拟机中的操作数栈。<br /></li>
</ul>
<h3 id="高频问题"><a href="#高频问题" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-解释栈和队列的区别"><a href="#1-解释栈和队列的区别" class="headerlink" title="1. 解释栈和队列的区别"></a>1. 解释栈和队列的区别</h4><ul>
<li>栈是一种后进先出的数据结构，而队列是一种先进先出的数据结构。</li>
</ul>
<h4 id="2-给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配"><a href="#2-给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配" class="headerlink" title="2. 给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配"></a>2. 给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配</h4><ul>
<li>遍历字符串，对于每个开括号，将其压入栈中。对于每个闭括号，检查栈顶元素是否为对应的开括号，如果是，则弹出栈顶元素；如果不是或栈为空，则括号不匹配。最终，如果栈为空，则括号匹配。</li>
</ul>
<h4 id="3-如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素"><a href="#3-如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素" class="headerlink" title="3. 如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素"></a>3. 如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素</h4><ul>
<li>使用两个栈：一个存储所有元素，另一个仅存储每个状态下的最小元素。每次入栈操作时，如果元素小于或等于“最小栈”的栈顶元素，也将其压入“最小栈”。出栈时，如果“主栈”的栈顶元素等于“最小栈”的栈顶元素，则同时从“最小栈”中弹出。</li>
</ul>
<h4 id="4-解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值"><a href="#4-解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值" class="headerlink" title="4. 解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值"></a>4. 解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值</h4><ul>
<li>逆波兰表达式是一种算术表达式，其中运算符跟随其操作数。使用栈计算其值时，从左到右扫描表达式，遇到数字就压入栈中，遇到运算符就从栈中弹出两个元素进行计算，计算结果再压入栈中。最后，栈顶元素即为表达式的值。</li>
</ul>
<h4 id="5-如何使用栈对一个数组进行排序"><a href="#5-如何使用栈对一个数组进行排序" class="headerlink" title="5. 如何使用栈对一个数组进行排序"></a>5. 如何使用栈对一个数组进行排序</h4><ul>
<li>使用两个栈，一个作为输入栈，另一个作为空栈用于排序。重复以下过程：从输入栈中弹出一个元素，然后将排序栈中所有比它大的元素移回输入栈，直到找到适当的位置将该元素压入排序栈中。最终，排序栈中的元素即为排序后的数组。</li>
</ul>
<h4 id="6-给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素"><a href="#6-给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素" class="headerlink" title="6. 给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素"></a>6. 给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素</h4><ul>
<li>遍历数组，对于每个元素，如果栈不为空且当前元素大于栈顶元素，则栈顶元素的右侧第一个更大元素就是当前元素。重复此过程直到栈为空或当前元素小于栈顶元素，然后将当前元素压入栈中。对于栈中剩余的元素，它们的右侧没有更大的元素。<br />
<br /></li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>队列（Queue）是一种先进先出（First In First Out, FIFO）的数据结构，它允许元素在队列的末尾位置被添加，并从队列的开始位置被移除。这种排队方式类似于现实生活中的队列——第一个加入队列的人也将是第一个得到服务并离开的人。</p>
<h4 id="图像表示-1"><a href="#图像表示-1" class="headerlink" title="图像表示"></a>图像表示</h4><p>待补</p>
<h4 id="队列的底层实现"><a href="#队列的底层实现" class="headerlink" title="队列的底层实现"></a>队列的底层实现</h4><p>在C++标准模板库（STL）中，queue是一个容器适配器，它给予程序员队列的功能。默认情况下，queue使用deque来实现，但也可以配置为使用list。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h4><p>在C++中实现一个队列可以通过多种方式完成，包括使用数组、链表、或者直接利用标准模板库（STL）中的容器如queue。这里，我将展示如何使用链表来手动实现一个简单的队列。</p>
<h4 id="数组版"><a href="#数组版" class="headerlink" title="数组版"></a>数组版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> front, rear, capacity;<br>    <span class="hljs-type">int</span>* queue;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Queue</span>(<span class="hljs-type">int</span> c) &#123;<br>        front = rear = <span class="hljs-number">0</span>;<br>        capacity = c;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Queue</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] queue;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to insert an element at the rear of the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == rear) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is full\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            queue[rear] = data;<br>            rear++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to delete an element from the front of the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (front == rear) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is empty\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rear - <span class="hljs-number">1</span>; i++) &#123;<br>                queue[i] = queue[i + <span class="hljs-number">1</span>];<br>            &#125;<br>            rear--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to print the elements of the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (front == rear) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is empty\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = front; i &lt; rear; i++) &#123;<br>            cout &lt;&lt; queue[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="链表版"><a href="#链表版" class="headerlink" title="链表版"></a>链表版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> d) : <span class="hljs-built_in">data</span>(d), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Node *front, *rear;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Queue</span>() &#123;<br>        front = rear = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Queue</span>() &#123;<br>        <span class="hljs-keyword">while</span> (front != <span class="hljs-literal">nullptr</span>) &#123;<br>            Node* temp = front;<br>            front = front-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to add an element to the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        <span class="hljs-keyword">if</span> (rear == <span class="hljs-literal">nullptr</span>) &#123;<br>            front = rear = temp;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        rear-&gt;next = temp;<br>        rear = temp;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to remove an element from queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is empty\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node* temp = front;<br>        front = front-&gt;next;<br>        <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>) &#123;<br>            rear = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to display the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* temp = front;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            temp = temp-&gt;next;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="队列的种类"><a href="#队列的种类" class="headerlink" title="队列的种类"></a>队列的种类</h4><p>队列有多种类型，根据其特性和应用场景的不同</p>
<h5 id="线性队列（待建立超链接）"><a href="#线性队列（待建立超链接）" class="headerlink" title="线性队列（待建立超链接）"></a>线性队列（待建立超链接）</h5><p>线性队列：最基本的队列类型，遵循FIFO原则。</p>
<h5 id="循环队列（待建立超链接）"><a href="#循环队列（待建立超链接）" class="headerlink" title="循环队列（待建立超链接）"></a>循环队列（待建立超链接）</h5><p>循环队列：是一种使用固定大小的数组的线性数据结构，头尾相连形成环状。当队列满时，新元素的插入将回到数组的开始位置（如果那里有空间）。</p>
<h5 id="优先队列（待建立超链接）"><a href="#优先队列（待建立超链接）" class="headerlink" title="优先队列（待建立超链接）"></a>优先队列（待建立超链接）</h5><p>优先队列：在这种队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先被移除。优先队列不遵循FIFO原则。</p>
<h5 id="双端队列（待建立超链接）"><a href="#双端队列（待建立超链接）" class="headerlink" title="双端队列（待建立超链接）"></a>双端队列（待建立超链接）</h5><p>双端队列：双端队列是一个允许我们从两端插入和删除的队列。</p>
<h5 id="阻塞队列（待建立超链接）"><a href="#阻塞队列（待建立超链接）" class="headerlink" title="阻塞队列（待建立超链接）"></a>阻塞队列（待建立超链接）</h5><p>阻塞队列：通常用于线程间的协作，当队列为空时，从队列中获取元素的操作将会阻塞，直到有元素加入；同样，如果队列满了，添加元素的操作也会阻塞。</p>
<h5 id="并发队列（待建立超链接）"><a href="#并发队列（待建立超链接）" class="headerlink" title="并发队列（待建立超链接）"></a>并发队列（待建立超链接）</h5><p>并发队列：在多线程程序中使用，可以安全地允许多个线程同时从队列中添加或移除元素。<br><br /></p>
<h3 id="高频问题-1"><a href="#高频问题-1" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-解释队列和栈的区别"><a href="#1-解释队列和栈的区别" class="headerlink" title="1. 解释队列和栈的区别"></a>1. 解释队列和栈的区别</h4><ul>
<li>队列是一种先进先出（FIFO）的数据结构，而栈是一种后进先出（LIFO）的数据结构。</li>
</ul>
<h4 id="2-如何使用两个栈实现一个队列"><a href="#2-如何使用两个栈实现一个队列" class="headerlink" title="2. 如何使用两个栈实现一个队列"></a>2. 如何使用两个栈实现一个队列</h4><ul>
<li>使用两个栈，一个栈用于入队操作，另一个栈用于出队操作。当进行出队操作时，如果第二个栈为空，则将第一个栈中的所有元素弹出并压入第二个栈中，然后从第二个栈中弹出顶部元素。</li>
</ul>
<h4 id="3-如何使用队列实现栈"><a href="#3-如何使用队列实现栈" class="headerlink" title="3. 如何使用队列实现栈"></a>3. 如何使用队列实现栈</h4><ul>
<li>使用两个队列，一个队列用于存储栈的所有元素。对于“入栈”操作，将元素加入空队列中，然后将另一个队列中的所有元素依次出队并入队到这个队列中。这样新加入的元素就位于队列的前端，模拟了栈的顶端。对于“出栈”操作，直接从队列前端移除元素即可。</li>
</ul>
<h4 id="4-解释优先队列及其实现"><a href="#4-解释优先队列及其实现" class="headerlink" title="4. 解释优先队列及其实现"></a>4. 解释优先队列及其实现</h4><ul>
<li>优先队列是一种特殊类型的队列，其中每个元素都有一个优先级。元素被按优先级的顺序移除，而不是它们被添加到队列的顺序。优先队列通常用堆数据结构来实现，以支持高效的插入和删除最高（或最低）优先级元素的操作。</li>
</ul>
<h4 id="5-如何在不使用队列数据结构的情况下反转队列的前k个元素"><a href="#5-如何在不使用队列数据结构的情况下反转队列的前k个元素" class="headerlink" title="5. 如何在不使用队列数据结构的情况下反转队列的前k个元素"></a>5. 如何在不使用队列数据结构的情况下反转队列的前k个元素</h4><ul>
<li>可以使用一个栈和另一个队列来实现。首先，将队列的前k个元素依次出队并压入栈中，然后从栈中弹出所有元素并依次入队，最后将队列的剩余元素移动到队列前端，以保持它们的原始顺序。<br />
<br /></li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="基础概念-2"><a href="#基础概念-2" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>堆（Heap）是一种特殊的完全二叉树，主要用于实现优先队列。堆的特点是树中每个父节点的值都具有特定的顺序关系（大于或小于）与其子节点的值，这种顺序关系在整个树中一致。</p>
<h4 id="图像表示-2"><a href="#图像表示-2" class="headerlink" title="图像表示"></a>图像表示</h4><p>待补</p>
<h4 id="堆的底层实现"><a href="#堆的底层实现" class="headerlink" title="堆的底层实现"></a>堆的底层实现</h4><p>堆通常使用数组来实现。对于堆中的任意节点i，其左子节点的索引为2i+1，右子节点的索引为2i+2，父节点的索引为(i-1)&#x2F;2（这里假设数组的起始索引为0）。这种表示方法使得堆的操作可以高效地在数组上执行，而无需使用指针或其他数据结构。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h4><h5 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeap</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; heap; <span class="hljs-comment">// 使用vector来存储堆元素</span><br><br>    <span class="hljs-comment">// 获取给定索引的左孩子索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>; &#125;<br><br>    <span class="hljs-comment">// 获取给定索引的右孩子索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">2</span>; &#125;<br><br>    <span class="hljs-comment">// 获取给定索引的父节点索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-type">int</span> child)</span> </span>&#123; <span class="hljs-keyword">return</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; &#125;<br><br>    <span class="hljs-comment">// 从给定索引向上调整堆，以维护最大堆性质</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapifyUp</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; heap[<span class="hljs-built_in">parent</span>(index)] &lt; heap[index]) &#123;<br>            std::<span class="hljs-built_in">swap</span>(heap[<span class="hljs-built_in">parent</span>(index)], heap[index]);<br>            index = <span class="hljs-built_in">parent</span>(index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从给定索引向下调整堆，以维护最大堆性质</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapifyDown</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-type">int</span> largest = index;<br>        <span class="hljs-type">int</span> leftChild = <span class="hljs-built_in">left</span>(index);<br>        <span class="hljs-type">int</span> rightChild = <span class="hljs-built_in">right</span>(index);<br><br>        <span class="hljs-keyword">if</span> (leftChild &lt; heap.<span class="hljs-built_in">size</span>() &amp;&amp; heap[leftChild] &gt; heap[largest])<br>            largest = leftChild;<br>        <span class="hljs-keyword">if</span> (rightChild &lt; heap.<span class="hljs-built_in">size</span>() &amp;&amp; heap[rightChild] &gt; heap[largest])<br>            largest = rightChild;<br><br>        <span class="hljs-keyword">if</span> (largest != index) &#123;<br>            std::<span class="hljs-built_in">swap</span>(heap[index], heap[largest]);<br>            <span class="hljs-built_in">heapifyDown</span>(largest);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 插入元素到堆中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span> </span>&#123;<br>        heap.<span class="hljs-built_in">push_back</span>(element);<br>        <span class="hljs-built_in">heapifyUp</span>(heap.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 将新加入的元素向上调整到合适位置</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除并返回堆中的最大元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteMax</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Heap is empty&quot;</span>);<br>        <span class="hljs-type">int</span> max = heap[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 堆顶元素即最大元素</span><br>        heap[<span class="hljs-number">0</span>] = heap.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 将最后一个元素移动到堆顶</span><br>        heap.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除最后一个元素</span><br>        <span class="hljs-built_in">heapifyDown</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 从堆顶向下调整堆</span><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印堆中的所有元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : heap) std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinHeap</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; heap;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">2</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-type">int</span> child)</span> </span>&#123; <span class="hljs-keyword">return</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapifyUp</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; heap[<span class="hljs-built_in">parent</span>(index)] &gt; heap[index]) &#123;<br>            std::<span class="hljs-built_in">swap</span>(heap[<span class="hljs-built_in">parent</span>(index)], heap[index]);<br>            index = <span class="hljs-built_in">parent</span>(index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapifyDown</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-type">int</span> smallest = index;<br>        <span class="hljs-type">int</span> leftChild = <span class="hljs-built_in">left</span>(index);<br>        <span class="hljs-type">int</span> rightChild = <span class="hljs-built_in">right</span>(index);<br><br>        <span class="hljs-keyword">if</span> (leftChild &lt; heap.<span class="hljs-built_in">size</span>() &amp;&amp; heap[leftChild] &lt; heap[smallest])<br>            smallest = leftChild;<br>        <span class="hljs-keyword">if</span> (rightChild &lt; heap.<span class="hljs-built_in">size</span>() &amp;&amp; heap[rightChild] &lt; heap[smallest])<br>            smallest = rightChild;<br><br>        <span class="hljs-keyword">if</span> (smallest != index) &#123;<br>            std::<span class="hljs-built_in">swap</span>(heap[index], heap[smallest]);<br>            <span class="hljs-built_in">heapifyDown</span>(smallest);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span> </span>&#123;<br>        heap.<span class="hljs-built_in">push_back</span>(element);<br>        <span class="hljs-built_in">heapifyUp</span>(heap.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Heap is empty&quot;</span>);<br>        <span class="hljs-type">int</span> min = heap[<span class="hljs-number">0</span>];<br>        heap[<span class="hljs-number">0</span>] = heap.<span class="hljs-built_in">back</span>();<br>        heap.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-built_in">heapifyDown</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : heap) std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="堆的种类（待建立超链接）"><a href="#堆的种类（待建立超链接）" class="headerlink" title="堆的种类（待建立超链接）"></a>堆的种类（待建立超链接）</h4><h5 id="最大堆-1"><a href="#最大堆-1" class="headerlink" title="最大堆"></a>最大堆</h5><ul>
<li>最大堆（Max Heap）：在最大堆中，任何一个父节点的值都大于或等于它的子节点的值。这意味着堆的根节点包含了堆中的最大值。</li>
</ul>
<h5 id="最小堆-1"><a href="#最小堆-1" class="headerlink" title="最小堆"></a>最小堆</h5><ul>
<li>最小堆（Min Heap）：在最小堆中，任何一个父节点的值都小于或等于它的子节点的值。这意味着堆的根节点包含了堆中的最小值。<br /></li>
</ul>
<h3 id="高频问题-2"><a href="#高频问题-2" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="解释最大堆和最小堆的区别"><a href="#解释最大堆和最小堆的区别" class="headerlink" title="解释最大堆和最小堆的区别"></a>解释最大堆和最小堆的区别</h4><ul>
<li>在最大堆中，任何一个父节点的值都大于或等于它的子节点的值，根节点是堆中的最大值。在最小堆中，任何一个父节点的值都小于或等于它的子节点的值，根节点是堆中的最小值。</li>
</ul>
<h4 id="如何将一个未排序的数组构建成一个堆"><a href="#如何将一个未排序的数组构建成一个堆" class="headerlink" title="如何将一个未排序的数组构建成一个堆"></a>如何将一个未排序的数组构建成一个堆</h4><ul>
<li>可以通过从最后一个非叶子节点开始，向根节点逐个进行下沉调整（对于最大堆）或上浮调整（对于最小堆），直到堆的性质满足为止。这个过程称为堆化（Heapify）</li>
</ul>
<h4 id="解释堆排序算法-加链接"><a href="#解释堆排序算法-加链接" class="headerlink" title="解释堆排序算法(加链接)"></a>解释堆排序算法(加链接)</h4><ul>
<li>堆排序算法是一种原地排序算法，利用最大堆（或最小堆）的性质进行排序。首先将数组构建成一个最大堆，然后将根节点（即最大值）与数组最后一个元素交换，之后减少堆的大小并重新堆化，重复这个过程直到堆的大小为1。</li>
</ul>
<h4 id="如何找到一个”运行中”数据流的中位数"><a href="#如何找到一个”运行中”数据流的中位数" class="headerlink" title="如何找到一个”运行中”数据流的中位数"></a>如何找到一个”运行中”数据流的中位数</h4><ul>
<li>可以使用两个堆，一个最大堆来存储数据流的较小一半，一个最小堆来存储数据流的较大一半。数据流中的每个新元素根据与两个堆顶元素的比较结果，被插入到适当的堆中。如果两个堆的大小不同，可以通过移动元素来平衡它们。中位数可以通过比较两个堆的大小来计算，如果大小相同，则中位数是两个堆顶元素的平均值；如果不同，则中位数是较大堆的堆顶元素。</li>
</ul>
<h4 id="如何处理堆中的删除操作"><a href="#如何处理堆中的删除操作" class="headerlink" title="如何处理堆中的删除操作"></a>如何处理堆中的删除操作</h4><ul>
<li>要删除堆中的任意元素（通常是堆顶元素），可以将它与堆的最后一个元素交换，然后移除最后一个元素（现在存储着被删除的值）。之后，对新的堆顶元素执行下沉调整（对于最大堆）或上浮调整（对于最小堆），以恢复堆的性质。</li>
</ul>
<h4 id="在最小堆中，如何增加任意一个元素的值"><a href="#在最小堆中，如何增加任意一个元素的值" class="headerlink" title="在最小堆中，如何增加任意一个元素的值"></a>在最小堆中，如何增加任意一个元素的值</h4><ul>
<li>首先直接增加元素的值，然后对该元素执行下沉调整（因为增加元素的值可能破坏了堆的性质），确保所有的父节点都小于它们的子节点。</li>
</ul>
<h4 id="给定n个元素，找出其中的第k大元素"><a href="#给定n个元素，找出其中的第k大元素" class="headerlink" title="给定n个元素，找出其中的第k大元素"></a>给定n个元素，找出其中的第k大元素</h4><ul>
<li>使用最小堆来解决这个问题。首先将数组的前k个元素构建成最小堆。然后遍历剩余的元素，对于每个元素，如果它大于堆顶元素，则将堆顶元素替换为该元素。通过这种方式，堆始终保持最大的k个元素，且堆的大小保持为k。由于这是一个最小堆，堆顶元素（即最小元素）实际上是这k个最大元素中的“最小者”，也就是第k大的元素。<br />
<br /></li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="基础概念-3"><a href="#基础概念-3" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>并查集（Disjoint Set Union，简称DSU）是一种数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。它支持两种基本操作：查找（Find）和合并（Union）。</p>
<h4 id="图像表示-3"><a href="#图像表示-3" class="headerlink" title="图像表示"></a>图像表示</h4><p>待补</p>
<h4 id="堆的底层实现-1"><a href="#堆的底层实现-1" class="headerlink" title="堆的底层实现"></a>堆的底层实现</h4><p>并查集可以通过数组实现，每个元素都有一个指向父节点的链接，根节点的父节点指向它自己，这样形成了一个或多个树形结构。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++实现"></a>C++实现</h4><ul>
<li>初始化：开始时，每个元素都是自己唯一的集合的代表，即每个元素都是一个单独的树的根。</li>
<li>查找：为了找到元素的代表（即根节点），我们沿着父节点的链接一直向上移动，直到找到根节点，根节点是其自己的父节点的节点。为了优化性能，实现时通常会使用路径压缩技术，即在执行查找操作的过程中，将树的深度减小，使得后续的查找操作更高效。</li>
<li>合并：为了合并两个集合，首先找到它们各自的根节点，然后将一个根节点连接到另一个根节点上。为了优化性能，合并时通常会考虑两棵树的大小或高度（称为按秩合并），总是将较小或较低的树连接到较大或较高的树上。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; parent; <span class="hljs-comment">// 存储每个元素的父节点</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; rank; <span class="hljs-comment">// 存储每个根节点的树的高度</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数初始化并查集</span><br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> size) : <span class="hljs-built_in">parent</span>(size), <span class="hljs-built_in">rank</span>(size, <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 初始化时，每个元素的父节点指向它自己，每个元素都是一个独立的集合</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找操作，返回元素x的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 路径压缩优化：在查找的过程中，将沿途的每个节点直接连接到根节点</span><br>        <span class="hljs-comment">// 这样可以减少后续查找操作的路径长度</span><br>        <span class="hljs-keyword">if</span> (parent[x] != x) &#123;<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]); <span class="hljs-comment">// 递归查找x的根节点，并进行路径压缩</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    在这段代码中，find函数的目的是找到某个元素x的根节点。当我们调用find(x)时，如果x不是它自己的父节点（即parent[x] != x），这意味着x不是根节点，它有一个指向另一个节点的父节点链接。在这种情况下，我们递归地调用find(parent[x])来找到x的根节点。</span><br><span class="hljs-comment">    关键的优化在于，当递归调用返回后，我们将x的父节点直接设置为它的根节点（parent[x] = find(parent[x])）。这样做的结果是，在x到根节点的路径上的每个节点都直接连接到根节点上，大大减少了路径长度。</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 合并操作，将元素x和元素y所在的集合合并</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSets</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootX = <span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 查找x的根节点</span><br>        <span class="hljs-type">int</span> rootY = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// 查找y的根节点</span><br>        <span class="hljs-keyword">if</span> (rootX != rootY) &#123; <span class="hljs-comment">// 如果x和y不在同一个集合中</span><br>            <span class="hljs-comment">// 按秩合并优化：总是将较低高度的树连接到较高的树上</span><br>            <span class="hljs-keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;<br>                parent[rootX] = rootY; <span class="hljs-comment">// 将x的根节点连接到y的根节点上</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;<br>                parent[rootY] = rootX; <span class="hljs-comment">// 将y的根节点连接到x的根节点上</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果两棵树高度相同，则选择一个作为根，并增加其高度</span><br>                parent[rootY] = rootX;<br>                rank[rootX] += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<br /></li>
</ul>
<h3 id="高频问题-3"><a href="#高频问题-3" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="并查集的基本操作有哪些"><a href="#并查集的基本操作有哪些" class="headerlink" title="并查集的基本操作有哪些"></a>并查集的基本操作有哪些</h4><ul>
<li>解释并查集支持的两个基本操作：查找（Find）和联合（Union）。查找操作用于确定某个元素所在的集合（即找到该元素的根节点），而联合操作用于将两个元素所在的集合合并为一个。</li>
</ul>
<h4 id="如何实现并查集"><a href="#如何实现并查集" class="headerlink" title="如何实现并查集"></a>如何实现并查集</h4><ul>
<li>包括使用数组（或向量）存储每个元素的父节点，以及如何通过递归或迭代实现查找操作。还应该提及路径压缩和按秩合并这两种优化技术。</li>
</ul>
<h4 id="什么是路径压缩，它如何优化并查集的性能"><a href="#什么是路径压缩，它如何优化并查集的性能" class="headerlink" title="什么是路径压缩，它如何优化并查集的性能"></a>什么是路径压缩，它如何优化并查集的性能</h4><ul>
<li>路径压缩是在执行查找操作时，将查找路径上的每个节点直接连接到根节点，从而减少后续操作的路径长度。这种优化可以显著减少查找操作的平均复杂度。</li>
</ul>
<h4 id="解释按秩合并"><a href="#解释按秩合并" class="headerlink" title="解释按秩合并"></a>解释按秩合并</h4><ul>
<li>按秩合并是在执行联合操作时，总是将较小的树连接到较大的树上，以避免树的不必要增长。”秩”通常表示树的高度或大小，这种方法可以帮助保持树的平衡，提高操作效率。</li>
</ul>
<h4 id="并查集可以用来解决哪些问题"><a href="#并查集可以用来解决哪些问题" class="headerlink" title="并查集可以用来解决哪些问题"></a>并查集可以用来解决哪些问题</h4><h5 id="动态连通性问题"><a href="#动态连通性问题" class="headerlink" title="动态连通性问题"></a>动态连通性问题</h5><ul>
<li>在网络、社交网络、图论等领域，我们经常需要判断任意两个节点是否属于同一个连通分量，或者需要将两个分开的连通分量合并成一个。并查集能够在几乎常数时间内完成这些操作，非常适合处理这类问题。</li>
</ul>
<h5 id="岛屿数量问题"><a href="#岛屿数量问题" class="headerlink" title="岛屿数量问题"></a>岛屿数量问题</h5><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的二维网格，计算网格中岛屿的数量。岛屿被水包围，并且它是通过水平或垂直连接相邻的陆地形成的。你可以假设网格的四个边界都被水包围。通过并查集，我们可以遍历每个陆地单元格，将相邻的陆地单元格合并，最终得到岛屿的数量。</p>
<h5 id="朋友圈问题"><a href="#朋友圈问题" class="headerlink" title="朋友圈问题"></a>朋友圈问题</h5><p>在朋友圈问题中，有一些人形成了不同的朋友圈（即连通分量）。问题可能会要求计算朋友圈的数量或者判断两个人是否在同一个朋友圈。通过并查集，我们可以快速合并朋友圈并进行查询。</p>
<h4 id="并查集中查找操作的时间复杂度是多少"><a href="#并查集中查找操作的时间复杂度是多少" class="headerlink" title="并查集中查找操作的时间复杂度是多少"></a>并查集中查找操作的时间复杂度是多少</h4><ul>
<li>详细解释在未优化和使用路径压缩优化后，查找操作的平均时间复杂度。通常，未优化的并查集查找操作的时间复杂度接近O(logn)，而使用路径压缩优化后，几乎可以达到O(1)的平均时间复杂度。<br />
<br /></li>
</ul>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="稀疏表"><a href="#稀疏表" class="headerlink" title="稀疏表"></a>稀疏表</h2><p>待填<br><br /><br><br /></p>
<br />
<br />

<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>待填<br><br /><br><br /></p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>待填<br><br /><br><br /></p>
<h2 id="0-1-线段树"><a href="#0-1-线段树" class="headerlink" title="0-1 线段树"></a>0-1 线段树</h2><p>待填<br><br /><br><br /></p>
<h2 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h2><p>待填<br><br /><br><br /></p>
<h2 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h2><p>待填<br><br /><br><br /></p>
<h2 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h2><p>待填<br><br /><br><br /></p>
<h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><p>待填<br><br /><br><br /></p>
<h2 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h2><p>待填<br><br /><br><br /></p>
<h2 id="k-d-树"><a href="#k-d-树" class="headerlink" title="k-d 树"></a>k-d 树</h2><p>待填<br><br /><br><br /></p>
<h2 id="珂朵莉树"><a href="#珂朵莉树" class="headerlink" title="珂朵莉树"></a>珂朵莉树</h2><p>待填<br><br /><br><br /></p>
<h2 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h2><p>待填<br><br /><br><br /><br><br /></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><br />
<br />

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><br />
<br />

<h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><br />
<br />

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><br />
<br />

<h2 id="回文自动机"><a href="#回文自动机" class="headerlink" title="回文自动机"></a>回文自动机</h2><br />
<br />

<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><br />
<br />

<h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><br />
<br />

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><br />
<br />

<h2 id="0-1-字典树"><a href="#0-1-字典树" class="headerlink" title="0-1 字典树"></a>0-1 字典树</h2><br />
<br />

<h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><br />
<br />

<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><h3 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h3><h3 id="质因数分解算法"><a href="#质因数分解算法" class="headerlink" title="质因数分解算法"></a>质因数分解算法</h3><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><h3 id="扩展-GCD"><a href="#扩展-GCD" class="headerlink" title="扩展 GCD"></a>扩展 GCD</h3><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><h3 id="大步小步算法"><a href="#大步小步算法" class="headerlink" title="大步小步算法"></a>大步小步算法</h3><h3 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h3><h3 id="Jacobi-符号"><a href="#Jacobi-符号" class="headerlink" title="Jacobi 符号"></a>Jacobi 符号</h3><h3 id="N-次剩余"><a href="#N-次剩余" class="headerlink" title="N 次剩余"></a>N 次剩余</h3><h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><h3 id="默慈金数"><a href="#默慈金数" class="headerlink" title="默慈金数"></a>默慈金数</h3><h3 id="那罗延数"><a href="#那罗延数" class="headerlink" title="那罗延数"></a>那罗延数</h3><h3 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h3><h3 id="贝尔数"><a href="#贝尔数" class="headerlink" title="贝尔数"></a>贝尔数</h3><h3 id="欧拉数"><a href="#欧拉数" class="headerlink" title="欧拉数"></a>欧拉数</h3><h3 id="数论分块（整除分块）"><a href="#数论分块（整除分块）" class="headerlink" title="数论分块（整除分块）"></a>数论分块（整除分块）</h3><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><h3 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h3><br />
<br />

<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h3><h3 id="常用恒等式"><a href="#常用恒等式" class="headerlink" title="常用恒等式"></a>常用恒等式</h3><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><br />
<br />

<h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><br />

<h2 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h2><br />

<h2 id="快速沃尔什变换"><a href="#快速沃尔什变换" class="headerlink" title="快速沃尔什变换"></a>快速沃尔什变换</h2><br />

<h2 id="连分数、佩尔方程"><a href="#连分数、佩尔方程" class="headerlink" title="连分数、佩尔方程"></a>连分数、佩尔方程</h2><br />

<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="矩阵相关运算"><a href="#矩阵相关运算" class="headerlink" title="矩阵相关运算"></a>矩阵相关运算</h3><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><h3 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h3><br />
<br />

<h2 id="数值分析"><a href="#数值分析" class="headerlink" title="数值分析"></a>数值分析</h2><h3 id="自适应辛普森积分"><a href="#自适应辛普森积分" class="headerlink" title="自适应辛普森积分"></a>自适应辛普森积分</h3><h3 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h3><br />
<br />

<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="线与点"><a href="#线与点" class="headerlink" title="线与点"></a>线与点</h3><h3 id="线与线"><a href="#线与线" class="headerlink" title="线与线"></a>线与线</h3><h3 id="圆与点"><a href="#圆与点" class="headerlink" title="圆与点"></a>圆与点</h3><h3 id="圆与线"><a href="#圆与线" class="headerlink" title="圆与线"></a>圆与线</h3><h3 id="圆与圆"><a href="#圆与圆" class="headerlink" title="圆与圆"></a>圆与圆</h3><h3 id="圆与矩形"><a href="#圆与矩形" class="headerlink" title="圆与矩形"></a>圆与矩形</h3><h3 id="最近点对"><a href="#最近点对" class="headerlink" title="最近点对"></a>最近点对</h3><h3 id="多边形与点"><a href="#多边形与点" class="headerlink" title="多边形与点"></a>多边形与点</h3><h4 id="判断点在凸多边形内"><a href="#判断点在凸多边形内" class="headerlink" title="判断点在凸多边形内"></a>判断点在凸多边形内</h4><h4 id="判断点在任意多边形内"><a href="#判断点在任意多边形内" class="headerlink" title="判断点在任意多边形内"></a>判断点在任意多边形内</h4><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><h3 id="最远点对"><a href="#最远点对" class="headerlink" title="最远点对"></a>最远点对</h3><h4 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h4><h3 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h3><br />
<br />

<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h3><br />
<br />
<br />

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><h3 id="树上背包（依赖背包）"><a href="#树上背包（依赖背包）" class="headerlink" title="树上背包（依赖背包）"></a>树上背包（依赖背包）</h3><h3 id="字典序最小方案"><a href="#字典序最小方案" class="headerlink" title="字典序最小方案"></a>字典序最小方案</h3><br />
<br />

<h2 id="线性-DP"><a href="#线性-DP" class="headerlink" title="线性 DP"></a>线性 DP</h2><h3 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h3><h3 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h3><h3 id="LPS"><a href="#LPS" class="headerlink" title="LPS"></a>LPS</h3><h3 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h3><h3 id="LCIS"><a href="#LCIS" class="headerlink" title="LCIS"></a>LCIS</h3><h3 id="长度为-m-的-LIS-个数"><a href="#长度为-m-的-LIS-个数" class="headerlink" title="长度为 m 的 LIS 个数"></a>长度为 m 的 LIS 个数</h3><h3 id="本质不同子序列个数"><a href="#本质不同子序列个数" class="headerlink" title="本质不同子序列个数"></a>本质不同子序列个数</h3><br />
<br />

<h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><br />

<h2 id="环形-DP"><a href="#环形-DP" class="headerlink" title="环形 DP"></a>环形 DP</h2><br />

<h2 id="博弈-DP"><a href="#博弈-DP" class="headerlink" title="博弈 DP"></a>博弈 DP</h2><br />

<h2 id="概率-DP"><a href="#概率-DP" class="headerlink" title="概率 DP"></a>概率 DP</h2><br />

<h2 id="期望-DP"><a href="#期望-DP" class="headerlink" title="期望 DP"></a>期望 DP</h2><br />

<h2 id="状压-DP"><a href="#状压-DP" class="headerlink" title="状压 DP"></a>状压 DP</h2><h3 id="全排列-DP"><a href="#全排列-DP" class="headerlink" title="全排列 DP"></a>全排列 DP</h3><h3 id="旅行商问题（TSP）"><a href="#旅行商问题（TSP）" class="headerlink" title="旅行商问题（TSP）"></a>旅行商问题（TSP）</h3><h3 id="子集-DP"><a href="#子集-DP" class="headerlink" title="子集 DP"></a>子集 DP</h3><h3 id="高维前缀和（SOS-DP）"><a href="#高维前缀和（SOS-DP）" class="headerlink" title="高维前缀和（SOS DP）"></a>高维前缀和（SOS DP）</h3><h3 id="插头-DP"><a href="#插头-DP" class="headerlink" title="插头 DP"></a>插头 DP</h3><br />
<br />

<h2 id="数位-DP"><a href="#数位-DP" class="headerlink" title="数位 DP"></a>数位 DP</h2><br />

<h2 id="倍增优化-DP"><a href="#倍增优化-DP" class="headerlink" title="倍增优化 DP"></a>倍增优化 DP</h2><br />

<h2 id="斜率优化-DP（CHT）"><a href="#斜率优化-DP（CHT）" class="headerlink" title="斜率优化 DP（CHT）"></a>斜率优化 DP（CHT）</h2><br />

<h2 id="WQS-二分优化-DP（凸优化-DP-带权二分）"><a href="#WQS-二分优化-DP（凸优化-DP-带权二分）" class="headerlink" title="WQS 二分优化 DP（凸优化 DP &#x2F; 带权二分）"></a>WQS 二分优化 DP（凸优化 DP &#x2F; 带权二分）</h2><br />

<h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><h3 id="树的直径个数"><a href="#树的直径个数" class="headerlink" title="树的直径个数"></a>树的直径个数</h3><h3 id="在任一直径上的节点个数"><a href="#在任一直径上的节点个数" class="headerlink" title="在任一直径上的节点个数"></a>在任一直径上的节点个数</h3><h3 id="树上最大独立集"><a href="#树上最大独立集" class="headerlink" title="树上最大独立集"></a>树上最大独立集</h3><h3 id="树上最小顶点覆盖"><a href="#树上最小顶点覆盖" class="headerlink" title="树上最小顶点覆盖"></a>树上最小顶点覆盖</h3><h3 id="树上最小支配集"><a href="#树上最小支配集" class="headerlink" title="树上最小支配集"></a>树上最小支配集</h3><h3 id="树上最大匹配"><a href="#树上最大匹配" class="headerlink" title="树上最大匹配"></a>树上最大匹配</h3><h3 id="换根-DP（二次扫描法）"><a href="#换根-DP（二次扫描法）" class="headerlink" title="换根 DP（二次扫描法）"></a>换根 DP（二次扫描法）</h3><br />
<br />
<br />

<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><br />

<h2 id="DFS-常用技巧"><a href="#DFS-常用技巧" class="headerlink" title="DFS 常用技巧"></a>DFS 常用技巧</h2><br />

<h2 id="BFS-常用技巧"><a href="#BFS-常用技巧" class="headerlink" title="BFS 常用技巧"></a>BFS 常用技巧</h2><br />

<h2 id="欧拉回路和欧拉路径"><a href="#欧拉回路和欧拉路径" class="headerlink" title="欧拉回路和欧拉路径"></a>欧拉回路和欧拉路径</h2><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><br />

<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><h2 id="割边（桥）"><a href="#割边（桥）" class="headerlink" title="割边（桥）"></a>割边（桥）</h2><h2 id="双连通分量（BCC）"><a href="#双连通分量（BCC）" class="headerlink" title="双连通分量（BCC）"></a>双连通分量（BCC）</h2><h3 id="v-BCC"><a href="#v-BCC" class="headerlink" title="v-BCC"></a>v-BCC</h3><h3 id="e-BCC"><a href="#e-BCC" class="headerlink" title="e-BCC"></a>e-BCC</h3><br />

<h2 id="仙人掌-圆方树"><a href="#仙人掌-圆方树" class="headerlink" title="仙人掌 &amp; 圆方树"></a>仙人掌 &amp; 圆方树</h2><br />

<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><h3 id="SPFA（队列优化的-Bellman-Ford）"><a href="#SPFA（队列优化的-Bellman-Ford）" class="headerlink" title="SPFA（队列优化的 Bellman-Ford）"></a>SPFA（队列优化的 Bellman-Ford）</h3><h3 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h3><h3 id="Johnson"><a href="#Johnson" class="headerlink" title="Johnson"></a>Johnson</h3><h3 id="0-1-BFS（双端队列-BFS）"><a href="#0-1-BFS（双端队列-BFS）" class="headerlink" title="0-1 BFS（双端队列 BFS）"></a>0-1 BFS（双端队列 BFS）</h3><h3 id="字典序最小最短路"><a href="#字典序最小最短路" class="headerlink" title="字典序最小最短路"></a>字典序最小最短路</h3><h3 id="同余最短路"><a href="#同余最短路" class="headerlink" title="同余最短路"></a>同余最短路</h3><br />

<h2 id="最小环"><a href="#最小环" class="headerlink" title="最小环"></a>最小环</h2><br />

<h2 id="最小斯坦纳树"><a href="#最小斯坦纳树" class="headerlink" title="最小斯坦纳树"></a>最小斯坦纳树</h2><br />

<h2 id="最小生成树（MST）"><a href="#最小生成树（MST）" class="headerlink" title="最小生成树（MST）"></a>最小生成树（MST）</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><br />

<h2 id="单度限制最小生成树"><a href="#单度限制最小生成树" class="headerlink" title="单度限制最小生成树"></a>单度限制最小生成树</h2><h2 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h2><h2 id="曼哈顿距离最小生成树"><a href="#曼哈顿距离最小生成树" class="headerlink" title="曼哈顿距离最小生成树"></a>曼哈顿距离最小生成树</h2><h2 id="最小差值生成树"><a href="#最小差值生成树" class="headerlink" title="最小差值生成树"></a>最小差值生成树</h2><h2 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h2><h3 id="朱刘算法"><a href="#朱刘算法" class="headerlink" title="朱刘算法"></a>朱刘算法</h3><br />

<h2 id="二分图判定（染色）"><a href="#二分图判定（染色）" class="headerlink" title="二分图判定（染色）"></a>二分图判定（染色）</h2><br />

<h2 id="二分图找奇环"><a href="#二分图找奇环" class="headerlink" title="二分图找奇环"></a>二分图找奇环</h2><br />

<h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h2><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><br />

<h2 id="带权二分图最大完美匹配"><a href="#带权二分图最大完美匹配" class="headerlink" title="带权二分图最大完美匹配"></a>带权二分图最大完美匹配</h2><h3 id="Kuhn–Munkres-算法"><a href="#Kuhn–Munkres-算法" class="headerlink" title="Kuhn–Munkres 算法"></a>Kuhn–Munkres 算法</h3><br />

<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><br />

<h2 id="强连通分量（SCC）"><a href="#强连通分量（SCC）" class="headerlink" title="强连通分量（SCC）"></a>强连通分量（SCC）</h2><br />

<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><br />

<h2 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h2><br />

<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h3><h3 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h3><h3 id="HLPP"><a href="#HLPP" class="headerlink" title="HLPP"></a>HLPP</h3><br />

<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><h3 id="Dijkstra-1"><a href="#Dijkstra-1" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><br />

<h2 id="三元环计数"><a href="#三元环计数" class="headerlink" title="三元环计数"></a>三元环计数</h2><br />

<h2 id="四元环计数"><a href="#四元环计数" class="headerlink" title="四元环计数"></a>四元环计数</h2><br />

<h2 id="树上问题"><a href="#树上问题" class="headerlink" title="树上问题"></a>树上问题</h2><h3 id="直径"><a href="#直径" class="headerlink" title="直径"></a>直径</h3><h3 id="重心"><a href="#重心" class="headerlink" title="重心"></a>重心</h3><h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><h3 id="点分树"><a href="#点分树" class="headerlink" title="点分树"></a>点分树</h3><h3 id="最近公共祖先（LCA）"><a href="#最近公共祖先（LCA）" class="headerlink" title="最近公共祖先（LCA）"></a>最近公共祖先（LCA）</h3><h4 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h4><h4 id="ST-表"><a href="#ST-表" class="headerlink" title="ST 表"></a>ST 表</h4><h4 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h4><h4 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h4><h4 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h4><h3 id="重链剖分（HLD）"><a href="#重链剖分（HLD）" class="headerlink" title="重链剖分（HLD）"></a>重链剖分（HLD）</h3><h3 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h3><h3 id="树上启发式合并（small-to-large）"><a href="#树上启发式合并（small-to-large）" class="headerlink" title="树上启发式合并（small to large）"></a>树上启发式合并（small to large）</h3><h4 id="按大小合并"><a href="#按大小合并" class="headerlink" title="按大小合并"></a>按大小合并</h4><h4 id="轻重儿子合并"><a href="#轻重儿子合并" class="headerlink" title="轻重儿子合并"></a>轻重儿子合并</h4><h3 id="树分块"><a href="#树分块" class="headerlink" title="树分块"></a>树分块</h3><h3 id="Prufer-序列"><a href="#Prufer-序列" class="headerlink" title="Prufer 序列"></a>Prufer 序列</h3><br />
<br />
<br />

<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="位运算笔记"><a href="#位运算笔记" class="headerlink" title="位运算笔记"></a>位运算笔记</h2><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><h3 id="区间位运算-trick（含-GCD）"><a href="#区间位运算-trick（含-GCD）" class="headerlink" title="区间位运算 trick（含 GCD）"></a>区间位运算 trick（含 GCD）</h3><br />

<h2 id="二分-三分"><a href="#二分-三分" class="headerlink" title="二分 三分"></a>二分 三分</h2><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><h3 id="0-1-分数规划"><a href="#0-1-分数规划" class="headerlink" title="0-1 分数规划"></a>0-1 分数规划</h3><h3 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h3><br />

<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="枚举排列"><a href="#枚举排列" class="headerlink" title="枚举排列"></a>枚举排列</h3><h3 id="枚举组合"><a href="#枚举组合" class="headerlink" title="枚举组合"></a>枚举组合</h3><h3 id="生成下一个排列"><a href="#生成下一个排列" class="headerlink" title="生成下一个排列"></a>生成下一个排列</h3><h3 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h3><h3 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h3><h3 id="枚举子集"><a href="#枚举子集" class="headerlink" title="枚举子集"></a>枚举子集</h3><h3 id="折半枚举"><a href="#折半枚举" class="headerlink" title="折半枚举"></a>折半枚举</h3><br />

<h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><br />

<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="算法思路整理"><a href="#算法思路整理" class="headerlink" title="算法思路整理"></a>算法思路整理</h3><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>AVL树（Adelson-Velsky和Landis树）是一种自平衡二叉搜索树。在这种树结构中，任何节点的两个子树的高度差最多为一，这有助于保持树的平衡，从而保证在最坏情况下操作（如查找、插入和删除）的时间复杂度为O(log n)，其中n是树中节点的数量。AVL树通过在每次插入或删除操作后进行一系列旋转操作来维持其平衡性。<br><a target="_blank" rel="noopener" href="https://www.cs.csub.edu/~msarr/visualizations/AVLtree.html">动画演示</a></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>自平衡性：AVL树的核心特征是它的自平衡性质。为了维持这一性质，它在每次插入或删除节点后，通过旋转来保证任何节点的左右子树高度差不超过1。</li>
<li>旋转操作：为了保持平衡，AVL树采用四种旋转操作：左旋、右旋、左右双旋和右左双旋。</li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Data-Structure/" class="category-chain-item">Data_Structure</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/Interview/" class="category-chain-item">Interview</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Data-Structure/" class="print-no-link">#Data Structure</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++_DataStructure_interview_master</div>
      <div>http://example.com/2024/02/26/Interview/C++_DataStructure_interview_master/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Aggie Lennon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/03/Interview/C++_DataStructure_interview_beginner/" title="C++_DataStructure_interview_beginner">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++_DataStructure_interview_beginner</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/25/Algorithms/SortingAlgorithms/BubbleSort/" title="BubbleSort">
                        <span class="hidden-mobile">BubbleSort</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      
<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
