

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Aggie Lennon">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++interview_guide">
<meta property="og:type" content="article">
<meta property="og:title" content="C++interview_guide">
<meta property="og:url" content="http://example.com/2024/02/24/Interview/C++interview/index.html">
<meta property="og:site_name" content="Aggie Lennon&#39;s Blog">
<meta property="og:description" content="C++interview_guide">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-23T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-24T15:08:04.400Z">
<meta property="article:author" content="Aggie Lennon">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++interview_guide - Aggie Lennon&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">C++interview_guide</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-24 00:00" pubdate>
          2024年2月24日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++interview_guide</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C-interview-guide"><a href="#C-interview-guide" class="headerlink" title="C++interview_guide"></a>C++interview_guide</h1><span id="more"></span>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的定义、种类、实现"><a href="#多态的定义、种类、实现" class="headerlink" title="多态的定义、种类、实现"></a>多态的定义、种类、实现</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>多态（Polymorphism）指的是能够使得一个接口（如方法或属性）被多种不同的类型实现，而表现出不同的行为。</p>
<h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ol>
<li>编译时多态（静态多态）：这种多态在编译期间就已经确定了对象调用哪个方法。最常见的实现方式是方法重载和运算符重载。</li>
</ol>
<ul>
<li>方法重载：在同一个类中存在多个同名方法，但它们的参数列表不同（参数类型、个数或顺序不同）。</li>
<li>运算符重载：对已有的运算符赋予多重含义，使得同一个运算符作用于不同类型的数据时有不同的行为。</li>
</ul>
<ol start="2">
<li>运行时多态（动态多态）：这种多态直到程序运行时才确定调用哪个方法。它主要通过继承（Inheritance）和接口（Interface）来实现。</li>
</ol>
<ul>
<li>继承：子类继承父类的方法和属性，可以对父类的方法进行重写（Override），当通过父类引用调用该方法时，实际执行的是子类重写的方法。</li>
<li>接口：类通过实现接口来实现多态。接口定义了一组方法规范，实现接口的类必须实现这些方法，但具体如何实现则由类自己决定。<br /></li>
</ul>
<h3 id="虚函数如何实现多态"><a href="#虚函数如何实现多态" class="headerlink" title="虚函数如何实现多态"></a>虚函数如何实现多态</h3><ol>
<li>声明虚函数：在基类中声明一个虚函数。这告诉编译器该函数在基类中可能不会有具体的实现，其实现可能会在任何派生类中出现。</li>
<li>重写虚函数：在一个或多个派生类中重写基类中声明的虚函数。重写的函数应该有相同的签名。</li>
<li>使用指针或引用调用：通过基类的指针或引用来调用虚函数。在运行时，根据对象的实际类型来决定调用哪个版本的虚函数。<br /></li>
</ol>
<h3 id="虚表指针什么时候产生"><a href="#虚表指针什么时候产生" class="headerlink" title="虚表指针什么时候产生"></a>虚表指针什么时候产生</h3><p>虚表指针（vptr）是实现C++运行时多态的一种机制，它指向一个虚表（vtable）。虚表是一个包含指向类的虚函数地址的数组。每个使用虚函数的类都有一个对应的虚表。当类中声明了虚函数时，编译器会自动为该类添加一个虚表指针。虚表指针的产生和初始化主要发生在以下时刻：</p>
<ol>
<li><p>对象构造时：当一个对象被创建时，如果它的类包含或继承了虚函数，编译器会在对象的内存布局中安插一个虚表指针（vptr）。这个指针指向类的虚表。在构造对象的过程中，构造函数会设置虚表指针指向正确的虚表，确保虚函数调用能够正确解析到该类或其基类中的实现。</p>
</li>
<li><p>派生类对象构造时：对于继承体系中的对象，每个构造函数（从基类到派生类）都可能修改其虚表指针，以指向其相应类级别的虚表。这是因为派生类可能覆盖（override）基类中的虚函数，需要确保虚函数调用解析到派生类中的最新实现。当构造派生类对象时，随着构造过程从基类到派生类的进行，虚表指针会被相应地更新，以反映派生类中虚函数的实现。</p>
</li>
<li><p>多态性使用时：虽然虚表指针在对象构造时产生并初始化，但它在对象的整个生命周期内发挥作用，使得运行时多态成为可能。每次通过基类的指针或引用调用虚函数时，程序会使用虚表指针找到正确的函数实现来执行。</p>
</li>
</ol>
<p>简而言之，虚表指针在对象的构造阶段产生，并根据对象所属的具体类在构造过程中被初始化指向适当的虚表。这个机制是C++实现运行时多态的关键。<br><br /></p>
<h3 id="虚函数表如何生成，是和类还是对象绑定"><a href="#虚函数表如何生成，是和类还是对象绑定" class="headerlink" title="虚函数表如何生成，是和类还是对象绑定"></a>虚函数表如何生成，是和类还是对象绑定</h3><h4 id="虚函数表的生成"><a href="#虚函数表的生成" class="headerlink" title="虚函数表的生成"></a>虚函数表的生成</h4><p>编译时生成：虚函数表是在编译时期为每个包含虚函数的类自动生成的。编译器会检查类定义中的所有虚函数，包括从基类继承的虚函数，并为它们在虚表中分配位置。如果派生类覆盖了基类中的虚函数，派生类的虚表中相应的条目会被更新为指向派生类中的函数实现。</p>
<h4 id="与类还是对象的绑定"><a href="#与类还是对象的绑定" class="headerlink" title="与类还是对象的绑定"></a>与类还是对象的绑定</h4><p>与类绑定：虚表与类绑定，而不是与单个对象绑定。每个类都有自己的虚表（如果它有虚函数的话），类的所有实例共享同一个虚表。这意味着虚表是静态的，对于类的所有实例来说都是相同的。<br><br /></p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是C++中的一个高级特性，用于在基类中声明一个接口，但不提供具体的实现。纯虚函数的声明以&#x3D; 0结尾，表明该函数没有实现体。拥有至少一个纯虚函数的类称为抽象类，这意味着它不能被实例化。纯虚函数的主要目的是强制派生类提供对该函数的实现，从而实现多态性。</p>
<h3 id="重载重写覆盖的区别，-子类重写了虚函数会对虚函数表有什么影响"><a href="#重载重写覆盖的区别，-子类重写了虚函数会对虚函数表有什么影响" class="headerlink" title="重载重写覆盖的区别， 子类重写了虚函数会对虚函数表有什么影响"></a>重载重写覆盖的区别， 子类重写了虚函数会对虚函数表有什么影响</h3><h4 id="重载-Overloading"><a href="#重载-Overloading" class="headerlink" title="重载 (Overloading)"></a>重载 (Overloading)</h4><p>重载是指在同一作用域中存在两个或两个以上的具有相同名称但参数列表不同的函数。重载关系到函数的静态多态性，编译器根据函数的参数类型和数量在编译时决定调用哪个函数。重载不影响虚函数表。</p>
<h4 id="重写（覆盖，Overriding）"><a href="#重写（覆盖，Overriding）" class="headerlink" title="重写（覆盖，Overriding）"></a>重写（覆盖，Overriding）</h4><p>重写（在一些文献中称为覆盖）发生在派生类中，当派生类定义一个与基类虚函数签名完全相同（函数名、参数列表、const属性等）的函数时，该函数将覆盖基类中的版本。重写是实现运行时多态的关键，它影响虚函数表。</p>
<p>对虚函数表的影响：当子类重写了基类的虚函数时，子类的虚函数表（vtable）中对应该函数的条目会被更新为指向子类中函数的指针。这确保了通过基类指针或引用调用虚函数时，能够执行到子类中重写的版本。</p>
<h4 id="隐藏（Hiding）"><a href="#隐藏（Hiding）" class="headerlink" title="隐藏（Hiding）"></a>隐藏（Hiding）</h4><p>隐藏发生在派生类中，当派生类定义了一个与基类中函数同名但参数列表不同（或者两个函数都是非虚函数）的函数时，派生类的函数会隐藏（而非重写）基类中所有同名的函数。这并不是多态，而是一种静态的、编译时的行为。<br><br /></p>
<h3 id="多继承的实现？可能出现什么问题"><a href="#多继承的实现？可能出现什么问题" class="headerlink" title="多继承的实现？可能出现什么问题"></a>多继承的实现？可能出现什么问题</h3><ol>
<li><p>菱形继承问题（钻石问题）：当两个基类继承自同一个祖先类，然后一个类又同时继承这两个基类时，会形成一个菱形继承结构。这会导致派生类间接继承了两份祖先类的成员，造成资源的冗余和访问歧义。<br>解决方法：C++中通过虚继承（使用virtual关键字）来解决这个问题，确保菱形继承中的最底层派生类只继承一个共同基类的单一实例。</p>
</li>
<li><p>歧义性：如果两个基类具有相同名称的成员，派生类在不明确指定的情况下访问这些成员会产生歧义。<br>解决方法：使用作用域解析运算符::来明确指定要访问的基类成员。</p>
</li>
<li><p>复杂性增加：多继承增加了类的设计和实现的复杂性，对于虚函数表的管理、构造函数和析构函数的调用顺序等都需要仔细处理，以避免错误和资源泄露。</p>
</li>
<li><p>效率问题：多继承可能会增加对象的大小（因为需要存储多个基类的vtable指针），并可能影响虚函数的调用效率。</p>
<br /></li>
</ol>
<h3 id="菱形继承下的类大小"><a href="#菱形继承下的类大小" class="headerlink" title="菱形继承下的类大小"></a>菱形继承下的类大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假设A的大小是a字节，B和C除了从A继承的成员外，没有额外的成员，D也是如此。</span><br>    A<br>   / \<br>  B   C<br>   \ /<br>    D<br></code></pre></td></tr></table></figure>
<h4 id="不使用虚继承时的类大小"><a href="#不使用虚继承时的类大小" class="headerlink" title="不使用虚继承时的类大小"></a>不使用虚继承时的类大小</h4><p>假设A的大小是a字节，B和C除了从A继承的成员外，没有额外的成员，D也是如此。<br>类D的大小将包括两份A的大小加上B和C的大小（如果B和C有额外的成员的话）。</p>
<h4 id="使用虚继承时的类大小"><a href="#使用虚继承时的类大小" class="headerlink" title="使用虚继承时的类大小"></a>使用虚继承时的类大小</h4><p>一份A的实例大小（因为虚继承）<br>B和C的虚基类指针（通常是指针大小，假设为4或8字节，取决于平台）<br>D自身的成员（如果有的话）<br><br /></p>
<h3 id="类实例的内存存储形式是什么样子的"><a href="#类实例的内存存储形式是什么样子的" class="headerlink" title="类实例的内存存储形式是什么样子的"></a>类实例的内存存储形式是什么样子的</h3><ul>
<li>非虚函数成员不影响对象的内存布局。它们的代码存在于程序的代码段中，类的每个实例共享对这些函数的访问，但不会在每个对象的内存布局中单独占用空间。</li>
<li>非静态成员变量存储在对象的内存空间中。它们的布局顺序通常遵循它们在类定义中的声明顺序，但编译器可能会进行内存对齐优化，这可能会影响实际的内存布局。如果存在继承，基类的成员变量通常先布局，后是派生类的成员变量。</li>
<li>类的每个实例中会包含一个虚表指针（vptr），指向与该类对应的虚函数表。这样，当通过基类指针或引用调用虚函数时，可以通过虚表指针查找到正确的函数实现，实现多态。虚继承可能引入额外的指针，如虚基类指针（vbptr），用于处理复杂的继承结构中的基类访问。<br /></li>
</ul>
<h3 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h3><ul>
<li>override关键字用于明确指示一个成员函数覆盖了基类中的一个虚函数。使用override时，如果声明的函数没有实际覆盖任何基类中的虚函数（比如由于函数签名不匹配），编译器将报错。</li>
<li>final关键字可以用在类或虚函数上。当用于类时，它阻止该类被继承。当用于虚函数时，它阻止虚函数在派生类中被进一步覆盖。<br /></li>
</ul>
<h3 id="基类不使用虚析构函数，会发生什么"><a href="#基类不使用虚析构函数，会发生什么" class="headerlink" title="基类不使用虚析构函数，会发生什么"></a>基类不使用虚析构函数，会发生什么</h3><p>基类不使用虚析构函数，当通过基类的指针来删除派生类的对象时，可能会发生未定义行为，通常这意味着派生类的析构函数不会被调用。这可能会导致派生类中分配的资源没有被正确释放，从而导致资源泄露等问题。<br><br /></p>
<h3 id="构造函数和析构函数能不能是虚函数，为什么"><a href="#构造函数和析构函数能不能是虚函数，为什么" class="headerlink" title="构造函数和析构函数能不能是虚函数，为什么"></a>构造函数和析构函数能不能是虚函数，为什么</h3><p>构造函数不能是虚函数是因为在对象构建阶段，虚拟机制还未建立，无法支持虚函数的调用机制。而析构函数可以（且在需要支持多态删除时应该）是虚函数，以确保对象通过基类指针被正确销毁，避免资源泄露和其他问题。<br><br /></p>
<h3 id="C-在构造函数和析构函数中的异常"><a href="#C-在构造函数和析构函数中的异常" class="headerlink" title="C++在构造函数和析构函数中的异常"></a>C++在构造函数和析构函数中的异常</h3><ul>
<li>构造函数和析构函数中抛出异常需要特别小心处理，因为它们在对象生命周期的关键点被调用，不当的异常处理可能会导致资源泄露、程序崩溃或其他未定义行为。</li>
</ul>
<h4 id="处理准则-构造"><a href="#处理准则-构造" class="headerlink" title="处理准则-构造"></a>处理准则-构造</h4><ul>
<li>C++11引入的智能指针（如std::unique_ptr和std::shared_ptr）可以自动管理资源，从而减少因异常而导致的资源泄露问题。</li>
<li>如果构造函数抛出异常，那么这个对象的构造过程被认为是未完成的，C++运行时系统不会为这个半构造的对象调用析构函数。</li>
<li>如果一个构造函数调用另一个可能抛出异常的函数，应该准备好捕获这些异常，或让它们传播出去，但同时确保所有已经分配的资源在异常传播前被清理。</li>
</ul>
<h4 id="处理准则-析构"><a href="#处理准则-析构" class="headerlink" title="处理准则-析构"></a>处理准则-析构</h4><ul>
<li>如果析构函数抛出异常而没有被捕获，程序将调用std::terminate，导致程序非正常退出。</li>
<li>在析构函数中捕获所有异常并吞掉它们（或记录下来），而不是让它们影响程序的其他部分。</li>
</ul>
<h5 id="RAII原则"><a href="#RAII原则" class="headerlink" title="RAII原则"></a>RAII原则</h5><ul>
<li>智能指针（如std::unique_ptr、std::shared_ptr）自动管理动态分配的内存。</li>
<li>标准容器（如std::vector、std::string）自动管理其元素的内存。</li>
<li>锁管理类（如std::lock_guard、std::unique_lock）自动管理锁的获取和释放，用于同步。<br />
<br /></li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>内存泄露是指程序分配的内存没有被正确释放，导致无法再次使用的情况。<br><br /></p>
<h3 id="智能指针有哪些"><a href="#智能指针有哪些" class="headerlink" title="智能指针有哪些"></a>智能指针有哪些</h3><ul>
<li>std::unique_ptr：提供独占所有权的智能指针，保证同一时间内只有一个std::unique_ptr指向给定的资源。当std::unique_ptr被销毁时，它所拥有的资源也会被释放。</li>
<li>std::shared_ptr：提供共享所有权的智能指针，允许多个std::shared_ptr实例指向同一个资源。资源会在最后一个引用它的std::shared_ptr被销毁时释放。</li>
<li>std::weak_ptr：与std::shared_ptr配合使用，提供一种不控制对象生命周期的智能指针。它用来解决std::shared_ptr相互引用时可能导致的循环引用问题。<br /></li>
</ul>
<h3 id="shared-ptr怎么实现多指针指向同一个地址"><a href="#shared-ptr怎么实现多指针指向同一个地址" class="headerlink" title="shared_ptr怎么实现多指针指向同一个地址"></a>shared_ptr怎么实现多指针指向同一个地址</h3><p>其核心原理是通过引用计数机制来实现的。每当一个新的std::shared_ptr指向某个资源时，该资源的引用计数会增加；当某个std::shared_ptr被销毁或者重新指向另一个资源时，原资源的引用计数会减少。当引用计数归零时，表示没有任何std::shared_ptr指向该资源，资源会被自动释放。<br>通常包含以下关键组件：</p>
<ul>
<li>控制块：每个资源都有一个与之关联的控制块（control block），控制块中存储了资源的引用计数和任何其他元数据（如自定义删除器）。</li>
<li>资源指针：std::shared_ptr内部包含一个指向管理的资源的指针。</li>
<li>对std::shared_ptr进行拷贝赋值或者销毁时，会相应地增加或减少控制块中的引用计数。<br>当多个std::shared_ptr指向同一个资源时，它们实际上是共享同一个控制块，而控制块中维护了资源的引用计数。这样，无论是哪个std::shared_ptr的操作（复制、赋值、销毁），都会通过控制块来更新引用计数，确保资源的生命周期正确管理。<br /></li>
</ul>
<h3 id="循环引用会在什么情况下产生，如何解决，解决的原理"><a href="#循环引用会在什么情况下产生，如何解决，解决的原理" class="headerlink" title="循环引用会在什么情况下产生，如何解决，解决的原理"></a>循环引用会在什么情况下产生，如何解决，解决的原理</h3><h4 id="发生情况"><a href="#发生情况" class="headerlink" title="发生情况"></a>发生情况</h4><p>循环引用通常发生在使用智能指针，特别是std::shared_ptr时，两个（或多个）对象互相持有对方的std::shared_ptr引用。这种情况下，即使外部对这些对象的引用全部消失，它们也不会被销毁，因为它们相互持有的引用使得引用计数永远不会降到零，导致内存泄漏。</p>
<h4 id="解决原理"><a href="#解决原理" class="headerlink" title="解决原理"></a>解决原理</h4><p>使用std::weak_ptr可以打破循环引用，因为它不会增加引用计数。这意味着即使两个对象互相引用，其中至少一个引用是weak_ptr，这个引用不会阻止对象被销毁。一旦外部对这些对象的shared_ptr引用被销毁，其中一个对象的引用计数会降到零，对象会被销毁。当一个对象被销毁时，它会释放对另一个对象的所有权，使得另一个对象的引用计数也能降到零，从而也被销毁。<br><br /></p>
<h3 id="智能指针构造与析构时间"><a href="#智能指针构造与析构时间" class="headerlink" title="智能指针构造与析构时间"></a>智能指针构造与析构时间</h3><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p>构造时间：当创建一个std::unique_ptr实例时，它会接管一个原始指针指向的对象的所有权。<br>析构时间：当std::unique_ptr对象离开其作用域或被显式删除时，它的析构函数会被调用。如果std::unique_ptr被赋予新的对象，它之前管理的对象也会被释放。</p>
<h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p>构造时间：构造发生在通过std::make_shared创建新对象、通过赋值操作共享所有权，或者通过拷贝构造函数复制一个std::shared_ptr时。<br>析构时间：析构发生在它离开作用域时，或者被显式重置或赋予新的对象时。当引用计数降到零时，所管理的对象和std::shared_ptr自身的控制块（包含引用计数和可能的自定义删除器）会被销毁。</p>
<h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h4><p>构造时间：通常是通过一个std::shared_ptr或另一个std::weak_ptr对象构造而来。<br>析构时间：当std::weak_ptr对象离开作用域或被重置时，其析构函数会被调用，但它不会导致所指向对象的销毁。当最后一个std::shared_ptr被销毁，std::weak_ptr会变成空（dangling），即指向一个已经被销毁的对象。<br><br /></p>
<h3 id="野指针的产生原因，解决方法"><a href="#野指针的产生原因，解决方法" class="headerlink" title="野指针的产生原因，解决方法"></a>野指针的产生原因，解决方法</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ol>
<li>未初始化的指针：声明指针变量但未初始化，它将指向一个随机内存地址。</li>
<li>释放后继续使用：指针指向的内存被释放（如通过delete或free），但指针没有被置为nullptr，之后再次使用这个指针会导致未定义行为。</li>
<li>指针运算错误：通过指针运算（如增加指针）让指针超出其原本指向的内存区域。</li>
<li>对象作用域结束：指针指向一个局部对象，而该对象的作用域已经结束，此时指针依然指向那个地址，但是那块内存可能已经被其他用途占用。</li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>初始化指针</li>
<li>使用智能指针</li>
<li>释放后置空</li>
<li>避免指针运算</li>
<li>确保在对象的生命周期结束后不再使用指针。<br />
<br /></li>
</ol>
<h2 id="STL设计模式"><a href="#STL设计模式" class="headerlink" title="STL设计模式"></a>STL设计模式</h2><h3 id="定义一个struct，有int-x，char-c两个成员，这个结构体的大小？"><a href="#定义一个struct，有int-x，char-c两个成员，这个结构体的大小？" class="headerlink" title="定义一个struct，有int x，char c两个成员，这个结构体的大小？"></a>定义一个struct，有int x，char c两个成员，这个结构体的大小？</h3><p>其大小为8字节。这个大小考虑到了结构体的对齐要求，即使char只需要1字节，int通常需要4字节，但由于内存对齐的需要，整个结构体占用的内存大小会被调整到合适的对齐边界。在大多数平台上，int类型的对齐要求是4字节，因此结构体的总大小被对齐到了8字节。</p>
<h4 id="如果增加一个static-int-这个结构体大小怎么变化？"><a href="#如果增加一个static-int-这个结构体大小怎么变化？" class="headerlink" title="如果增加一个static int 这个结构体大小怎么变化？"></a>如果增加一个static int 这个结构体大小怎么变化？</h4><p>​static成员变量是属于类的，而不是单个实例的。无论创建多少个实例，static成员只有一份拷贝，并且它的存储空间是在程序的数据段中，而不是存储在每个对象的内存布局中。<br><br /></p>
<h3 id="如果在结构体里定义一个虚函数，结构体大小怎么变化？"><a href="#如果在结构体里定义一个虚函数，结构体大小怎么变化？" class="headerlink" title="如果在结构体里定义一个虚函数，结构体大小怎么变化？"></a>如果在结构体里定义一个虚函数，结构体大小怎么变化？</h3><p>如果在结构体中定义一个虚函数，结构体的大小会增加，因为它需要存储一个指向虚函数表（vtable）的指针。虚函数表是一个存储类中所有虚函数地址的表，而指向这个表的指针（通常称为vptr）需要被存储在类或结构体的实例中。</p>
<h3 id="为什么要内存对齐？"><a href="#为什么要内存对齐？" class="headerlink" title="为什么要内存对齐？"></a>为什么要内存对齐？</h3><ol>
<li>提升访问速度： 对齐的数据可以一次性被读取，而非对齐的数据可能需要多次访问才能被完全读取。</li>
<li>硬件要求： 尝试访问未对齐的数据可能导致硬件异常，例如对齐错误（alignment fault）。</li>
<li>提高缓存利用率：对齐的数据更有可能被有效地缓存，因为缓存行通常也是按照一定的字节对齐的。这可以减少缓存未命中的次数，进一步提升性能。</li>
</ol>
<h3 id="inline与宏区别"><a href="#inline与宏区别" class="headerlink" title="inline与宏区别?"></a>inline与宏区别?</h3><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ul>
<li>宏不涉及类型安全。它们通过预处理器进行文本替换，不考虑任何类型问题，可能导致类型相关的错误。</li>
<li>inline函数是类型安全的，会进行类型检查，减少了类型错误的可能性。</li>
</ul>
<h4 id="编译器处理"><a href="#编译器处理" class="headerlink" title="编译器处理"></a>编译器处理</h4><ul>
<li>宏在预处理阶段就被处理，编译器看到的是已经替换后的代码。</li>
<li>inline函数在编译阶段处理，编译器根据函数的定义和函数调用的上下文决定是否内联展开。</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>宏的作用域从定义点开始，到文件结束或者被#undef指令撤销。</li>
<li>inline函数遵循C++的作用域和链接规则，有利于封装和模块化。</li>
</ul>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul>
<li>宏扩展后的代码可能难以调试，因为它们会展开成可能难以理解和追踪的形式。</li>
<li>inline函数在调试时通常更容易理解和追踪，因为它们保留了函数调用的形式。</li>
</ul>
<h4 id="参数计算"><a href="#参数计算" class="headerlink" title="参数计算"></a>参数计算</h4><ul>
<li>宏的参数在宏展开时会根据宏的定义重复计算，可能导致意外的副作用。</li>
<li>inline函数的参数和普通函数一样，只计算一次，避免了重复计算的问题。<br /></li>
</ul>
<h3 id="inline函数与普通函数区别？"><a href="#inline函数与普通函数区别？" class="headerlink" title="inline函数与普通函数区别？"></a>inline函数与普通函数区别？</h3><h4 id="编译器处理-1"><a href="#编译器处理-1" class="headerlink" title="编译器处理"></a>编译器处理</h4><ul>
<li>inline函数被设计为在调用点直接展开函数体，以减少函数调用的开销</li>
<li>普通函数在调用时，程序会跳转到函数定义处执行代码，执行完毕后再跳回到调用处继续执行。这个过程涉及到一系列的运行时开销。</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li>inline函数的主要目的是为了提升性能，特别是在函数体较小、调用频繁的情况下。将函数定义为inline可以减少函数调用的开销，提升程序的运行效率。</li>
<li>普通函数不会被自动展开，因此它们保留了正常的函数调用开销。在某些情况下，这种开销是可以接受的，特别是对于较大或者复杂度较高的函数。</li>
</ul>
<h4 id="使用场景和限制"><a href="#使用场景和限制" class="headerlink" title="使用场景和限制"></a>使用场景和限制</h4><ul>
<li>inline函数最适合用于简短、频繁调用的函数。</li>
<li>普通函数适用于执行较为复杂的任务，其代码体积较大或者不频繁调用的情况。<br /></li>
</ul>
<h3 id="什么时候会发生浅拷贝？深拷贝是什么？作用？怎么实现？"><a href="#什么时候会发生浅拷贝？深拷贝是什么？作用？怎么实现？" class="headerlink" title="什么时候会发生浅拷贝？深拷贝是什么？作用？怎么实现？"></a>什么时候会发生浅拷贝？深拷贝是什么？作用？怎么实现？</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝（Shallow Copy）发生在对象复制过程中，仅复制对象的每个成员及其值，而不复制指向的外部资源或指针指向的数据。<br>浅拷贝意味着复制后的对象的指针成员将指向与原对象相同的内存地址。这可能导致多个对象共享相同的资源，从而在一个对象释放这些资源时引发问题。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝（Deep Copy）在复制过程中不仅复制对象本身和其值，还包括对象指向的所有资源。<br>通过深拷贝，每个对象都有自己独立的资源副本，防止资源共享导致的问题，如悬挂指针和双重释放等。</p>
<h3 id="有哪些数据类型-强制类型转换的种类、区别"><a href="#有哪些数据类型-强制类型转换的种类、区别" class="headerlink" title="有哪些数据类型 强制类型转换的种类、区别"></a>有哪些数据类型 强制类型转换的种类、区别</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>整型（int, short, long, long long）用于存储整数。<br>浮点型（float, double, long double）用于存储小数。<br>字符型（char）用于存储单个字符。<br>布尔型（bool）用于存储真（true）或假（false）。</p>
<h4 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h4><p>数组<br>结构体（struct）<br>共用体（union）<br>枚举（enum）<br>类（class）</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ol>
<li>static_cast<type>(expression)</li>
</ol>
<ul>
<li>基本数据类型转换：基本数据类型之间的转换，如整型、浮点型等。</li>
<li>类层次结构中的上行转换： 派生类的指针或引用转换为基类的指针或引用。这是安全的转换。对于非多态类型的转换（没有虚函数的类，简单类型之间的转换）</li>
<li>void* 指针转换为具体类型指针</li>
</ul>
<ol start="2">
<li>dynamic_cast<type>(expression)</li>
</ol>
<ul>
<li>多态基类和派生类之间的转换： 有一个指向基类的指针或引用，但需要访问派生类中的成员或函数时，dynamic_cast 可以在运行时安全地转换类型，前提是这种转换在类型层次结构中是合理的。</li>
<li>在类的继承层次中，从基类向派生类的转换被称为向下转换。dynamic_cast 能够在运行时检查这种向下转换的安全性，如果转换不合法，则返回 nullptr（对于指针）或抛出 std::bad_cast 异常（对于引用）。</li>
</ul>
<ol start="3">
<li>const_cast</li>
</ol>
<ul>
<li>去除 const 属性：当你有一个 const 指针或引用，但需要将其传递给一个非 const 参数的函数时，你可以使用 const_cast 来去除 const 限定。</li>
<li>添加或去除 volatile 属性：虽然不常见，但 const_cast 也可以用来添加或去除变量的 volatile 属性。（阻止编译器对涉及该变量的代码进行某些形式的优化）</li>
</ul>
<ol start="4">
<li>reinterpret_cast</li>
</ol>
<ul>
<li>不相关类型之间的指针转换：例如，将 int* 转换为 double* 或将 void* 转换为具体类型的指针。</li>
<li>指针与足够大的整数类型之间的转换：有时候可能需要将指针存储在整型变量中，或者将整型变量转换回指针类型。<br /></li>
</ul>
<h3 id="类中静态变量的初始化是什么时候？"><a href="#类中静态变量的初始化是什么时候？" class="headerlink" title="类中静态变量的初始化是什么时候？"></a>类中静态变量的初始化是什么时候？</h3><h4 id="静态常量整数成员"><a href="#静态常量整数成员" class="headerlink" title="静态常量整数成员"></a>静态常量整数成员</h4><p>如果一个静态成员是常量整数类型的（或枚举类型）在类定义内部使用常量表达式初始化，则它会在编译时初始化。</p>
<h4 id="其他静态成员变量"><a href="#其他静态成员变量" class="headerlink" title="其他静态成员变量"></a>其他静态成员变量</h4><p>对于非局部静态变量它们在main函数开始执行前被初始化，这个过程称为动态初始化。具体的初始化顺序可能依赖于编译单元的链接顺序，这可能导致所谓的静态初始化顺序问题。</p>
<h4 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h4><p>如果静态变量是在函数内部定义的（即局部静态变量），那么它在该函数第一次执行到变量定义处时被初始化，且只初始化一次。<br><br /></p>
<h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>指的是那些表达式结束后依然存在的对象或函数。左值的特征是它们指向一个具体的内存位置，因此可以通过地址来访问。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>可寻址性：左值引用了存储在内存中的数据，因此你可以获取它的地址。</li>
<li>持久性：与临时创建的右值不同，左值在创建后会持续存在，直到其作用域结束。</li>
<li>可修改性（如果非const）：如果左值不是被const修饰的，你可以修改它引用的内存中的数据。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>内存操作</li>
<li>引用传递</li>
<li>持久存储<br /></li>
</ul>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>左值引用的定义使用符号&amp;紧跟在类型名之后，例如int&amp;是int类型的左值引用。声明左值引用时，必须立即初始化，因为引用必须绑定到具体的对象上。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>别名：左值引用为对象提供了别名，通过引用或原始名字都能访问同一内存位置。</li>
<li>必须初始化：在声明时必须初始化，不能存在悬空的引用。</li>
<li>不可重新绑定：一旦引用被初始化绑定到一个对象，就不能再绑定到另一个对象。</li>
<li>类型匹配：引用的类型必须与所引用对象的类型完全匹配（除了常量引用可以绑定到非常量对象）。</li>
</ul>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>函数参数传递</li>
<li>函数返回值</li>
<li>操作符重载<br /></li>
</ul>
<h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>右值通常指那些只能出现在赋值表达式右侧的表达式的结果。它们通常是临时的，不具有持久的内存地址，因此不能直接对它们取地址。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>临时性</li>
<li>不可取地址</li>
<li>移动语义：右值是移动语义和完美转发的关键，它们允许从临时对象“移动”资源，而不是复制资源，从而提高效率。<br /></li>
</ul>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>右值引用允许一个对象接管另一个对象的资源（比如动态分配的内存），这在处理临时对象（右值）时特别有用。通过这种方式，C++可以避免不必要的复制，从而提高效率。右值引用通过双字符&amp;&amp;来定义。</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>绑定到右值：右值引用可以绑定到临时对象（即右值）。</li>
<li>支持移动语义：通过右值引用，可以实现资源的转移。<br /></li>
</ul>
<h3 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>移动构造函数是一种特殊的构造函数，它接受一个同类型对象的右值引用作为参数，并从这个临时对象中“移动”数据到正在构建的对象中，而不是进行深拷贝。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当一个临时对象传递给一个函数，或从函数返回时，如果该类型定义了移动构造函数，编译器会选择使用移动构造函数而不是拷贝构造函数。移动构造函数直接接管原对象的资源（例如指向动态分配内存的指针），然后将原对象的指针设为nullptr或其它空状态。这样，原对象在销毁时不会释放已经转移的资源，从而避免不必要的资源复制，提高效率。<br><br /></p>
<h3 id="move的作用"><a href="#move的作用" class="headerlink" title="move的作用"></a>move的作用</h3><p>用于将对象转换为右值引用，从而允许资源的移动而非复制。它的作用是提示编译器一个对象可以安全地被“移动”，而不必进行深拷贝，这通常用于优化性能，尤其是对于资源管理密集型的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用示例</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">// 使用std::move后，vec1的资源被转移到vec2，vec1变为空</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec2 = std::<span class="hljs-built_in">move</span>(vec1);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;vec1 size: &quot;</span> &lt;&lt; vec1.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;vec2 size: &quot;</span> &lt;&lt; vec2.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出5</span><br>&#125;<br></code></pre></td></tr></table></figure>
<br />

<h3 id="类中默认构造函数"><a href="#类中默认构造函数" class="headerlink" title="类中默认构造函数"></a>类中默认构造函数</h3><ol>
<li>类没有定义任何构造函数时：编译器会自动生成一个默认的无参构造函数。</li>
<li>当类中含有其他对象成员且这些对象成员有默认构造函数时：编译器生成的默认构造函数会调用这些成员的默认构造函数来初始化对象。</li>
<li>类中含有默认成员初始化器时：在C++11及以后的版本中，你可以在类定义中直接为成员变量提供默认值。如果类中的成员变量被这种方式初始化，编译器同样会提供一个默认构造函数。<br /></li>
</ol>
<h3 id="拷贝构造函数和移动构造函数的区别？"><a href="#拷贝构造函数和移动构造函数的区别？" class="headerlink" title="拷贝构造函数和移动构造函数的区别？"></a>拷贝构造函数和移动构造函数的区别？</h3><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><ul>
<li>用途：通过使用另一个同类型对象的数据来初始化新对象。</li>
<li>工作方式：它创建一个新对象的深拷贝，这意味着被拷贝对象和新对象是完全独立的，对一个对象的修改不会影响到另一个对象。</li>
<li>形式：ClassName(const ClassName&amp; other);</li>
<li>场景：当你需要复制对象，且复制的结果应当与原始对象相互独立时使用。</li>
</ul>
<h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><ul>
<li>用途：在初始化新对象时，使用另一个同类型的临时对象（右值）的资源。</li>
<li>工作方式：它将资源从一个（临时）对象转移到另一个新对象，这通常通过改变资源的所有权来实现，而非复制。这样可以提高性能，避免不必要的复制。</li>
<li>形式：ClassName(ClassName&amp;&amp; other);</li>
<li>场景：用于临时对象或即将销毁的对象，它可以显著提高资源（如动态分配的内存）管理的效率。<br /></li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>它可以用于类的成员变量和成员函数、函数内的局部变量，以及全局变量和函数。</p>
<h4 id="类的静态成员变量"><a href="#类的静态成员变量" class="headerlink" title="类的静态成员变量"></a>类的静态成员变量</h4><ul>
<li>用途：声明类的静态成员变量，这意味着无论创建了多少对象，类的所有实例都共享同一个静态成员变量。</li>
<li>特点：</li>
<li><ul>
<li>需要在类的外部进行定义和初始化（除非是constexpr）。</li>
</ul>
</li>
<li><ul>
<li>可以通过类名直接访问，无需对象实例。</li>
</ul>
</li>
</ul>
<h4 id="类的静态成员函数"><a href="#类的静态成员函数" class="headerlink" title="类的静态成员函数"></a>类的静态成员函数</h4><ul>
<li>用途：声明类的静态成员函数。这些函数可以在没有类的对象实例的情况下调用。</li>
<li>特点：只能访问类的静态成员变量和其他静态成员函数。</li>
</ul>
<h4 id="局部静态变量-1"><a href="#局部静态变量-1" class="headerlink" title="局部静态变量"></a>局部静态变量</h4><ul>
<li>用途：在函数内部声明静态局部变量。这样的变量在函数第一次执行时初始化，并在函数调用之间保持其值。</li>
<li>特点：</li>
<li><ul>
<li>在程序执行期间只初始化一次，即使它在函数内部定义。</li>
</ul>
</li>
<li><ul>
<li>可以保持函数调用之间的状态，而不是像普通局部变量那样在函数退出时销毁。</li>
</ul>
</li>
</ul>
<h4 id="全局静态变量和函数"><a href="#全局静态变量和函数" class="headerlink" title="全局静态变量和函数"></a>全局静态变量和函数</h4><ul>
<li>用途：限制变量或函数的作用域到声明它们的文件内部。</li>
<li>特点：</li>
<li><ul>
<li>在其定义的文件之外不可见，从而避免了命名冲突。</li>
</ul>
</li>
<li><ul>
<li>对于变量和函数来说，这提供了一种封装的形式。<br /></li>
</ul>
</li>
</ul>
<h3 id="new与malloc的的区别？"><a href="#new与malloc的的区别？" class="headerlink" title="new与malloc的的区别？"></a>new与malloc的的区别？</h3><p>都是在C++和C语言中用于动态内存分配的</p>
<ol>
<li>语言</li>
</ol>
<ul>
<li>是C++引入的操作符。</li>
<li>是C语言中的库函数，也可以在C++中使用。</li>
</ul>
<ol start="2">
<li>构造函数和析构函数</li>
</ol>
<ul>
<li>分配内存的同时，会调用对象的构造函数来初始化对象。</li>
<li>仅仅分配内存，不会调用构造函数。</li>
</ul>
<ol start="3">
<li>返回类型</li>
</ol>
<ul>
<li>直接返回正确的类型指针，不需要类型转换。</li>
<li>返回void*，需要显式转换为目标类型的指针。</li>
</ul>
<ol start="4">
<li>分配失败时的行为</li>
</ol>
<ul>
<li>默认情况下，如果内存分配失败，会抛出一个std::bad_alloc异常。</li>
<li>分配失败时返回NULL。</li>
</ul>
<ol start="5">
<li>配对的释放操作</li>
</ol>
<ul>
<li>new：使用delete来释放</li>
<li>malloc：使用free来释放</li>
</ul>
<ol start="6">
<li>分配数组的处理</li>
</ol>
<ul>
<li>new：可以使用new[]来分配对象数组，并会调用每个元素的构造函数。释放时使用delete[]。</li>
<li>需要手动计算整个数组的大小，并且不会调用构造函数。释放时使用free。</li>
</ul>
<ol start="7">
<li>内存分配方式</li>
</ol>
<ul>
<li>new：可以被重载，允许自定义内存分配和释放的行为。</li>
<li>malloc：作为库函数，行为是固定的，不能被重载。<br /></li>
</ul>
<h3 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h3><p>const 关键字用于定义常量值，表示变量的值不可修改。</p>
<ol>
<li>常量变量<br>意味着这个变量的值在初始化后就不可更改。</li>
<li>指针和const<br>指向常量的指针：不能通过这个指针修改所指向的值，但指针本身可以改变，指向另一个地址。<br>常量指针：指针指向的地址不可更改，但可以修改所指向地址的值。<br>指向常量的常量指针：既不能修改指针指向的地址，也不能通过指针修改所指地址的值。</li>
<li>函数参数<br>可以避免函数内部意外改变输入参数的值，尤其是对于引用传递的情况。</li>
<li>成员函数后的const<br>在成员函数声明的结尾处使用 const，表示这个函数不会修改任何成员变量的值（除了那些用 mutable 声明的成员变量）。<br /></li>
</ol>
<h3 id="一个类在各种情况下取sizeof-的结果"><a href="#一个类在各种情况下取sizeof-的结果" class="headerlink" title="一个类在各种情况下取sizeof()的结果"></a>一个类在各种情况下取sizeof()的结果</h3><ol>
<li>空类：空类的大小为1字节，这是为了确保两个不同的对象有不同的地址。</li>
<li>包含非静态数据成员的类：类的大小至少等于所有非静态数据成员的大小之和，但可能会更大，因为编译器可能会添加填充字节来满足对齐要求。</li>
<li>包含静态数据成员的类：静态成员不计入类的大小，因为它们在类的所有实例之间共享。</li>
<li>包含虚函数的类：如果类包含虚函数，那么类的大小会增加，以存储指向虚函数表（vtable）的指针。这个指针的大小通常是一个指针的大小。</li>
<li>继承：派生类的大小至少等于基类的大小加上派生类自己的非静态成员大小，再加上可能的对齐填充。</li>
<li>虚继承：使用虚继承时，派生类将包含额外的信息（如指向虚基类表的指针），以管理虚基类与派生类之间的关系，这可能会增加派生类的大小。</li>
<li>多重继承：在多重继承中，派生类的大小会受到多个基类的影响，可能会包含多个基类的数据成员和虚函数表指针。</li>
<li>菱形继承（钻石问题）：在菱形继承中，如果使用了虚继承，可以避免基类的多份拷贝，但派生类的大小会受到额外的虚拟继承机制的影响。<br /></li>
</ol>
<h3 id="指针和引用的区别？"><a href="#指针和引用的区别？" class="headerlink" title="指针和引用的区别？"></a>指针和引用的区别？</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>指针：指针是一个变量，其值为另一个变量的地址。指针可以被重新赋值以指向另一个变量。</li>
<li>引用：引用是另一个变量的别名，一旦被初始化后，就不能改变引用的绑定关系，即不能重新引用到另一个变量。</li>
</ul>
<h4 id="语法区别"><a href="#语法区别" class="headerlink" title="语法区别"></a>语法区别</h4><ul>
<li>指针使用<em>进行定义，如int</em> ptr;。访问指针指向的值需要使用解引用操作符<em>，如</em>ptr。</li>
<li>引用使用&amp;进行定义，但在使用时不需要特殊符号，如int&amp; ref &#x3D; someVar;。</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>指针可以指向nullptr或者NULL，表示它不指向任何对象。</li>
<li>引用必须绑定到具体的对象，不能是空。</li>
</ul>
<h4 id="间接性"><a href="#间接性" class="headerlink" title="间接性"></a>间接性</h4><ul>
<li>指针可以有多级间接性，例如，指针的指针。</li>
<li>引用只能是一级间接性，不存在引用的引用。</li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li>指针可以进行算术运算（如指针加减），便于遍历数组。</li>
<li>引用不支持算术运算。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>指针更灵活，适用于动态内存管理、数组操作等需要地址计算的场景。</li>
<li>引用更安全易用，适用于需要操作原始数据但不希望复制数据的场景，如函数参数传递。<br /></li>
</ul>
<h3 id="什么是无效引用？"><a href="#什么是无效引用？" class="headerlink" title="什么是无效引用？"></a>什么是无效引用？</h3><p>无效引用是指引用了不合法或未定义内存区域的引用。</p>
<h4 id="1-引用悬挂"><a href="#1-引用悬挂" class="headerlink" title="1. 引用悬挂"></a>1. 引用悬挂</h4><p>当引用指向的对象被销毁或超出其作用域时，该引用仍然存在，但是它所引用的内存已经不再保留原有的对象数据。此时，引用成为悬挂引用，任何通过该引用的访问都是未定义行为。</p>
<h4 id="2-未初始化的引用"><a href="#2-未初始化的引用" class="headerlink" title="2. 未初始化的引用"></a>2. 未初始化的引用</h4><p>C++规定所有的引用在创建时必须被初始化，但如果通过非法手段（如类型转换）创建了一个未初始化的引用，这个引用就是无效的。</p>
<h4 id="避免无效引用的方法"><a href="#避免无效引用的方法" class="headerlink" title="避免无效引用的方法"></a>避免无效引用的方法</h4><ul>
<li>确保引用的生命周期不超过它所引用的对象。</li>
<li>避免返回局部变量的引用。</li>
<li>使用智能指针来管理动态分配的内存，而不是裸引用。<br /></li>
</ul>
<h3 id="调用函数的过程？"><a href="#调用函数的过程？" class="headerlink" title="调用函数的过程？"></a>调用函数的过程？</h3><h4 id="1-参数准备"><a href="#1-参数准备" class="headerlink" title="1. 参数准备"></a>1. 参数准备</h4><ul>
<li>参数传递：调用函数时，首先需要准备参数。这包括计算参数表达式的值，并按照函数定义的顺序将这些值传递给函数。参数可以通过值传递、引用传递或指针传递的方式传递给函数。</li>
<li>参数存储：传递的参数通常存储在调用栈（call stack）上，但具体细节依赖于编译器的实现和调用约定。</li>
</ul>
<h4 id="2-调用栈操作"><a href="#2-调用栈操作" class="headerlink" title="2. 调用栈操作"></a>2. 调用栈操作</h4><ul>
<li>栈帧：为当前调用的函数创建一个新的栈帧（stack frame）或激活记录（activation record）。栈帧包括返回地址、局部变量、保存的寄存器值等。</li>
<li>栈指针调整：调整栈指针（SP）以为新的栈帧腾出空间。</li>
</ul>
<h4 id="3-控制权转移"><a href="#3-控制权转移" class="headerlink" title="3. 控制权转移"></a>3. 控制权转移</h4><ul>
<li>执行跳转指令，将控制权转移到被调用函数的入口点。</li>
</ul>
<h4 id="4-函数执行"><a href="#4-函数执行" class="headerlink" title="4. 函数执行"></a>4. 函数执行</h4><ul>
<li>局部变量分配：在栈上为局部变量分配空间。</li>
<li>函数体执行：执行函数体中的语句。</li>
<li>资源管理：管理任何在函数执行过程中分配的资源。</li>
</ul>
<h4 id="5-返回值处理"><a href="#5-返回值处理" class="headerlink" title="5. 返回值处理"></a>5. 返回值处理</h4><ul>
<li>返回值：计算返回值（如果有）并将其传递回调用者。返回值可以通过寄存器或栈传递，这取决于返回值的类型和大小以及具体的调用约定。</li>
</ul>
<h4 id="6-控制权返回"><a href="#6-控制权返回" class="headerlink" title="6. 控制权返回"></a>6. 控制权返回</h4><ul>
<li>返回地址：利用栈帧中保存的返回地址，将控制权返回给调用者。</li>
<li>栈指针恢复：调整栈指针，移除当前函数的栈帧。</li>
</ul>
<h4 id="7-后续操作"><a href="#7-后续操作" class="headerlink" title="7. 后续操作"></a>7. 后续操作</h4><ul>
<li>处理函数的返回值（如果函数有返回值）。</li>
<li>继续执行调用函数之后的代码。<br /></li>
</ul>
<h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p>用于声明一个变量或函数的定义在另一个文件或编译单元中。它告诉编译器，该标识符的定义虽然在当前作用域可见，但其实际定义位于程序的其他地方。</p>
<h4 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h4><p>extern 通常用于全局变量的声明。当你在多个文件中使用同一个全局变量时，你需要在一个文件中定义该变量（无需extern），在其他文件中使用extern关键字来声明它，以避免重复定义错误。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>虽然对于函数来说，extern 是隐含的（即在一个文件中定义的函数自动对其他文件可见），但在某些情况下，显式使用extern可以增加代码的可读性。</p>
<h4 id="解决C和C-的兼容问题"><a href="#解决C和C-的兼容问题" class="headerlink" title="解决C和C++的兼容问题"></a>解决C和C++的兼容问题</h4><p>在混合使用C和C++时，extern “C” 被用来告诉C++编译器按照C的规则（不进行名称改编）来处理特定的函数或变量，从而使得C++代码能够调用C语言编写的库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// C 代码或声明...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C/" class="category-chain-item">C++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++interview_guide</div>
      <div>http://example.com/2024/02/24/Interview/C++interview/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Aggie Lennon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/24/C++_Design%20Patterns/Prototype_Pattern/" title="Prototype_Pattern">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Prototype_Pattern</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/23/C++_Design%20Patterns/Factory_Method_Pattern/" title="Factory_Method_Pattern">
                        <span class="hidden-mobile">Factory_Method_Pattern</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      
<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
