

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Aggie Lennon">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++ DataStructure interview">
<meta property="og:type" content="article">
<meta property="og:title" content="C++_DataStructure_interview_beginner">
<meta property="og:url" content="http://example.com/2024/03/03/Interview/C++_DataStructure_interview_beginner/index.html">
<meta property="og:site_name" content="Aggie Lennon&#39;s Blog">
<meta property="og:description" content="C++ DataStructure interview">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-02T21:26:09.000Z">
<meta property="article:modified_time" content="2024-03-04T02:32:47.384Z">
<meta property="article:author" content="Aggie Lennon">
<meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++_DataStructure_interview_beginner - Aggie Lennon&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">C++_DataStructure_interview_beginner</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-03 05:26" pubdate>
          2024年3月3日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++_DataStructure_interview_beginner</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C-DataStructure-interview"><a href="#C-DataStructure-interview" class="headerlink" title="C++ DataStructure interview"></a>C++ DataStructure interview</h1><span id="more"></span>
<p>@参考网站<a target="_blank" rel="noopener" href="https://tsejx.github.io/data-structure-and-algorithms-guidebook/data-structure/adt/stack">click to jump</a></p>
<h1 id="抽象类型"><a href="#抽象类型" class="headerlink" title="抽象类型"></a>抽象类型</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在C++中，栈（Stack）是一个后进先出（LIFO）的数据结构，可以使用标准模板库（STL）中的<stack>头文件中定义的stack类来实现。</p>
<h4 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h4><p>待补</p>
<h4 id="栈的底层实现"><a href="#栈的底层实现" class="headerlink" title="栈的底层实现"></a>栈的底层实现</h4><p>在 C++ 中，栈（Stack）通常是用一个动态数组或链表实现的。C++ 标准模板库（STL）中的 std::stack 容器适配器默认情况下是使用 std::deque 实现的，但它也可以配置为使用 std::vector 或 std::list。</p>
<h4 id="C-vector实现栈"><a href="#C-vector实现栈" class="headerlink" title="C++ vector实现栈"></a>C++ vector实现栈</h4><p>栈的实现可以通过动态数组（如vector）、链表或其他容器实现。以下是一个使用vector作为底层数据结构的栈实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;T&gt; elems; <span class="hljs-comment">// 使用vector作为底层容器</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; elem)</span> </span>&#123; <span class="hljs-comment">// 入栈</span><br>        elems.<span class="hljs-built_in">push_back</span>(elem);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 出栈</span><br>        <span class="hljs-keyword">if</span> (elems.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>);<br>        &#125;<br>        elems.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 查看栈顶元素</span><br>        <span class="hljs-keyword">if</span> (elems.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 检查栈是否为空</span><br>        <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 返回栈的大小</span><br>        <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="栈的种类"><a href="#栈的种类" class="headerlink" title="栈的种类"></a>栈的种类</h4><p>不同种类的栈主要是基于它们的 <strong>实现细节</strong> 和 <strong>用途</strong> 来区分的。</p>
<h5 id="顺序栈（Array-Stack）（待建立超链接）"><a href="#顺序栈（Array-Stack）（待建立超链接）" class="headerlink" title="顺序栈（Array Stack）（待建立超链接）"></a>顺序栈（Array Stack）（待建立超链接）</h5><ul>
<li>使用数组实现的栈。</li>
<li>有固定大小，可能需要手动管理数组的扩容。</li>
<li>提供快速的访问时间，因为它允许随机访问(数据可以以任意顺序被快速访问，而不需要按照顺序逐个查找)。</li>
<li>由于是连续内存，所以可能会有空间浪费。</li>
</ul>
<h5 id="链式栈-Linked-Stack-待建立超链接"><a href="#链式栈-Linked-Stack-待建立超链接" class="headerlink" title="链式栈(Linked Stack)(待建立超链接)"></a>链式栈(Linked Stack)(待建立超链接)</h5><ul>
<li>使用链表实现的栈。</li>
<li>大小可动态变化，不需要手动扩容。</li>
<li>访问时间较慢，因为需要通过指针遍历,属于顺序访问(为了读取特定数据，需要从起点开始按顺序查找直到找到所需信息)。</li>
<li>空间利用效率更高，没有空间浪费。</li>
</ul>
<h5 id="动态栈-Dynamic-Stack-待建立超链接"><a href="#动态栈-Dynamic-Stack-待建立超链接" class="headerlink" title="动态栈(Dynamic Stack)(待建立超链接)"></a>动态栈(Dynamic Stack)(待建立超链接)</h5><ul>
<li>可以无限增长的栈。</li>
<li>通常是基于数组实现的，但会在需要时自动扩容。</li>
</ul>
<h5 id="寄存器栈-Register-Stack-待建立超链接"><a href="#寄存器栈-Register-Stack-待建立超链接" class="headerlink" title="寄存器栈(Register Stack)(待建立超链接)"></a>寄存器栈(Register Stack)(待建立超链接)</h5><ul>
<li>直接使用CPU寄存器来实现的栈。</li>
<li>非常快速，但空间有限。</li>
</ul>
<h5 id="栈机-Stack-Machine-待建立超链接"><a href="#栈机-Stack-Machine-待建立超链接" class="headerlink" title="栈机(Stack Machine)(待建立超链接)"></a>栈机(Stack Machine)(待建立超链接)</h5><ul>
<li>一种计算模型，它的主要数据结构是栈，例如Java虚拟机中的操作数栈。<br /></li>
</ul>
<h3 id="高频问题"><a href="#高频问题" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-解释栈和队列的区别"><a href="#1-解释栈和队列的区别" class="headerlink" title="1. 解释栈和队列的区别"></a>1. 解释栈和队列的区别</h4><ul>
<li>栈是一种后进先出的数据结构，而队列是一种先进先出的数据结构。</li>
</ul>
<h4 id="2-给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配"><a href="#2-给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配" class="headerlink" title="2. 给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配"></a>2. 给定一个包含括号的字符串，如何使用栈来检查字符串中的括号是否匹配</h4><ul>
<li>遍历字符串，对于每个开括号，将其压入栈中。对于每个闭括号，检查栈顶元素是否为对应的开括号，如果是，则弹出栈顶元素；如果不是或栈为空，则括号不匹配。最终，如果栈为空，则括号匹配。</li>
</ul>
<h4 id="3-如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素"><a href="#3-如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素" class="headerlink" title="3. 如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素"></a>3. 如何实现一个具有getMin操作的栈，该操作能在常数时间内返回栈中的最小元素</h4><ul>
<li>使用两个栈：一个存储所有元素，另一个仅存储每个状态下的最小元素。每次入栈操作时，如果元素小于或等于“最小栈”的栈顶元素，也将其压入“最小栈”。出栈时，如果“主栈”的栈顶元素等于“最小栈”的栈顶元素，则同时从“最小栈”中弹出。</li>
</ul>
<h4 id="4-解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值"><a href="#4-解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值" class="headerlink" title="4. 解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值"></a>4. 解释逆波兰表达式（后缀表达式）和如何使用栈计算它的值</h4><ul>
<li>逆波兰表达式是一种算术表达式，其中运算符跟随其操作数。使用栈计算其值时，从左到右扫描表达式，遇到数字就压入栈中，遇到运算符就从栈中弹出两个元素进行计算，计算结果再压入栈中。最后，栈顶元素即为表达式的值。</li>
</ul>
<h4 id="5-如何使用栈对一个数组进行排序"><a href="#5-如何使用栈对一个数组进行排序" class="headerlink" title="5. 如何使用栈对一个数组进行排序"></a>5. 如何使用栈对一个数组进行排序</h4><ul>
<li>使用两个栈，一个作为输入栈，另一个作为空栈用于排序。重复以下过程：从输入栈中弹出一个元素，然后将排序栈中所有比它大的元素移回输入栈，直到找到适当的位置将该元素压入排序栈中。最终，排序栈中的元素即为排序后的数组。</li>
</ul>
<h4 id="6-给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素"><a href="#6-给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素" class="headerlink" title="6. 给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素"></a>6. 给定一个无序数组，如何使用栈找到每个元素右侧的第一个更大元素</h4><ul>
<li>遍历数组，对于每个元素，如果栈不为空且当前元素大于栈顶元素，则栈顶元素的右侧第一个更大元素就是当前元素。重复此过程直到栈为空或当前元素小于栈顶元素，然后将当前元素压入栈中。对于栈中剩余的元素，它们的右侧没有更大的元素。<br />
<br /></li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>队列（Queue）是一种先进先出（First In First Out, FIFO）的数据结构，它允许元素在队列的末尾位置被添加，并从队列的开始位置被移除。这种排队方式类似于现实生活中的队列——第一个加入队列的人也将是第一个得到服务并离开的人。</p>
<h4 id="图像表示-1"><a href="#图像表示-1" class="headerlink" title="图像表示"></a>图像表示</h4><p>待补</p>
<h4 id="队列的底层实现"><a href="#队列的底层实现" class="headerlink" title="队列的底层实现"></a>队列的底层实现</h4><p>在C++标准模板库（STL）中，queue是一个容器适配器，它给予程序员队列的功能。默认情况下，queue使用deque来实现，但也可以配置为使用list。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h4><p>在C++中实现一个队列可以通过多种方式完成，包括使用数组、链表、或者直接利用标准模板库（STL）中的容器如queue。这里，我将展示如何使用链表来手动实现一个简单的队列。</p>
<h4 id="数组版"><a href="#数组版" class="headerlink" title="数组版"></a>数组版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> front, rear, capacity;<br>    <span class="hljs-type">int</span>* queue;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Queue</span>(<span class="hljs-type">int</span> c) &#123;<br>        front = rear = <span class="hljs-number">0</span>;<br>        capacity = c;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Queue</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] queue;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to insert an element at the rear of the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == rear) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is full\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            queue[rear] = data;<br>            rear++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to delete an element from the front of the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (front == rear) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is empty\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rear - <span class="hljs-number">1</span>; i++) &#123;<br>                queue[i] = queue[i + <span class="hljs-number">1</span>];<br>            &#125;<br>            rear--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to print the elements of the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (front == rear) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is empty\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = front; i &lt; rear; i++) &#123;<br>            cout &lt;&lt; queue[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="链表版"><a href="#链表版" class="headerlink" title="链表版"></a>链表版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> d) : <span class="hljs-built_in">data</span>(d), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Node *front, *rear;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Queue</span>() &#123;<br>        front = rear = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Queue</span>() &#123;<br>        <span class="hljs-keyword">while</span> (front != <span class="hljs-literal">nullptr</span>) &#123;<br>            Node* temp = front;<br>            front = front-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to add an element to the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        <span class="hljs-keyword">if</span> (rear == <span class="hljs-literal">nullptr</span>) &#123;<br>            front = rear = temp;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        rear-&gt;next = temp;<br>        rear = temp;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to remove an element from queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Queue is empty\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node* temp = front;<br>        front = front-&gt;next;<br>        <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>) &#123;<br>            rear = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br><br>    <span class="hljs-comment">// Function to display the queue</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* temp = front;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            temp = temp-&gt;next;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="队列的种类"><a href="#队列的种类" class="headerlink" title="队列的种类"></a>队列的种类</h4><p>队列有多种类型，根据其特性和应用场景的不同</p>
<h5 id="线性队列（待建立超链接）"><a href="#线性队列（待建立超链接）" class="headerlink" title="线性队列（待建立超链接）"></a>线性队列（待建立超链接）</h5><p>线性队列：最基本的队列类型，遵循FIFO原则。</p>
<h5 id="循环队列（待建立超链接）"><a href="#循环队列（待建立超链接）" class="headerlink" title="循环队列（待建立超链接）"></a>循环队列（待建立超链接）</h5><p>循环队列：是一种使用固定大小的数组的线性数据结构，头尾相连形成环状。当队列满时，新元素的插入将回到数组的开始位置（如果那里有空间）。</p>
<h5 id="优先队列（待建立超链接）"><a href="#优先队列（待建立超链接）" class="headerlink" title="优先队列（待建立超链接）"></a>优先队列（待建立超链接）</h5><p>优先队列：在这种队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先被移除。优先队列不遵循FIFO原则。</p>
<h5 id="双端队列（待建立超链接）"><a href="#双端队列（待建立超链接）" class="headerlink" title="双端队列（待建立超链接）"></a>双端队列（待建立超链接）</h5><p>双端队列：双端队列是一个允许我们从两端插入和删除的队列。</p>
<h5 id="阻塞队列（待建立超链接）"><a href="#阻塞队列（待建立超链接）" class="headerlink" title="阻塞队列（待建立超链接）"></a>阻塞队列（待建立超链接）</h5><p>阻塞队列：通常用于线程间的协作，当队列为空时，从队列中获取元素的操作将会阻塞，直到有元素加入；同样，如果队列满了，添加元素的操作也会阻塞。</p>
<h5 id="并发队列（待建立超链接）"><a href="#并发队列（待建立超链接）" class="headerlink" title="并发队列（待建立超链接）"></a>并发队列（待建立超链接）</h5><p>并发队列：在多线程程序中使用，可以安全地允许多个线程同时从队列中添加或移除元素。<br><br /></p>
<h3 id="高频问题-1"><a href="#高频问题-1" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-解释队列和栈的区别"><a href="#1-解释队列和栈的区别" class="headerlink" title="1. 解释队列和栈的区别"></a>1. 解释队列和栈的区别</h4><ul>
<li>队列是一种先进先出（FIFO）的数据结构，而栈是一种后进先出（LIFO）的数据结构。</li>
</ul>
<h4 id="2-如何使用两个栈实现一个队列"><a href="#2-如何使用两个栈实现一个队列" class="headerlink" title="2. 如何使用两个栈实现一个队列"></a>2. 如何使用两个栈实现一个队列</h4><ul>
<li>使用两个栈，一个栈用于入队操作，另一个栈用于出队操作。当进行出队操作时，如果第二个栈为空，则将第一个栈中的所有元素弹出并压入第二个栈中，然后从第二个栈中弹出顶部元素。</li>
</ul>
<h4 id="3-如何使用队列实现栈"><a href="#3-如何使用队列实现栈" class="headerlink" title="3. 如何使用队列实现栈"></a>3. 如何使用队列实现栈</h4><ul>
<li>使用两个队列，一个队列用于存储栈的所有元素。对于“入栈”操作，将元素加入空队列中，然后将另一个队列中的所有元素依次出队并入队到这个队列中。这样新加入的元素就位于队列的前端，模拟了栈的顶端。对于“出栈”操作，直接从队列前端移除元素即可。</li>
</ul>
<h4 id="4-解释优先队列及其实现"><a href="#4-解释优先队列及其实现" class="headerlink" title="4. 解释优先队列及其实现"></a>4. 解释优先队列及其实现</h4><ul>
<li>优先队列是一种特殊类型的队列，其中每个元素都有一个优先级。元素被按优先级的顺序移除，而不是它们被添加到队列的顺序。优先队列通常用堆数据结构来实现，以支持高效的插入和删除最高（或最低）优先级元素的操作。</li>
</ul>
<h4 id="5-如何在不使用队列数据结构的情况下反转队列的前k个元素"><a href="#5-如何在不使用队列数据结构的情况下反转队列的前k个元素" class="headerlink" title="5. 如何在不使用队列数据结构的情况下反转队列的前k个元素"></a>5. 如何在不使用队列数据结构的情况下反转队列的前k个元素</h4><ul>
<li>可以使用一个栈和另一个队列来实现。首先，将队列的前k个元素依次出队并压入栈中，然后从栈中弹出所有元素并依次入队，最后将队列的剩余元素移动到队列前端，以保持它们的原始顺序。<br />
<br />
<br /></li>
</ul>
<h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="基础概念-2"><a href="#基础概念-2" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>数组是一种基础且广泛使用的数据结构，用于存储一系列相同类型的元素。数组中的每个元素都可以通过索引（或位置）直接访问。在大多数编程语言中，数组的索引通常从0开始。数组提供了一种高效的方式来存储和访问数据序列，是很多算法和其他数据结构的基础。</p>
<h4 id="图像表示-2"><a href="#图像表示-2" class="headerlink" title="图像表示"></a>图像表示</h4><p>待补</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h4><h5 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 声明一个静态数组</span><br><span class="hljs-type">int</span> staticArray[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 访问数组元素</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Element at index 2: &quot;</span> &lt;&lt; staticArray[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 修改数组元素</span><br>staticArray[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    std::cout &lt;&lt; staticArray[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>
<h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> size = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 动态分配数组</span><br><span class="hljs-type">int</span>* dynamicArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><br><span class="hljs-comment">// 初始化数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    dynamicArray[i] = i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 访问数组元素</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Element at index 2: &quot;</span> &lt;&lt; dynamicArray[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 修改数组元素</span><br>dynamicArray[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    std::cout &lt;&lt; dynamicArray[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 释放动态数组</span><br><span class="hljs-keyword">delete</span>[] dynamicArray;<br></code></pre></td></tr></table></figure>
<br />

<h3 id="高频问题-2"><a href="#高频问题-2" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-如何找到数组中的重复元素"><a href="#1-如何找到数组中的重复元素" class="headerlink" title="1. 如何找到数组中的重复元素"></a>1. 如何找到数组中的重复元素</h4><ul>
<li>这个问题通常涉及对数组的遍历，并使用哈希表来跟踪已经出现过的元素。另一种方法是先对数组排序，然后查找相邻元素是否相同。</li>
</ul>
<h4 id="2-在一个无序数组中如何找到第k大的元素"><a href="#2-在一个无序数组中如何找到第k大的元素" class="headerlink" title="2. 在一个无序数组中如何找到第k大的元素"></a>2. 在一个无序数组中如何找到第k大的元素</h4><ul>
<li>快速选择算法(待添加文章引用)</li>
<li>最小堆方法</li>
<li><ul>
<li>初始化堆：创建一个容量为k的最小堆。</li>
</ul>
</li>
<li><ul>
<li>填充堆：遍历数组中的前k个元素，并将它们依次加入到堆中。</li>
</ul>
</li>
<li><ul>
<li>处理剩余元素：继续遍历数组，对于每个新元素：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果它小于堆顶元素（即最小堆中的最小元素），则忽略它，因为我们只关心最大的k个元素。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果它大于堆顶元素，则将堆顶元素移除，并将新元素加入堆中。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>调整堆：每次加入新元素或移除堆顶元素后，重新调整堆以保持最小堆的性质。</li>
</ul>
</li>
<li><ul>
<li>获取结果：遍历完数组后，堆顶元素就是第k大的元素。</li>
</ul>
</li>
</ul>
<h4 id="3-如何合并两个已排序的数组"><a href="#3-如何合并两个已排序的数组" class="headerlink" title="3. 如何合并两个已排序的数组"></a>3. 如何合并两个已排序的数组</h4><ul>
<li>这个问题可以通过使用两个指针分别遍历这两个数组来解决，选择两个指针指向的较小元素放入新数组，然后移动对应的指针。</li>
</ul>
<h4 id="4-如何找出数组中的最大子数组和"><a href="#4-如何找出数组中的最大子数组和" class="headerlink" title="4. 如何找出数组中的最大子数组和"></a>4. 如何找出数组中的最大子数组和</h4><ul>
<li>Kadane算法(待添加文章引用)</li>
</ul>
<h4 id="5-如何找到数组中丢失的和多余的元素"><a href="#5-如何找到数组中丢失的和多余的元素" class="headerlink" title="5. 如何找到数组中丢失的和多余的元素"></a>5. 如何找到数组中丢失的和多余的元素</h4><ul>
<li>通过哈希表来解决，或者通过计算数组的和与预期和的差值来找到答案。</li>
</ul>
<h4 id="6-如何移除数组中的重复元素"><a href="#6-如何移除数组中的重复元素" class="headerlink" title="6. 如何移除数组中的重复元素"></a>6. 如何移除数组中的重复元素</h4><p>对于一个已排序的数组，可以使用双指针技术原地修改数组。对于未排序的数组，可能需要使用哈希表。</p>
<h4 id="7-数组中是否存在一对数字，其和等于给定值"><a href="#7-数组中是否存在一对数字，其和等于给定值" class="headerlink" title="7. 数组中是否存在一对数字，其和等于给定值"></a>7. 数组中是否存在一对数字，其和等于给定值</h4><p>对于一个未排序的数组，可以使用哈希表来存储已经遍历过的数字。对于一个已排序的数组，可以使用双指针技术。</p>
<h4 id="8-如何寻找数组中的主要元素（出现次数超过数组长度一半的元素）"><a href="#8-如何寻找数组中的主要元素（出现次数超过数组长度一半的元素）" class="headerlink" title="8. 如何寻找数组中的主要元素（出现次数超过数组长度一半的元素）"></a>8. 如何寻找数组中的主要元素（出现次数超过数组长度一半的元素）</h4><p>Boyer-Moore投票算法</p>
<h4 id="9-两个数组的交集是什么"><a href="#9-两个数组的交集是什么" class="headerlink" title="9. 两个数组的交集是什么"></a>9. 两个数组的交集是什么</h4><p>可以使用哈希表来解决这个问题，也可以先对两个数组进行排序，然后使用双指针技术<br><br /><br><br /></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基础概念-3"><a href="#基础概念-3" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>字符串是一种基本的数据结构，用于表示和存储文本数据。在编程中，字符串是由字符组成的序列。每个字符可以是字母、数字、空格、标点符号或其他符号。字符串在几乎所有编程语言中都是一个基本数据类型或类。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++实现"></a>C++实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建字符串</span><br>std::string str1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string str2 = <span class="hljs-string">&quot;World&quot;</span>;<br><br><span class="hljs-comment">// 字符串连接</span><br>std::string str3 = str1 + <span class="hljs-string">&quot; &quot;</span> + str2;<br>std::cout &lt;&lt; str3 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Hello World&quot;</span><br><br><span class="hljs-comment">// 获取字符串长度</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Length of str3: &quot;</span> &lt;&lt; str3.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Length of str3: 11&quot;</span><br><br><span class="hljs-comment">// 访问特定位置的字符</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;The first character of str3: &quot;</span> &lt;&lt; str3[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;The first character of str3: H&quot;</span><br><br><span class="hljs-comment">// 子字符串</span><br>std::string subStr = str3.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 从索引6开始的5个字符</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Substring of str3: &quot;</span> &lt;&lt; subStr &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Substring of str3: World&quot;</span><br><br><span class="hljs-comment">// 查找子字符串</span><br><span class="hljs-type">size_t</span> position = str3.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-keyword">if</span> (position != std::string::npos) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;&#x27;World&#x27; found at position: &quot;</span> &lt;&lt; position &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;&#x27;World&#x27; found at position: 6&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 替换子字符串</span><br>str3.<span class="hljs-built_in">replace</span>(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;C++&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;After replacement: &quot;</span> &lt;&lt; str3 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;After replacement: Hello C++&quot;</span><br><br></code></pre></td></tr></table></figure>
<br />
<br />

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>哈希函数：H(key): K -&gt; D , key ∈ K<br>又称散列表，是根据关键码值（Key value）而直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫作散列函数（Hash Function），存放记录的数组叫作哈希表（或散列表）。<br><br /></p>
<h3 id="哈希底层实现"><a href="#哈希底层实现" class="headerlink" title="哈希底层实现"></a>哈希底层实现</h3><p>独立于实现方法，大多数哈希表还会根据当前的负载因子（即元素数量与槽数量的比值）动态调整其大小，通常是通过重新哈希（rehashing）到一个更大的数组来实现。</p>
<h4 id="链地址法的哈希底层实现"><a href="#链地址法的哈希底层实现" class="headerlink" title="链地址法的哈希底层实现"></a>链地址法的哈希底层实现</h4><p>在链地址法中，哈希表是由一个数组实现的，数组的每个槽位（slot）通常包含一个链表的头指针。当插入一个新键值对时，哈希函数首先计算键的哈希码，这个哈希码随后被转换为数组索引。在该索引位置的链表中添加新元素。</p>
<h4 id="开放寻址法的哈希底层实现"><a href="#开放寻址法的哈希底层实现" class="headerlink" title="开放寻址法的哈希底层实现"></a>开放寻址法的哈希底层实现</h4><p>在开放寻址法中，所有元素直接存储在哈希表数组中，没有使用链表。当发生冲突时，按照某种系统的方式探测（probe）数组的其他位置，直到找到一个空槽位为止。</p>
<h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p>待补<br><br /></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>待补<br><br /></p>
<h3 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++实现"></a>C++实现</h3><p>unordered_map：一个关联容器，它使用哈希表来存储键值对。它允许基于键快速查找值。</p>
<p>unordered_set：一个集合容器，它使用哈希表来存储元素。它允许快速检查一个值是否存在于集合中。</p>
<p>unordered_multimap和unordered_multiset：这两种容器与unordered_map和unordered_set类似，但它们允许键重复，即它们可以存储多个相同键的元素。<br><br /></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>插入（Insert）：向哈希表中添加一个新的元素。<br>删除（Delete）：从哈希表中移除元素。<br>查找（Search）：在哈希表中查找一个特定的元素。<br><br /></p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>两个不同的关键码值经过散列函数处理后得到了相同的结果。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>当插入一个新的元素时，如果通过哈希函数计算得到的位置已经被占用，那么就根据某种探测序列去寻找下一个空闲的位置。这个探测序列可以是线性探测、二次探测或者双重散列等。</p>
<h5 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h5><p>当发生冲突时，按照顺序检查表中的下一个位置，直到找到一个空位。<br>不能简单地将要删除元素的位置置为空，因为这可能会中断查找其他元素时的探测序列。通常的解决方案是使用一个特殊标记来表示该位置曾经有元素但现在被删除了，这样查找操作在遇到这样的标记时可以继续探测下一个位置。</p>
<h5 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h5><p>当发生冲突时，使用一个二次函数来计算下一个探测的位置。</p>
<h5 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h5><p>使用第二个哈希函数来计算下一个探测的位置，这个第二个哈希函数与第一个不同。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优：不需要额外的存储空间来维护元素之间的关系，因为所有元素都存储在哈希表本身内部。<br>缺：当哈希表填充度较高时，可能需要进行多次探测才能找到空位，这会导致性能下降。因此，为了保持高效的操作性能，通常需要维护较低的装载因子（Load Factor），即元素数量与哈希表大小的比例。<br><br /></p>
<h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>链表法是通过将具有相同哈希值的所有元素放在同一个链表中来解决这个问题的。<br>为了提高效率，通常需要选择一个好的哈希函数，并且根据数据量动态地调整哈希表的大小，以保持较低的装载因子（load factor），即元素个数与槽位数的比值。装载因子越小，发生冲突的可能性就越低，链表法的效率也就越高。</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol>
<li><p>初始化哈希表：创建一个数组，数组的每个槽位（slot）对应一个链表的头指针。初始时，所有槽位都为空。</p>
</li>
<li><p>插入元素：当要插入一个新元素时，首先使用哈希函数计算该元素的哈希值，然后根据这个哈希值找到对应的槽位。如果该槽位为空，则直接在该槽位创建一个新的链表，并将元素作为链表的第一个节点；如果槽位已经有链表，则将新元素添加到链表的末尾或头部。</p>
</li>
<li><p>查找元素：要查找一个元素时，同样先计算其哈希值，然后访问对应槽位的链表，并在链表中顺序查找该元素。</p>
</li>
<li><p>删除元素：删除操作也需要先计算元素的哈希值，然后在对应槽位的链表中找到并删除该元素。</p>
</li>
</ol>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>优：实现简单，且在冲突不多时插入和查找操作的速度较快。<br>缺：如果哈希函数选得不好，或者数据分布不均匀，导致某些槽位的链表过长，则会影响哈希表的性能，使得查找和插入操作的时间复杂度接近于O(n)。<br><br /></p>
<h3 id="哈希函数构造方法"><a href="#哈希函数构造方法" class="headerlink" title="哈希函数构造方法"></a>哈希函数构造方法</h3><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>给定一个正整数m，对于任意的关键字key，通过计算key被m除后所得的余数r来作为这个关键字的哈希值，即哈希函数H(key) &#x3D; key mod m，其中”mod”表示求余数的数学运算。<br>这里的m通常被称为哈希表的大小，选取一个合适的m对于哈希表的性能至关重要。如果m选得不好，会导致许多关键字映射到同一个哈希值，这种现象称为“冲突”（Collision）。为了减少冲突，m通常选取为一个质数，并且与数据分布有关的特定模式无关。</p>
<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>取数据元素关键字中某些取值较均匀的数字位作为哈希地址的方法。 即当关键字的位数很多时，可以通过对关键字的各位进行分析，丢掉分布不均匀的位，作为哈希值。 它只适合于所有关键字值已知的情况。 通过分析分布情况把关键字取值区间转化为一个较小的关键字取值区间。</p>
<h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>折叠法的基本思想是将输入分割成几个部分，然后将这些部分以某种方式组合起来（通常是相加），以产生哈希值。</p>
<ol>
<li><p>将输入数据（如一个较长的数字或字符串）分割成几个长度相等的部分。如果输入数据的长度不是划分长度的整数倍，则可以在最后一个部分不足的位置上补零。</p>
</li>
<li><p>将这些部分进行相加或其他运算（如异或运算），得到一个总和或结果。</p>
</li>
<li><p>如果得到的总和或结果长度超过了哈希表大小，可以继续将其分割并折叠，直到其长度满足哈希表的要求。</p>
</li>
<li><p>最终得到的结果就是输入数据对应的哈希值。</p>
</li>
</ol>
<h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><ol>
<li><p>选择关键字：首先确定一个数字关键字（Key），这个关键字是将要被哈希处理的原始数据。</p>
</li>
<li><p>计算关键字的平方：将关键字乘以它自己，得到一个平方数。</p>
</li>
<li><p>取中间几位：从这个平方数中取出中间的几位数字。取多少位通常取决于所需哈希值的大小。</p>
</li>
<li><p>得到哈希值：所取出的这几位数字就是关键字的哈希值。</p>
<br /></li>
</ol>
<h3 id="如何衡量哈希表的性能"><a href="#如何衡量哈希表的性能" class="headerlink" title="如何衡量哈希表的性能"></a>如何衡量哈希表的性能</h3><p>散列函数的设计<br>哈希表的大小<br>冲突解决方法的效率<br>负载因子（即表中已填充位置的比例）<br><br /></p>
<h3 id="高频问题-3"><a href="#高频问题-3" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-什么是哈希表"><a href="#1-什么是哈希表" class="headerlink" title="1. 什么是哈希表"></a>1. 什么是哈希表</h4><ul>
<li>哈希表是一种使用哈希函数组织数据，以支持快速插入、删除和查找操作的数据结构。哈希函数将键转换为存储值的数组索引。理想情况下，哈希函数将键均匀地映射到数组中，但实际上可能会出现两个键映射到同一个索引的情况（称为冲突）。为了解决冲突，可以使用方法如链地址法（在每个数组索引处存储一个链表）或开放寻址法。</li>
</ul>
<h4 id="2-哈希表和数组、链表有什么区别"><a href="#2-哈希表和数组、链表有什么区别" class="headerlink" title="2. 哈希表和数组、链表有什么区别"></a>2. 哈希表和数组、链表有什么区别</h4><ul>
<li>哈希表：哈希表结合了数组的快速访问和链表的动态插入&#x2F;删除。它通过哈希函数快速定位数据的存储位置，但在处理冲突和哈希函数选择方面需要额外的考虑。</li>
</ul>
<h4 id="3-解释哈希函数和它如何工作"><a href="#3-解释哈希函数和它如何工作" class="headerlink" title="3. 解释哈希函数和它如何工作"></a>3. 解释哈希函数和它如何工作</h4><ul>
<li>哈希函数是将输入（或“键”）转换为数组索引的函数，以确定值在哈希表中的存储位置。理想的哈希函数应满足几个标准：一致性（相同的输入总是产生相同的输出）、高效计算、均匀分布（不同的输入应均匀地映射到不同的索引上，以减少冲突）。</li>
</ul>
<h4 id="4-如何解决哈希表中的冲突"><a href="#4-如何解决哈希表中的冲突" class="headerlink" title="4. 如何解决哈希表中的冲突"></a>4. 如何解决哈希表中的冲突</h4><ul>
<li>链地址法（Separate Chaining）：在每个哈希表索引处维护一个链表。如果多个键映射到同一个索引，它们都存储在这个索引的链表中。</li>
<li>开放寻址法（Open Addressing）：当发生冲突时，寻找另一个空闲位置来存储新元素。这种方法包括线性探测、二次探测和双重散列等策略。</li>
<li>双重散列（Double Hashing）：使用两个哈希函数而不是一个。当第一个哈希函数导致冲突时，使用第二个哈希函数来计算索引。</li>
</ul>
<h4 id="5-哈希表的时间复杂度是多少"><a href="#5-哈希表的时间复杂度是多少" class="headerlink" title="5.  哈希表的时间复杂度是多少"></a>5.  哈希表的时间复杂度是多少</h4><p>理想情况下（没有或很少冲突），哈希表的平均时间复杂度为O(1)。然而，在最坏的情况下（所有键都映射到同一个索引，或哈希表的加载因子很高导致大量冲突），时间复杂度可能恶化为O(n)，其中n是哈希表中元素的数量</p>
<h4 id="6-什么是加载因子"><a href="#6-什么是加载因子" class="headerlink" title="6. 什么是加载因子"></a>6. 什么是加载因子</h4><p>加载因子是哈希表中已填充位置与总位置数量的比率。它是衡量哈希表“满”程度的指标。加载因子的值越高，表明哈希表越满<br><br /><br><br /><br><br /></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>链表由一系列节点组成，每个节点包含两个部分：数据和对下一个节点的引用（在双向链表中，还有对前一个节点的引用）。这种结构允许在序列中高效地插入和删除元素。<br><br /></p>
<h3 id="图例-1"><a href="#图例-1" class="headerlink" title="图例"></a>图例</h3><p>待补<br><br /></p>
<h3 id="链表类型"><a href="#链表类型" class="headerlink" title="链表类型"></a>链表类型</h3><ul>
<li>单向链表：每个节点只有指向下一个节点的链接。易于实现，但只能单向遍历。</li>
<li>双向链表：每个节点有两个链接，一个指向前一个节点，另一个指向后一个节点。它允许双向遍历，但比单向链表占用更多内存。</li>
<li>循环链表：链表的尾部不是指向null，而是指回链表的头部或其他节点，形成一个圈。<br /></li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><p>实现一个单向链表（单链表）通常涉及定义两个主要的结构：节点（Node）和链表（LinkedList）本身。节点是链表的基本单位，包含数据部分和指向下一个节点的指针（或引用）。链表则是由这些节点按特定顺序连接而成的集合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> data) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;data = data;<br>        <span class="hljs-keyword">this</span>-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 在C++中，nullptr是C++11标准引入的，表示空指针</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* head;<br><br>    <span class="hljs-built_in">LinkedList</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;head = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;head = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* lastNode = <span class="hljs-keyword">this</span>-&gt;head;<br>        <span class="hljs-keyword">while</span> (lastNode-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            lastNode = lastNode-&gt;next;<br>        &#125;<br><br>        lastNode-&gt;next = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* currentNode = <span class="hljs-keyword">this</span>-&gt;head;<br>        <span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; currentNode-&gt;data &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            currentNode = currentNode-&gt;next;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;nullptr\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>实现一个双向链表（双链表）类似于实现单向链表，但每个节点会有两个指针（或引用）：一个指向前一个节点，另一个指向后一个节点。这允许双向遍历：从头到尾或从尾到头。下面是用Python实现双向链表的基本方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>    Node* prev;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">data</span>(data), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* head;<br><br>    <span class="hljs-built_in">DoublyLinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 向链表尾部添加节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            head = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* temp = head;<br>        <span class="hljs-keyword">while</span> (temp-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            temp = temp-&gt;next;<br>        &#125;<br>        <br>        temp-&gt;next = newNode;<br>        newNode-&gt;prev = temp;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表（从头到尾）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printListForward</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* temp = head;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="hljs-string">&quot; &lt;-&gt; &quot;</span>;<br>            temp = temp-&gt;next;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;nullptr\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表（从尾到头）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printListBackward</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* temp = head;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 空链表</span><br><br>        <span class="hljs-comment">// 移动到链表的末尾</span><br>        <span class="hljs-keyword">while</span> (temp-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            temp = temp-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 从尾到头打印</span><br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="hljs-string">&quot; &lt;-&gt; &quot;</span>;<br>            temp = temp-&gt;prev;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;nullptr\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">data</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularLinkedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Node* head;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CircularLinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 插入一个新节点到链表的末尾</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            head = newNode;<br>            head-&gt;next = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node* temp = head;<br>            <span class="hljs-keyword">while</span> (temp-&gt;next != head) &#123;<br>                temp = temp-&gt;next;<br>            &#125;<br>            temp-&gt;next = newNode;<br>            newNode-&gt;next = head;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除链表中的节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>        Node *curr = head, *prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (curr-&gt;data == value) &#123;<br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 删除的是头节点</span><br>                    <span class="hljs-comment">// 找到尾节点</span><br>                    Node* tail = head;<br>                    <span class="hljs-keyword">while</span> (tail-&gt;next != head) &#123;<br>                        tail = tail-&gt;next;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (tail == head) &#123; <span class="hljs-comment">// 只有一个节点</span><br>                        <span class="hljs-keyword">delete</span> head;<br>                        head = <span class="hljs-literal">nullptr</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        tail-&gt;next = head-&gt;next;<br>                        <span class="hljs-keyword">delete</span> head;<br>                        head = tail-&gt;next;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 删除的是非头节点</span><br>                    prev-&gt;next = curr-&gt;next;<br>                    <span class="hljs-keyword">delete</span> curr;<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            prev = curr;<br>            curr = curr-&gt;next;<br>        &#125; <span class="hljs-keyword">while</span> (curr != head);<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历循环链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;List is empty&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node* temp = head;<br>        <span class="hljs-keyword">do</span> &#123;<br>            std::cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            temp = temp-&gt;next;<br>        &#125; <span class="hljs-keyword">while</span> (temp != head);<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">CircularLinkedList</span>() &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        Node* curr = head;<br>        <span class="hljs-keyword">while</span> (curr-&gt;next != head) &#123;<br>            Node* next = curr-&gt;next;<br>            <span class="hljs-keyword">delete</span> curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> curr; <span class="hljs-comment">// 删除最后一个节点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<br />

<h3 id="高频问题-4"><a href="#高频问题-4" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-如何反转链表"><a href="#1-如何反转链表" class="headerlink" title="1. 如何反转链表"></a>1. 如何反转链表</h4><p>遍历链表，不断改变每个节点的next指针，使其指向前一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Node* <span class="hljs-title">reverse</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    Node* prev = <span class="hljs-literal">nullptr</span>;<br>    Node* current = head;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>        Node* next = current-&gt;next;<br>        current-&gt;next = prev;<br>        prev = current;<br>        current = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-如何检测链表中的环"><a href="#2-如何检测链表中的环" class="headerlink" title="2. 如何检测链表中的环"></a>2. 如何检测链表中的环</h4><p>创建两个指针，一个每次移动一个节点（慢），另一个每次移动两个节点（快）。如果链表中存在环，那么这两个指针最终会相遇。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Node* slow = head;<br>    Node* fast = head-&gt;next;<br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-如何合并两个排序的链表"><a href="#3-如何合并两个排序的链表" class="headerlink" title="3. 如何合并两个排序的链表"></a>3. 如何合并两个排序的链表</h4><p>合并两个已排序的链表可以通过递归或迭代来实现。在每一步中，你比较两个链表的头节点，并选择较小的一个作为合并后链表的下一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Node* <span class="hljs-title">mergeSortedLists</span><span class="hljs-params">(Node* l1, Node* l2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l2;<br>    <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l1;<br><br>    <span class="hljs-keyword">if</span> (l1-&gt;data &lt; l2-&gt;data) &#123;<br>        l1-&gt;next = <span class="hljs-built_in">mergeSortedLists</span>(l1-&gt;next, l2);<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        l2-&gt;next = <span class="hljs-built_in">mergeSortedLists</span>(l1, l2-&gt;next);<br>        <span class="hljs-keyword">return</span> l2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-如何找到链表的中间节点"><a href="#4-如何找到链表的中间节点" class="headerlink" title="4. 如何找到链表的中间节点"></a>4. 如何找到链表的中间节点</h4><p>找到链表的中间节点可以使用快慢指针方法。设置两个指针，一个每次前进一个节点，另一个每次前进两个节点。当快指针到达链表末尾时，慢指针将位于中间。</p>
<h4 id="5-如何从链表的末尾删除第n个节点"><a href="#5-如何从链表的末尾删除第n个节点" class="headerlink" title="5. 如何从链表的末尾删除第n个节点"></a>5. 如何从链表的末尾删除第n个节点</h4><p>首先遍历链表，计算出其长度。然后重新遍历到第(长度 - n)个节点，将其next指针指向next-&gt;next。<br><br /><br><br /><br><br /></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是计算机科学中一种非常重要的数据结构，用于表示具有层级关系的数据。在二叉树中，每个节点最多有两个子节点：通常称为“左子节点”和“右子节点”。<br><br /></p>
<h3 id="图例-2"><a href="#图例-2" class="headerlink" title="图例"></a>图例</h3><p>待补<br><br /></p>
<h3 id="二叉树类型"><a href="#二叉树类型" class="headerlink" title="二叉树类型"></a>二叉树类型</h3><ul>
<li>完全二叉树：除了最后一层外，每一层都被完全填满，并且所有节点都向左对齐。</li>
<li>满二叉树： 每个节点都有0个或2个子节点。</li>
<li>平衡二叉树： 任何两个叶子节点之间的高度差最多为1</li>
<li>二叉搜索树： 对于树中的每个节点，其左子树的所有元素都小于该节点，右子树的所有元素都大于该节点。<br /></li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;         <span class="hljs-comment">// 节点值</span><br>    TreeNode *left;  <span class="hljs-comment">// 指向左子节点的指针</span><br>    TreeNode *right; <span class="hljs-comment">// 指向右子节点的指针</span><br><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<br />

<h3 id="高频问题-5"><a href="#高频问题-5" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-如何实现二叉树的前序遍历"><a href="#1-如何实现二叉树的前序遍历" class="headerlink" title="1.如何实现二叉树的前序遍历"></a>1.如何实现二叉树的前序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>
<h4 id="2-如何实现二叉树的中序遍历"><a href="#2-如何实现二叉树的中序遍历" class="headerlink" title="2.如何实现二叉树的中序遍历"></a>2.如何实现二叉树的中序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;left);<br>        std::cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-如何实现二叉树的后序遍历"><a href="#3-如何实现二叉树的后序遍历" class="headerlink" title="3.如何实现二叉树的后序遍历"></a>3.如何实现二叉树的后序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>
<h4 id="4-如何检查一棵树是否是二叉搜索树"><a href="#4-如何检查一棵树是否是二叉搜索树" class="headerlink" title="4. 如何检查一棵树是否是二叉搜索树"></a>4. 如何检查一棵树是否是二叉搜索树</h4><p>在中序遍历中，对于BST，遍历的结果应该是严格递增的。如果遍历的结果不是递增的，则树不是BST。</p>
<h4 id="5-如何找到二叉树的高度"><a href="#5-如何找到二叉树的高度" class="headerlink" title="5. 如何找到二叉树的高度"></a>5. 如何找到二叉树的高度</h4><p>二叉树的高度可以通过递归地计算左右子树的高度来确定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">height</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">height</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="6-在二叉搜索树中插入一个节点"><a href="#6-在二叉搜索树中插入一个节点" class="headerlink" title="6. 在二叉搜索树中插入一个节点"></a>6. 在二叉搜索树中插入一个节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left, *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) &#123;<br>        root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="7-删除二叉搜索树中的一个节点"><a href="#7-删除二叉搜索树中的一个节点" class="headerlink" title="7. 删除二叉搜索树中的一个节点"></a>7. 删除二叉搜索树中的一个节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (key &lt; root-&gt;val) &#123;<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;val) &#123;<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) &#123;<br>            TreeNode* temp = root-&gt;right;<br>            <span class="hljs-keyword">delete</span> root;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            TreeNode* temp = root-&gt;left;<br>            <span class="hljs-keyword">delete</span> root;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>        TreeNode* temp = root-&gt;right;<br>        <span class="hljs-keyword">while</span> (temp-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            temp = temp-&gt;left;<br>        &#125;<br>        root-&gt;val = temp-&gt;val;<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, temp-&gt;val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="8-寻找二叉树的最近公共祖先"><a href="#8-寻找二叉树的最近公共祖先" class="headerlink" title="8.寻找二叉树的最近公共祖先"></a>8.寻找二叉树的最近公共祖先</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">return</span> left != <span class="hljs-literal">nullptr</span> ? left : right;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="9-实现二叉树的层次遍历"><a href="#9-实现二叉树的层次遍历" class="headerlink" title="9. 实现二叉树的层次遍历"></a>9. 实现二叉树的层次遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> result;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode* node = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            level.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<br />
<br />

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>红黑树是一种自平衡二叉搜索树，广泛应用于计算机科学中。它是为了解决普通二叉搜索树在最坏情况下会退化成链表，导致操作效率下降的问题而设计的。通过在树的结构上施加一些约束，红黑树保证在插入、删除和查找操作中最坏情况下的时间复杂度始终保持在O(log n)。<br><br /></p>
<h3 id="图例-3"><a href="#图例-3" class="headerlink" title="图例"></a>图例</h3><p>待补<br><br /></p>
<h3 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h3><ul>
<li>节点颜色：每个节点被染成红色或黑色。</li>
<li>根节点：根节点始终是黑色的。</li>
<li>红色节点规则：红色节点的两个子节点都是黑色的（即红色节点不能有红色的父节点或子节点）。</li>
<li>所有路径的黑色节点数目相同：从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li>
<li>叶子节点：所有叶子节点（NIL节点，树的末端）都是黑色的。<br /></li>
</ul>
<h3 id="C-中的应用"><a href="#C-中的应用" class="headerlink" title="C++中的应用"></a>C++中的应用</h3><p>std::map和std::set<br><br /></p>
<h3 id="高频问题-6"><a href="#高频问题-6" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-红黑树和AVL树有什么区别"><a href="#1-红黑树和AVL树有什么区别" class="headerlink" title="1. 红黑树和AVL树有什么区别"></a>1. 红黑树和AVL树有什么区别</h4><ul>
<li>平衡策略：AVL树通过维持严格的高度平衡来优化查找操作，而红黑树则通过颜色和部分平衡的条件来平衡插入和删除操作的效率。</li>
<li>操作效率：AVL树在查找操作中更快，而红黑树在插入和删除操作中更加高效。</li>
<li>内存占用：AVL树由于维护每个节点的高度信息，通常需要更多的内存。红黑树仅需要一个额外的比特来存储颜色信息。</li>
<li>应用场景：红黑树由于插入和删除操作的高效性，更适合用于实现那些插入和删除频繁的数据结构（如多种Map和Set实现）。而AVL树更适合那些查找操作远远多于插入和删除的场景。</li>
</ul>
<h4 id="2-红黑树的性质是什么"><a href="#2-红黑树的性质是什么" class="headerlink" title="2. 红黑树的性质是什么"></a>2. 红黑树的性质是什么</h4><ul>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点是黑色的。</li>
<li>红色节点的子节点必须是黑色的（即红色节点不能相邻）。</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
<li>所有叶子节点（NIL节点）都是黑色的。</li>
</ul>
<h4 id="3-红黑树的旋转操作是什么"><a href="#3-红黑树的旋转操作是什么" class="headerlink" title="3. 红黑树的旋转操作是什么"></a>3. 红黑树的旋转操作是什么</h4><p>旋转操作的目的是重新平衡树，以维护红黑树的性质。插入或删除节点可能会破坏红黑树的平衡性质（特别是连续两个红色节点或黑色节点数不平衡的性质）。通过旋转，可以重新组织树的结构，从而保持树的平衡。</p>
<ul>
<li>红黑树的旋转操作是维护树平衡的关键步骤之一。在插入或删除节点时，为了保持红黑树的性质，可能需要对树进行旋转。旋转操作主要有两种类型：左旋（Left Rotation）和右旋（Right Rotation）。</li>
<li>左旋</li>
<li><ul>
<li>将Y的左子节点变为X的右子节点。</li>
</ul>
</li>
<li><ul>
<li>将X的父节点（如果存在）设置为Y的父节点。</li>
</ul>
</li>
<li><ul>
<li>将X设置为Y的左子节点。<br>这个操作实际上是将Y提升到X的位置，同时将X降低到Y的左子节点的位置。</li>
</ul>
</li>
<li>右旋</li>
<li><ul>
<li>X的右子节点变为Y的左子节点。</li>
</ul>
</li>
<li><ul>
<li>将Y的父节点（如果存在）设置为X的父节点。</li>
</ul>
</li>
<li><ul>
<li>将Y设置为X的右子节点。<br>这个操作实际上是将X提升到Y的位置，同时将Y降低到X的右子节点的位置。</li>
</ul>
</li>
</ul>
<h4 id="4-插入新节点时，为什么新节点初始被着色为红色"><a href="#4-插入新节点时，为什么新节点初始被着色为红色" class="headerlink" title="4. 插入新节点时，为什么新节点初始被着色为红色"></a>4. 插入新节点时，为什么新节点初始被着色为红色</h4><ul>
<li>在红黑树中插入新节点时，初始将其着色为红色是为了维持树的黑色完美平衡性质。如果新节点是黑色的，可能会违反红黑树的性质，特别是在某些路径上的黑色节点数比其他路径多的情况。着色为红色后，只需进行少量的颜色更改和树旋转即可恢复平衡。<br />
<br /></li>
</ul>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>B树是一种自平衡的树数据结构，主要用于数据库和操作系统的文件系统。B树通过在每个节点中保持多个键和子节点指针来优化大量数据的存储和访问。它是为了有效地在磁盘或其他辅助存储设备上读写大型数据块而设计的。<br><br /></p>
<h3 id="图例-4"><a href="#图例-4" class="headerlink" title="图例"></a>图例</h3><p>待补<br><br /></p>
<h3 id="B树特性"><a href="#B树特性" class="headerlink" title="B树特性"></a>B树特性</h3><ul>
<li>节点最大和最小键数：B树的每个节点可以有多个键和子节点。节点可以包含的键和子节点的数量有上限和下限。</li>
<li>树的高度：B树的高度通常很低，即使是存储大量数据的B树也是如此。</li>
<li>节点分裂和合并：当节点中的键数量超过某个上限时，它会分裂成两个节点。相反，如果键的数量低于下限，则可能需要与相邻节点合并。</li>
<li>所有叶子节点在同一层：B树的所有叶子节点都位于同一层级，这意味着从树的根节点到任何叶子节点的路径长度相同。<br /></li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BTreeNode</span> &#123;<br>    <span class="hljs-type">int</span> *keys;             <span class="hljs-comment">// 存储键</span><br>    <span class="hljs-type">int</span> t;                 <span class="hljs-comment">// 最小度数（每个节点的最小键数）</span><br>    BTreeNode **C;         <span class="hljs-comment">// 指向子节点的指针数组</span><br>    <span class="hljs-type">int</span> n;                 <span class="hljs-comment">// 当前键数</span><br>    <span class="hljs-type">bool</span> leaf;             <span class="hljs-comment">// 是否为叶子节点的标志</span><br><br>    <span class="hljs-built_in">BTreeNode</span>(<span class="hljs-type">int</span> <span class="hljs-type">_t</span>, <span class="hljs-type">bool</span> _leaf) &#123;<br>        t = <span class="hljs-type">_t</span>;<br>        leaf = _leaf;<br>        keys = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>*t<span class="hljs-number">-1</span>];<br>        C = <span class="hljs-keyword">new</span> BTreeNode *[<span class="hljs-number">2</span>*t];<br>        n = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他B树函数...</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>
<br />

<h3 id="高频问题-7"><a href="#高频问题-7" class="headerlink" title="高频问题"></a>高频问题</h3><h4 id="1-B树的主要特点是什么"><a href="#1-B树的主要特点是什么" class="headerlink" title="1. B树的主要特点是什么"></a>1. B树的主要特点是什么</h4><ul>
<li>B树的主要特点包括它的多路平衡搜索树结构，每个节点可以有多个子节点和键。这减少了树的高度，优化了大量数据的存储和访问效率。B树是自平衡的，所有叶子节点都在同一层，这保证了操作的均匀性和效率。</li>
</ul>
<h4 id="2-B树和二叉搜索树有什么区别"><a href="#2-B树和二叉搜索树有什么区别" class="headerlink" title="2. B树和二叉搜索树有什么区别"></a>2. B树和二叉搜索树有什么区别</h4><ul>
<li>二叉搜索树（BST）的每个节点最多有两个子节点，而B树的每个节点可以有多个子节点和键。B树是为磁盘或其他外部存储设备优化的，能够减少读写次数，而BST通常用于内存中的数据结构。因此，B树在处理大量数据时更有效。</li>
</ul>
<h4 id="B树在数据库中的应用是什么"><a href="#B树在数据库中的应用是什么" class="headerlink" title="B树在数据库中的应用是什么"></a>B树在数据库中的应用是什么</h4><ul>
<li>在数据库中，B树通常用于实现索引。由于B树可以有效地处理大量数据，并且能够减少磁盘I&#x2F;O操作，它们非常适合用于数据库索引，以加快查询速度。</li>
</ul>
<h4 id="4-如何插入一个键到B树中"><a href="#4-如何插入一个键到B树中" class="headerlink" title="4. 如何插入一个键到B树中"></a>4. 如何插入一个键到B树中</h4><ul>
<li>插入一个键到B树中首先要找到应该插入的叶子节点。如果该节点有空间，直接插入；如果没有空间，节点需要分裂成两个，键会上升到父节点中。这个过程可能会递归地向上继续，直到根节点。<br>节点分裂是B树插入操作的关键部分，分为以下几个步骤：</li>
<li><ul>
<li>将新键插入到叶子节点的键列表中。</li>
</ul>
</li>
<li><ul>
<li>将包含新键的叶子节点分裂成两个节点。通常，这涉及到将节点中间的键（中值键）上升到父节点，并将其余键分配到两个新节点中。</li>
</ul>
</li>
<li><ul>
<li>如果上升的中值键导致父节点满了，这个过程会递归地向上继续，可能一直到根节点。</li>
</ul>
</li>
</ul>
<h4 id="5-B树的删除操作如何工作"><a href="#5-B树的删除操作如何工作" class="headerlink" title="5. B树的删除操作如何工作"></a>5. B树的删除操作如何工作</h4><ul>
<li>从B树中删除键可能涉及多种情况。如果键在叶子节点且删除后不违反节点最小键的限制，可以直接删除。否则，可能需要从相邻节点借键或与相邻节点合并。复杂的情况可能需要重新平衡整个树。</li>
</ul>
<h4 id="6-B树为什么适合大型存储设备"><a href="#6-B树为什么适合大型存储设备" class="headerlink" title="6. B树为什么适合大型存储设备"></a>6. B树为什么适合大型存储设备</h4><p>B树通过减少树的高度和优化节点键的数量减少了磁盘读写次数，这使得它特别适合用于大型存储设备。在磁盘等外部存储设备上，读写操作的成本比内存中操作高得多</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Data-Structure/" class="category-chain-item">Data_Structure</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/Interview/" class="category-chain-item">Interview</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Data-Structure/" class="print-no-link">#Data Structure</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++_DataStructure_interview_beginner</div>
      <div>http://example.com/2024/03/03/Interview/C++_DataStructure_interview_beginner/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Aggie Lennon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/26/Interview/C++_DataStructure_interview_master/" title="C++_DataStructure_interview_master">
                        <span class="hidden-mobile">C++_DataStructure_interview_master</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      
<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
